---- tfm_lua/pshy.games.pacmice.tfm.lua.txt
--- 
--- This script is a compilation of other scripts.
--- Compiler: pshy_merge (https://github.com/Pshy0/pshy_merge).
--- pshy version: v0.10.12
--- 
 
if __PSHY_PASTED__ then error("<b><r>\nYOU PASTED THE SCRIPT TWICE!!!</r></b>") end
do
local pshy = {}
pshy.PSHY_VERSION = "v0.10.12"
pshy.BUILD_TIME = "1663160972.1147456"
pshy.INIT_TIME = os.time()
math.randomseed(os.time())
if not _ENV then _ENV = _G end
_ENV.pshy = pshy
print(" ")
pshy.modules_list = pshy.modules_list or {}
pshy.modules_list[1] = {name = "pshy.compiler.require", file = "./lua/pshy/compiler/require.lua", start_line = 73, end_line = 120}
pshy.modules_list[2] = {name = "pshy.events", file = "./lua/pshy/events/init.lua", start_line = 123, end_line = 209}
pshy.modules_list[3] = {name = "pshy.utils.print", file = "./lua/pshy/utils/print.lua", start_line = 211, end_line = 238}
pshy.modules_list[4] = {name = "pshy.help.pages", file = "./lua/pshy/help/pages.lua", start_line = 241, end_line = 262}
pshy.modules_list[5] = {name = "pshy.commands.list", file = "./lua/pshy/commands/list/init.lua", start_line = 264, end_line = 283}
pshy.modules_list[6] = {name = "pshy.alternatives.chat", file = "./lua/pshy/alternatives/chat.lua", start_line = 285, end_line = 369}
pshy.modules_list[7] = {name = "pshy.room", file = "./lua/pshy/room.lua", start_line = 371, end_line = 401}
pshy.modules_list[8] = {name = "pshy.alternatives.timers", file = "./lua/pshy/alternatives/timers.lua", start_line = 403, end_line = 486}
pshy.modules_list[9] = {name = "pshy.players", file = "./lua/pshy/players/init.lua", start_line = 488, end_line = 539}
pshy.modules_list[10] = {name = "pshy.anticheats.ban", file = "./lua/pshy/anticheats/ban.lua", start_line = 541, end_line = 768}
pshy.modules_list[11] = {name = "pshy.perms", file = "./lua/pshy/perms.lua", start_line = 770, end_line = 1111}
pshy.modules_list[12] = {name = "pshy.anticheats.adminchat", file = "./lua/pshy/anticheats/adminchat.lua", start_line = 1113, end_line = 1157}
pshy.modules_list[13] = {name = "pshy.anticheats.loadersync", file = "./lua/pshy/anticheats/loadersync.lua", start_line = 1159, end_line = 1242}
pshy.modules_list[14] = {name = "pshy.bases.loopmore", file = "./lua/pshy/bases/loopmore.lua", start_line = 1244, end_line = 1360}
pshy.modules_list[15] = {name = "pshy.utils.strings", file = "./lua/pshy/utils/strings.lua", start_line = 1362, end_line = 1414}
pshy.modules_list[16] = {name = "pshy.ui.dialog", file = "./lua/pshy/ui/dialog.lua", start_line = 1416, end_line = 1486}
pshy.modules_list[17] = {name = "pshy.enums.colors", file = "./lua/pshy/enums/colors.lua", start_line = 1488, end_line = 1534}
pshy.modules_list[18] = {name = "pshy.utils.lua", file = "./lua/pshy/utils/lua.lua", start_line = 1536, end_line = 1588}
pshy.modules_list[19] = {name = "pshy.utils.tfm", file = "./lua/pshy/utils/tfm.lua", start_line = 1590, end_line = 1663}
pshy.modules_list[20] = {name = "pshy.utils.types", file = "./lua/pshy/utils/types.lua", start_line = 1665, end_line = 1842}
pshy.modules_list[21] = {name = "pshy.commands", file = "./lua/pshy/commands/init.lua", start_line = 1844, end_line = 2244}
pshy.modules_list[22] = {name = "pshy.ui.v1", file = "./lua/pshy/ui/v1.lua", start_line = 2246, end_line = 2330}
pshy.modules_list[23] = {name = "pshy.bases.scores", file = "./lua/pshy/bases/scores.lua", start_line = 2332, end_line = 2529}
pshy.modules_list[24] = {name = "pshy.bases.splashscreen", file = "./lua/pshy/bases/splashscreen.lua", start_line = 2531, end_line = 2589}
pshy.modules_list[25] = {name = "pshy.bases.version", file = "./lua/pshy/bases/version.lua", start_line = 2591, end_line = 2694}
pshy.modules_list[26] = {name = "pshy.utils.tfm_enum_fix", file = "./lua/pshy/utils/tfm_enum_fix.lua", start_line = 2696, end_line = 2710}
pshy.modules_list[27] = {name = "pshy.images.list", file = "./lua/pshy/images/list/init.lua", start_line = 2713, end_line = 2867}
pshy.modules_list[28] = {name = "pshy.images.list.bonuses", file = "./lua/pshy/images/list/bonuses.lua", start_line = 2869, end_line = 2903}
pshy.modules_list[29] = {name = "pshy.utils.tables", file = "./lua/pshy/utils/tables.lua", start_line = 2905, end_line = 3072}
pshy.modules_list[30] = {name = "pshy.bonuses.list", file = "./lua/pshy/bonuses/list/init.lua", start_line = 3074, end_line = 3080}
pshy.modules_list[31] = {name = "pshy.bonuses", file = "./lua/pshy/bonuses/init.lua", start_line = 3082, end_line = 3474}
pshy.modules_list[32] = {name = "pshy.bases.checkpoints", file = "./lua/pshy/bases/checkpoints.lua", start_line = 3476, end_line = 3576}
pshy.modules_list[33] = {name = "pshy.players.keyboard", file = "./lua/pshy/players/keyboard.lua", start_line = 3578, end_line = 3656}
pshy.modules_list[34] = {name = "pshy.bonuses.list.mario", file = "./lua/pshy/bonuses/list/mario.lua", start_line = 3658, end_line = 3823}
pshy.modules_list[35] = {name = "pshy.events.enable", file = "./lua/pshy/events/enable.lua", start_line = 3825, end_line = 3847}
pshy.modules_list[36] = {name = "pshy.events.disable", file = "./lua/pshy/events/disable.lua", start_line = 3849, end_line = 3873}
pshy.modules_list[37] = {name = "pshy.commands.list.modules", file = "./lua/pshy/commands/list/modules.lua", start_line = 3875, end_line = 3940}
pshy.modules_list[38] = {name = "pshy.enums.keycodes", file = "./lua/pshy/enums/keycodes.lua", start_line = 3942, end_line = 4015}
pshy.modules_list[39] = {name = "pshy.help", file = "./lua/pshy/help/init.lua", start_line = 4017, end_line = 4215}
pshy.modules_list[40] = {name = "pshy.commands.get_target_or_error", file = "./lua/pshy/commands/get_target_or_error.lua", start_line = 4217, end_line = 4236}
pshy.modules_list[41] = {name = "pshy.images.changeimage", file = "./lua/pshy/images/changeimage.lua", start_line = 4238, end_line = 4403}
pshy.modules_list[42] = {name = "pshy.utils.rotation", file = "./lua/pshy/utils/rotation.lua", start_line = 4405, end_line = 4498}
pshy.modules_list[43] = {name = "pshy.maps.list", file = "./lua/pshy/maps/list/init.lua", start_line = 4500, end_line = 4509}
pshy.modules_list[44] = {name = "pshy.rotations.list", file = "./lua/pshy/rotations/list/init.lua", start_line = 4511, end_line = 4548}
pshy.modules_list[45] = {name = "pshy.rotations.list.transformice", file = "./lua/pshy/rotations/list/transformice.lua", start_line = 4550, end_line = 4595}
pshy.modules_list[46] = {name = "pshy.rotations.newgame", file = "./lua/pshy/rotations/newgame.lua", start_line = 4597, end_line = 5164}
pshy.modules_list[47] = {name = "pshy.tools.fcplatform", file = "./lua/pshy/tools/fcplatform.lua", start_line = 5166, end_line = 5349}
pshy.modules_list[48] = {name = "pshy.tools.motd", file = "./lua/pshy/tools/motd.lua", start_line = 5351, end_line = 5429}
pshy.modules_list[49] = {name = "pshy.games.pacmice", file = "./lua/pshy/games/pacmice.lua", start_line = 5432, end_line = 6096}
pshy.modules = pshy.modules or {}
for i_module, module in ipairs(pshy.modules_list) do
	pshy.modules[module.name] = module
end
do
--- pshy.compiler.require
--
-- Define a `pshy.require` function.
-- The function behave like the Lua `require` one.
-- Calls to the function are also parsed by the compiler to include the right files.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
--
-- @preload
pshy = pshy or {}
--- List of functions to load after a new module have been loaded.
-- They will be called with the name of the loaded module.
pshy.require_postload_functions = {}
--- Load a module from the `pshy.modules` table.
-- Load a module if it have not been loaded already.
-- @param module_name The name of the module.
-- @param optional The module may or may not be loaded. If present, whatever the value, the compiler will ignore the call.
-- @return The module's return.
function pshy.require(module_name, optional)
local module = pshy.modules[module_name]
if not module then
if not optional then
print(string.format("<r>ERROR: <n>require: Module `%s` not found!", module_name))
end
return nil
end
if not module.loaded then
if module.loading then
error(string.format("<r> Module `%s` recursively required!", module_name))
end
module.loading = true
local success
success, module.value = pcall(module.load)
if not success then
if not optional then
error(string.format("<r>Loading %s:\n %s", module_name, module.value))
end
module.value = nil
end
module.loading = false
module.loaded = true
for i_postload_function, postload_function in ipairs(pshy.require_postload_functions) do
postload_function(module_name)
end
end
return pshy.modules[module_name].value
end
end
pshy.modules["pshy.compiler.require"].loaded = true
pshy.modules["pshy.events"].load = function()
--- pshy.events
--
-- Adds an event `eventInit(init_duration)` called when the script was loaded.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
pshy = pshy or {}
--- Namespace.
local events = {}
--- Set of events to minimize.
-- Minimized events will be faster but have less functionalities.
events.to_minimize = {}
events.to_minimize["eventEmotePlayed"] = true
events.to_minimize["eventKeyboard"] = true
events.to_minimize["eventPlayerCrouchKey"] = true
events.to_minimize["eventPlayerGetCheese"] = true
events.to_minimize["eventPlayerJumpKey"] = true
events.to_minimize["eventPlayerMeep"] = true
events.to_minimize["eventPlayerMeepKey"] = true
--- Events map.
-- The key is the event function name.
-- Values are tables with the following fields:
--	- module_names:			A list of module names corresponding to entries in `original_functions`.
--	- module_indices:		A map of module names corresponding to indices of entries in the other lists.
--	- original_functions:	A list of functions corresponding to the recovered event functions.
--	- functions:			A list of functions to run when this event runs. Fields may become dummy functions or be set back to the values from `original_functions`.
events.events = {}
--- Assertion variables.
local event_functions_created = false
--- Get all new event functions.
local function RecoverEventFunctions(last_module_name)
if event_functions_created ~= false then
print(string.format("<r>ERROR: <n>RecoverEventFunctions: Events were already created when processing `%s`!", last_module_name))
end
local event_functions = {}
local module = pshy.modules[last_module_name]
module.event_count = 0
for obj_name, obj in pairs(_ENV) do
if type(obj) == "function" then
if string.find(obj_name, "event", 1, true) == 1 then
event_functions[obj_name] = obj
module.event_count = module.event_count + 1
end
end
end
for event_name, event_function in pairs(event_functions) do
if not events.events[event_name] then
events.events[event_name] = {module_names = {}, module_indices = {}, functions = {}, original_functions = {}}
end
table.insert(events.events[event_name].module_names, last_module_name)
events.events[event_name].module_indices[last_module_name] = #events.events[event_name].module_names
table.insert(events.events[event_name].original_functions, event_function)
table.insert(events.events[event_name].functions, event_function)
_ENV[event_name] = nil
end
end
--- Create the event functions
-- A call to this is added by the compiler and run at the end of initialization.
function events.CreateFunctions()
assert(event_functions_created == false)
for event_name, event in pairs(events.events) do
local event_functions = event.functions
if not events.to_minimize[event_name] then
_ENV[event_name] = function(...)
for i_func, func in ipairs(event_functions) do
if (func(...) ~= nil) then
return
end
end
end
else
_ENV[event_name] = function(...)
for i_func, func in ipairs(event_functions) do
func(...)
end
end
end
end
event_functions_created = true
if eventInit then
local init_duration = os.time() - pshy.INIT_TIME
eventInit(init_duration)
end
end
--- Hook `pshy.require`:
table.insert(pshy.require_postload_functions, RecoverEventFunctions)
return events
end
do
--- pshy.utils.print
--
-- Custom print functions.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
--
-- @preload
pshy = pshy or {}
local function nothrow_format(format, ...)
local rst, rtn = pcall(string.format, format, ...)
return rtn
end
function print_debug(format, ...)
print("<bv>DEBUG: </bv>" .. nothrow_format(tostring(format), ...))
end
function print_info(format, ...)
print("<ch>INFO: </ch>" .. nothrow_format(tostring(format), ...))
end
function print_warn(format, ...)
print("<o>WARN: </o>" .. nothrow_format(tostring(format), ...))
end
function print_error(format, ...)
print("<r>ERROR: </r>" .. nothrow_format(tostring(format), ...))
end
function print_critical(format, ...)
print("<r>CRITICAL: </r>" .. nothrow_format(tostring(format), ...))
end
end
pshy.modules["pshy.utils.print"].loaded = true
pshy.modules["pshy.help.pages"].load = function()
--- pshy.help.pages
--
-- Base list for help pages.
--
-- @author tfm:Pshy#3752
--- Help pages.
-- Key is the name page.
-- Value is the help table (help page).
-- Help pages fields:
--	string:back			- upper page.
--	string:title		- title of the page.
--	string:text			- text to display at the top of the page.
--	set:commands		- set of chat command names.
--	set:examples		- map of action (string) -> command (string) (click to run).
--	set:subpages		- set of pages to be listed in that one at the bottom.
--	bool:restricted		- if true, require the permission "!help page_name"
local help_pages = {}
help_pages[""] = {title = "Main Help", text = "Use '<j>*</j>' to run a command on all players.\nPrefix commands with `<j>pshy.</j>` or <j>`other.`</j> in case of conflict.\n", details = "Commands syntax:\n\n<p align='left'><v>!command(aliases) &lt;required_argument&gt; [optional_argument]</v></p>\nCommands color code:\n\n<p align='left'><v>GREEN - Commands everyone can use (commands may still not allow some actions).<v>\n<j>YELLOW - Cheat commands that are enabled when an admin use `!enablecheats`.</j>\n<r>RED - Admin only commands.</r>\n<vi>PURPLE - Script loader only commands.</vi></p>\n", subpages = {}}
help_pages["pshy"] = {back = "", title = "Pshy", text = "Pshy version '<ch2>" .. tostring(pshy.PSHY_VERSION) .. "</ch2>'.\n", subpages = {}}
help_pages[""].subpages["pshy"] = help_pages["pshy"]
return help_pages
end
pshy.modules["pshy.commands.list"].load = function()
--- pshy.commands.list
--
-- The commands's list.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
--- Commands lists
-- keys represent the lowecase command name.
-- values are tables with the following fields:
-- - func: the function to run
--   the functions will take the player name as the first argument,
--   then the remaining ones.
-- - help: the help string to display when querying for help.
-- - arg_types: an array the argument types (not including the player name).
--   if arg_types is undefined then this is determined automatically.
-- - arg_names:
-- - no_user: true if the called function doesnt take the command user as
--   a first argument.
local command_list = {}
return command_list
end
pshy.modules["pshy.alternatives.chat"].load = function()
--- pshy.alternatives.chat
--
-- Adds chat for scripts ran in tribehouse.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
pshy.require("pshy.events")
pshy.require("pshy.utils.print")
local help_pages = pshy.require("pshy.help.pages")
local command_list = pshy.require("pshy.commands.list")
--- Namespace:
local alternative_chat = {}
--- Help page:
help_pages["pshy_alternatives"] = {title = "Alternatives", text = "Allow some scripts to run without all lua features.\n", commands = {}}
--- Module Settings:
alternative_chat.chat_arbitrary_id = 84
--- Internal use:
local have_sync_access = (tfm.exec.getPlayerSync() ~= nil)
local players_chats = {}									-- stores the last messages sent per player
local players_hidden_chats = {}								-- status of chats
--- Get an alternative player's chat content.
local function GetPlayerChatContent(player_name)
local chat = players_chats[player_name]
local total = ""
for i_line, line in ipairs(chat) do
total = "<n>" .. total .. line .. "</n>\n"
end
return total
end
--- Update an alternative player's chat.
local function UpdatePlayerChat(player_name)
if not players_hidden_chats[player_name] then
local text = GetPlayerChatContent(player_name)
ui.addTextArea(alternative_chat.chat_arbitrary_id, text, player_name, 0, 50, 400, nil, 0x0, 0x0, 1.0, true)
else
ui.removeTextArea(alternative_chat.chat_arbitrary_id, player_name)
end
end
--- Replacement for `tfm.exec.chatMessage`.
-- @TODO: only remove older chat messages if required.
local function chatMessage(message, player_name)
-- convert message
if type(message) ~= "string" then
message = tostring(message)
end
-- replace http and ://
message = message:gsub("http", "ht&#116;ps"):gsub("://", ":&#47;/")
-- params checks
if #message > 200 then
print_error("<fc>[Alt]</fc> chatMessage: message length is limited to 200!")
return
end
-- nil player value
if not player_name then
for player_name in pairs(tfm.get.room.playerList) do
chatMessage(message, player_name)
end
return
end
-- add message
players_chats[player_name] = players_chats[player_name] or {}
local chat = players_chats[player_name]
if #chat > 8 then
table.remove(chat, 1)
end
table.insert(chat, message)
-- display
UpdatePlayerChat(player_name)
end
--- !chat
local function ChatCommandChat(user)
players_hidden_chats[user] = not players_hidden_chats[user]
UpdatePlayerChat(user)
return true
end
command_list["chat"] = {perms = "everyone", func = ChatCommandChat, desc = "toggle the alternative chat", argc_min = 0, argc_max = 0}
help_pages["pshy_alternatives"].commands["chat"] = command_list["chat"]
function eventInit()
if not have_sync_access then
tfm.exec.chatMessage = chatMessage
chatMessage("This text area is replacing tfm.exec.chatMessage().")
chatMessage("Type <ch2>!chat</ch2> to toggle this text.")
end
end
return alternative_chat
end
pshy.modules["pshy.room"].load = function()
--- pshy.room
--
-- Provides basic room informations.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
pshy.require("pshy.events")
--- Namespace.
local room = {}
--- Module loader.
-- This is the person on who's account the script is running.
room.loader = string.match(({pcall(nil)})[2], "^(.-)%.")
--- Module launcher.
-- If there is only one player in the room then they are the launcher.
-- Otherwise the launcher will be set to the loader.
room.launcher = nil
for player_name in pairs(tfm.get.room.playerList) do
if room.launcher then
room.launcher = room.loader
break
end
room.launcher = player_name
end
--- Is the room private.
room.is_private = string.sub(tfm.get.room.name, 1, 1) == "@"
--- Is the room a tribehouse.
room.is_tribehouse = string.byte(tfm.get.room.name, 2) == 3
--- Is the room in funcorp mode.
-- In fact this will only tell if some features are available.
room.is_funcorp = tfm.exec.getPlayerSync() ~= nil
return room
end
pshy.modules["pshy.alternatives.timers"].load = function()
--- pshy.alternatives.timers
--
-- Adds timers for scripts ran in tribehouse.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
pshy.require("pshy.events")
pshy.require("pshy.utils.print")
local room = pshy.require("pshy.room")
--- Namespace:
local alternative_timers = {}
--- Internal use:
local have_sync_access = (tfm.exec.getPlayerSync() ~= nil)
local timers = {}								-- replacement for game timers
--- Replacement for `system.addTimer`.
-- @todo Test this.
local function newTimer(callback, time, loop, arg1, arg2, arg3, arg4)
-- params checks
if time < 500 then
print_error("<fc>[Alt]</fc> newTimer: minimum time is 500!")
return
end
-- find an id
local timer_id = 1
while timers[timer_id] do
timer_id = timer_id + 1
end
-- create
timers[timer_id] = {}
timer = timers[timer_id]
timer.timer_id = timer_id
timer.callback = callback
timer.time = time
timer.loop = loop
timer.arg1 = arg1
timer.arg2 = arg2
timer.arg3 = arg3
timer.arg4 = arg4
timer.next_run_time = os.time() + timer.time
return timer_id
end
--- Replacement for `system.removeTimer`.
local function removeTimer(timer_id)
if timer_id then
timers[timer_id] = nil
end
end
--- Run pending timers.
function alternative_timers.RunTimers()
local time = os.time()
if not have_sync_access then
local ended_timers = {}
local timers_copy = {}
local timers_cnt = 0
for i_timer, timer in pairs(timers) do
timers_copy[i_timer] = timer
timers_cnt = timers_cnt + 1
end
for i_timer, timer in pairs(timers_copy) do
if timer.next_run_time < time then
timer.callback(timer.timer_id, timer.arg1, timer.arg2, timer.arg3, timer.arg4)
if timer.loop then
timer.next_run_time = timer.next_run_time + timer.time -- math.min(, ..)
else
ended_timers[i_timer] = true
end
end
end
for i_ended_timer in pairs(ended_timers) do
timers[i_ended_timer] = nil
end
end
end
--- TFM event eventLoop.
function eventLoop()
alternative_timers.RunTimers()
end
function eventInit()
if not have_sync_access then
system.newTimer = newTimer
system.removeTimer = removeTimer
end
end
return alternative_timers
end
pshy.modules["pshy.players"].load = function()
--- pshy.players
--
-- A global `pshy.players` table to store players informations.
-- Other modules may add their fields to a player's table, using that module's prefix.
--
-- Player fields provided by this module:
--	- `name`:					The Name#0000 of the player.
--	- `tfm_player`:				The corresponding table entry in `tfm.get.room.playerList` when the player joined (not updated).
--	- `tag`:					The # tag of the player or nil for guests.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
pshy.require("pshy.events")
--- Namespace.
local players = {}
--- Module settings and public members:
players.list = {}							-- all player data saved in the module
players.in_room = {}						-- only players in the room
players.in_room_count = 0					-- count players in the room
--- Internal Use:
local player_list = players.list
local players_in_room = players.in_room
--- Ensure a table entry exist in `pshy.players` for a player, creating it if required.
-- Also set the default fields in the table.
-- @param player_name The Name#0000 if the player.
local function TouchPlayer(player_name)
if not player_list[player_name] then
local new_player = {}
new_player.name = player_name
new_player.tfm_player = tfm.get.room.playerList[player_name]
new_player.tag = string.match(player_name, "#....$")
player_list[player_name] = new_player
players_in_room[player_name] = new_player
else
players_in_room[player_name] = player_list[player_name]
end
end
function eventNewPlayer(player_name)
TouchPlayer(player_name)
players.in_room_count = players.in_room_count + 1
end
function eventPlayerLeft(player_name)
players_in_room[player_name] = nil
players.in_room_count = players.in_room_count - 1
end
--- Init:
-- Not using eventInit in order to make some features available early.
for player_name in pairs(tfm.get.room.playerList) do
TouchPlayer(player_name)
players.in_room_count = players.in_room_count + 1
end
return players
end
pshy.modules["pshy.anticheats.ban"].load = function()
--- pshy.anticheats.ban
--
-- Allow to ban players from the room.
-- Players are not realy made to leave the room, just prevented from playing.
--
-- You can also shadowban a player.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
local command_list = pshy.require("pshy.commands.list")
pshy.require("pshy.events")
local help_pages = pshy.require("pshy.help.pages")
local players = pshy.require("pshy.players")
local player_list = players.list			-- optimization
--- Module Help Page:
help_pages["pshy_ban"] = {restricted = true, back = "pshy", title = "Kick / Ban", text = "", commands = {}}
help_pages["pshy"].subpages["pshy_ban"] = help_pages["pshy_ban"]
--- Namespace.
local ban = {}
--- Public Members:
ban.banned_players = {}
ban.shadow_banned_players = {}
ban.shadowban_simulate_death = false
--- Internal use:
local player_list = players.list
local ban_mask_ui_arbitrary_id = 73
local pass_next_event_player_died = false
local banned_players = ban.banned_players
local shadow_banned_players = ban.shadow_banned_players
--- Override for `tfm.exec.respawnPlayer`.
local tfm_exec_respawnPlayer = tfm.exec.respawnPlayer
tfm.exec.respawnPlayer = function(player_name, ...)
if banned_players[player_name] then
return
end
return tfm_exec_respawnPlayer(player_name, ...)
end
--- Proceed with what have to be done on a banned player.
-- @param player_name The Name#0000 of the player to apply the ban effects on.
-- @private
local function ApplyBanEffects(player_name)
tfm.exec.removeCheese(player_name)
tfm.exec.movePlayer(player_name, -1001, -1001, false, 0, 0, true)
tfm.exec.killPlayer(player_name)
ui.addTextArea(ban_mask_ui_arbitrary_id, "", player_name, -999, -999, 800 + 2002, 400 + 2002, 0x111111, 0, 0.01, false)
tfm.exec.setPlayerScore(player_name, -1, false)
end
--- Ban a player from the running script (unban him on leave).
-- @param player_name The player's Name#0000.
-- @param reason The official ban reason.
function ban.KickPlayer(player_name, reason)
local player = player_list[player_name]
if player.banned then
return false, "This player is already banned."
end
banned_players[player_name] = player
player.kicked = true
player.banned = true
player.ban_reason = reason or "reason not provided"
ApplyBanEffects(player_name)
return true, string.format("%s script kicked (%s)", player_name, player.ban_reason)
end
command_list["kick"] = {perms = "admins", func = ban.KickPlayer, desc = "'Kick' a player from the script (they need to rejoin).", no_user = true, argc_min = 1, argc_max = 1, arg_types = {"player"}}
help_pages["pshy_ban"].commands["kick"] = command_list["kick"]
--- Ban a player from the running script.
-- @param player_name The player's Name#0000.
-- @param reason The official ban reason.
function ban.BanPlayer(player_name, reason)
local player = player_list[player_name]
if player.banned and not player.kicked then
return false, "This player is already banned."
end
banned_players[player_name] = player
player.kicked = false
player.banned = true
player.ban_reason = reason or "reason not provided"
ApplyBanEffects(player_name)
return true, string.format("%s script banned (%s)", player_name, player.ban_reason)
end
command_list["ban"] = {perms = "admins", func = ban.BanPlayer, desc = "'ban' a player from the script.", no_user = true, argc_min = 1, argc_max = 1, arg_types = {"player"}}
help_pages["pshy_ban"].commands["ban"] = command_list["ban"]
--- ShadowBan a player from the running script.
-- @param player_name The player's Name#0000.
-- @param reason A ban reason visible only to the room admins.
function ban.ShadowBanPlayer(player_name, reason)
local player = player_list[player_name]
shadow_banned_players[player_name] = player
player.kicked = false
player.banned = false
player.shadow_banned = true
player.shadow_ban_score = tfm.get.room.playerList[player_name].score
player.ban_reason = reason or "reason not provided"
-- simulate the player's death
pass_next_event_player_died = true
eventPlayerDied(player_name)
return true, string.format("%s script shadowbanned (%s)", player_name, player.ban_reason)
end
command_list["shadowban"] = {perms = "admins", func = ban.ShadowBanPlayer, desc = "Disable most of the script's features for this player.", no_user = true, argc_min = 1, argc_max = 1, arg_types = {"player"}}
help_pages["pshy_ban"].commands["shadowban"] = command_list["shadowban"]
--- Unban a player
function ban.UnbanPlayer(player_name)
local player = player_list[player_name]
if not player then
return false, "This player does not exist."
end
if not player.kicked and not player.banned and not player.shadow_banned then
return false, "This player is not banned."
end
banned_players[player_name] = nil
shadow_banned_players[player_name] = nil
player.kicked = false
player.banned = false
player.shadow_banned = false
ui.removeTextArea(ban_mask_ui_arbitrary_id, player_name)
return true, string.format("Unbanned %s.", player_name)
end
command_list["unban"] = {perms = "admins", func = ban.UnbanPlayer, desc = "Unban a player from the room.", no_user = true, argc_min = 1, argc_max = 1, arg_types = {"string"}}
help_pages["pshy_ban"].commands["unban"] = command_list["unban"]
--- TFM event eventNewPlayer.
-- Apply ban effects on banned players who rejoined.
function eventNewPlayer(player_name)
if banned_players[player_name] then
ApplyBanEffects(player_name)
end
end
--- TFM event eventPlayerLeft.
-- Remove the ban for kicked players.
function eventPlayerLeft(player_name)
local player = banned_players[player_name]
if player and player.kicked then
banned_players[player_name] = nil
player.kicked = false
player.banned = false
end
end
--- TFM event eventNewGame.
-- Apply the ban effects on banned players.
function eventNewGame()
for player_name in pairs(banned_players) do
if tfm.get.room.playerList[player_name] then
ApplyBanEffects(player_name)
end
end
for player_name in pairs(shadow_banned_players) do
if tfm.get.room.playerList[player_name] then
if not banned_players[player_name] then
pass_next_event_player_died = true
eventPlayerDied(player_name)
end
end
end
end
function eventPlayerDied(player_name)
-- ignore shadowbanned player's win
local player = player_list[player_name]
if (player.shadow_banned and ban.shadowban_simulate_death) or player.banned then
if pass_next_event_player_died then
pass_next_event_player_died = false
return
end
return false
end
-- make shadowbanneds dead (cause ban to function on Floor Is Random)
if ban.shadowban_simulate_death then
for player_name in pairs(shadow_banned_players) do
if tfm.get.room.playerList[player_name] then
tfm.get.room.playerList[player_name].isDead = true
end
end
end
end
--- TFM event eventPlayerRespawn.
-- Apply the ban effects on banned players who respawn.
function eventPlayerRespawn(player_name)
if banned_players[player_name] then
ApplyBanEffects(player_name)
elseif ban.shadowban_simulate_death and shadow_banned_players[player_name] then
tfm.exec.killPlayer(player_name)
end
end
--- TFM event eventChatCommand.
-- Return false for banned players to hope that the command processing will be canceled.
function eventChatCommand(player_name, message)
if banned_players[player_name] then
return false
end
end
--- TFM event eventPlayerWon.
-- Cancel this event for shadow_banned players.
-- Also override the player's score in `tfm.get.room.playerList`.
function eventPlayerWon(player_name)
if player_list[player_name].shadow_banned then
local player = player_list[player_name]
player.won = false
tfm.exec.setPlayerScore(player_name, player.shadow_ban_score, false)
tfm.get.room.playerList[player_name].score = player.shadow_ban_score
return false
end
end
--- TFM event eventPlayerGetCheese.
-- Cancel this event for shadow_banned players.
function eventPlayerGetCheese(player_name)
if player_list[player_name].shadow_banned then
return false
end
end
function eventPlayerBonusGrabbed(player_name)
if shadow_banned_players[player_name] then
return false
end
end
--- Display a list of banned players.
local function ChatCommandBanlist(user)
tfm.exec.chatMessage("<r><b>SCRIPT-BANNED PLAYERS:</b></r>", user)
for player_name, player in pairs(player_list) do
if player.kicked then
tfm.exec.chatMessage(string.format("<j>%s KICKED:<j> %s", player_name, player.ban_reason), user)
elseif player.banned then
tfm.exec.chatMessage(string.format("<r>%s BANNED:<r> %s", player_name, player.ban_reason), user)
elseif player.shadow_banned then
tfm.exec.chatMessage(string.format("<vi>%s SHADOW BANNED:<vi> %s", player_name, player.ban_reason), user)
end
end
return true
end
command_list["banlist"] = {perms = "admins", func = ChatCommandBanlist, desc = "See the bans list.", argc_min = 0, argc_max = 0, arg_types = {}}
help_pages["pshy_ban"].commands["banlist"] = command_list["banlist"]
return ban
end
pshy.modules["pshy.perms"].load = function()
--- pshy.perms
--
-- Handles permissions.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
local command_list = pshy.require("pshy.commands.list")
pshy.require("pshy.events")
local help_pages = pshy.require("pshy.help.pages")
local room = pshy.require("pshy.room")
--- Namespace.
local perms = {}
--- Help page:
help_pages["perms_map"] = {title = "Permissions", text = "Handles permissions.\n", commands = {}}
--- Room admins.
-- Admins will have access to most of the functionalities of the scripts.
-- The module loader is automatically added as an admin.
-- Settings starting in `perms.auto_admin_*` define who can join room admins by themselves using `!adminme`.
perms.admins = {}
perms.admins[room.loader] = 0
perms.auto_admin_admins = true
perms.auto_admin_moderators = true
perms.auto_admin_funcorps = true
perms.auto_admin_authors = false
--- Script authors.
-- Authors will be allowed to join room admins if `perms.auto_admin_authors` is `true`.
-- They can always join room admins in private rooms.
perms.authors = {}
perms.authors[105766424] = "Pshy#3752"
--- Funcorp map.
-- Those players can join room admins if `perms.auto_admin_funcorps` is `true`.
perms.funcorps = {}
perms.funcorps[105766424] = "Pshy#3752"
--- Permissions map.
-- This map store per-player and per-groups sets of permissions.
perms.perms = {}
perms.perms.everyone = {}			-- permissions everyone has
perms.perms.cheats = {}				-- permissions given to everyone when cheats are enabled
perms.perms.admins = {}				-- admins permissions
--- Messages shown to players who can join room admins before they do.
perms.admin_instructions = {}
--- Are permissions in `perms.perms.cheats` available to everyone.
perms.cheats_enabled = false									-- do players have the permissions in `perms.perms.cheats`
--- Internal use:
local admin_add_count = 1
local admins_added = {}						-- table of list of added admins by admin
local admins = perms.admins
local authors = perms.authors
local funcorps = perms.funcorps
local perms_map = perms.perms
local perms_admins = perms.perms.admins
local perms_cheats = perms.perms.cheats
local perms_everyone = perms.perms.everyone
local content_creators = {["#Module#0000"] = true}
--- Check if a player have a permission.
-- @param The name of the player.
-- @param perm The permission name.
-- @return true if the player have the required permission.
function perms.HavePerm(player_name, perm)
assert(type(perm) == "string", "permission must be a string")
if perms_everyone[perm] then
return true
elseif perms.perms_cheats_enabled and perms_cheats[perm] then
return true
elseif admins[player_name] and (perms_admins[perm] or perms_cheats[perm]) then
return true
elseif perms_map[player_name] then
return true
elseif player_name == room.loader then
return true
end
return false
end
--- Check if a player's content is to be trusted.
-- @return `true` if the player's content can be trusted.
function perms.IsPlayerNameContentTrusted(author)
if admins[author] or content_creators[author] then
return true
end
for player_id, player_name in pairs(authors) do
if player_name == author then
return true
end
end
for player_id, player_name in pairs(funcorps) do
if player_name == author then
return true
end
end
return false
end
--- Add an admin with a reason, and broadcast it to other admins.
-- @param new_admin The new room admin's Name#0000.
-- @param reason A message displayed as the reason for the promotion.
local function AddAdmin(new_admin, reason, by)
if admins[new_admin] then
return false, "This user is already admin!"
end
admins[new_admin] = admin_add_count
admin_add_count = admin_add_count + 1
if by then
admins_added[by] = admins_added[by] or {}
table.insert(admins_added[by], new_admin)
end
for an_admin, void in pairs(admins) do
tfm.exec.chatMessage(string.format("<r>[Perms]</r> %s added to room admins%s.", new_admin, reason and (" (" .. reason .. ")") or ""), an_admin)
end
return true
end
--- Remove a room admin and all admins they added.
local function RemoveAdmin(old_admin, reason, by)
if not admins[old_admin] then
return false, "This user is not a room admin."
end
if by then
if admins[old_admin] < admins[by] then
return false, "Cannot remove an older room admin!"
end
end
admins[old_admin] = nil
for admin_name, void in pairs(admins) do
tfm.exec.chatMessage(string.format("<r>[Perms]</r> %s removed from room admins%s.", old_admin, reason and (" (" .. reason .. ")") or ""), an_admin)
end
if admins_added[old_admin] then
for _, another_old_admin in ipairs(admins_added[old_admin]) do
RemoveAdmin(another_old_admin, "recursive removal", by)
end
end
return true
end
--- Check if a player could be set as admin automatically.
-- @param player_name The player's Name#0000.
-- @return true/false (can become admin), reason
local function CanAutoAdmin(player_name)
local player_id = tfm.get.room.playerList[player_name].id
if admins[player_name] then
return false, "Already Admin"
elseif player_name == perms.loader then
return true, "Script Loader"
elseif perms.perms_auto_admin_admins and string.sub(player_name, -5) == "#0001" then
return true, "Admin &lt;3"
elseif perms.perms_auto_admin_moderators and string.sub(player_name, -5) == "#0010" then
return true, "Moderator"
elseif perms.perms_auto_admin_funcorps and perms.funcorps[player_id] then
return true, string.format("FunCorp %s", perms.funcorps[player_id])
elseif (perms.perms_auto_admin_authors or room.is_private or room.is_tribehouse) and perms.authors[player_id] == player_name then
return true, string.format("Author %s", perms.authors[player_id])
else
return false, "Not Allowed"
end
end
--- Check if a player can use `!adminme` and notify them if so.
-- @param player_name The player's Name#0000.
local function TouchPlayer(player_name)
local can_admin, reason = CanAutoAdmin(player_name)
if can_admin then
tfm.exec.chatMessage("<r>[Perms]</r> <j>You may join room admins (" .. reason .. ").</j>", player_name)
for instruction in ipairs(perms.admin_instructions) do
tfm.exec.chatMessage("<r>[Perms]</r> <fc>" .. instruction .. "</fc>", player_name)
end
tfm.exec.chatMessage("<r>[Perms]</r> <j>To become a room admin, use `<fc>!adminme</fc>`</j>", player_name)
print(string.format("<r>[Perms]</r> Current settings are allowing %s to join room admins (%s).", player_name, reason))
end
end
--- TFM event eventNewPlayer.
function eventNewPlayer(player_name)
TouchPlayer(player_name)
end
--- !admin <NewAdmin#0000>
-- Add an admin in the perms.admins set.
local function ChatCommandAdmin(user, new_admin_name)
return AddAdmin(new_admin_name, "by " .. user, user)
end
command_list["admin"] = {perms = "admins", func = ChatCommandAdmin, desc = "add a room admin", argc_min = 1, argc_max = 1, arg_types = {"string"}, arg_names = {"Newadmin#0000"}}
help_pages["perms_map"].commands["admin"] = command_list["admin"]
--- !unadmin <OldAdmin#0000>
-- Remove an admin from the perms.admins set.
local function ChatCommandUnadmin(user, admin_name)
return RemoveAdmin(admin_name, "by " .. user, user)
end
command_list["unadmin"] = {perms = "admins", func = ChatCommandUnadmin, desc = "remove a room admin", argc_min = 1, argc_max = 1, arg_types = {"string"}, arg_names = {"Oldadmin#0000"}}
help_pages["perms_map"].commands["unadmin"] = command_list["unadmin"]
--- !adminme
-- Add yourself as an admin if allowed by the module configuration.
local function ChatCommandAdminme(user)
local allowed, reason = CanAutoAdmin(user)
if allowed then
AddAdmin(user, reason)
return true
else
return false, reason
end
end
command_list["adminme"] = {perms = "everyone", func = ChatCommandAdminme, desc = "join room admins if allowed", argc_min = 0, argc_max = 0}
help_pages["perms_map"].commands["adminme"] = command_list["adminme"]
--- !admins
local function ChatCommandAdmins(user)
local strlist = ""
for an_admin, is_admin in pairs(admins) do
if is_admin then
if #strlist > 0 then
strlist = strlist .. ", "
end
strlist = strlist .. an_admin
end
end
tfm.exec.chatMessage("<r>[Perms]</r> Script Loader: " .. tostring(room.loader), user)
tfm.exec.chatMessage("<r>[Perms]</r> Room admins: " .. strlist .. ".", user)
if perms.auto_admin_moderators then
tfm.exec.chatMessage("<r>[Perms]</r> Moderators can join room admins.", user)
end
if perms.auto_admin_funcorps then
tfm.exec.chatMessage("<r>[Perms]</r> Funcorps can join room admins.", user)
end
if perms.auto_admin_authors then
tfm.exec.chatMessage("<r>[Perms]</r> Authors can join room admins.", user)
end
if perms.auto_admin_moderators or perms.auto_admin_funcorps or perms.auto_admin_authors then
tfm.exec.chatMessage("<r>[Perms]</r> Disable in settings or with `!setperm everyone adminme no`.", user)
end
return true
end
command_list["admins"] = {perms = "everyone", func = ChatCommandAdmins, desc = "see a list of room admins", argc_min = 0, argc_max = 0}
help_pages["perms_map"].commands["admins"] = command_list["admins"]
--- !authors
local function ChatCommandAuthors(user)
local strlist = ""
for an_author, author_name in pairs(perms.authors) do
if #strlist > 0 then
strlist = strlist .. ", "
end
strlist = strlist .. author_name
end
tfm.exec.chatMessage("<r>[Perms]</r> Authors: " .. strlist .. ".", user)
return true
end
command_list["authors"] = {perms = "everyone", func = ChatCommandAuthors, desc = "see a list of authors", argc_min = 0, argc_max = 0}
help_pages["perms_map"].commands["authors"] = command_list["authors"]
--- !trust <player#0000>
local function ChatCommandTrust(user, target_player)
content_creators[target_player] = true
for admin_name, void in pairs(admins) do
tfm.exec.chatMessage(string.format("<r>[Perms]</r> %s's content is now trusted (by %s).", target_player, user), admin_name)
end
return true
end
command_list["trust"] = {perms = "admins", func = ChatCommandTrust, desc = "trust a player's maps (enable advanced features)", argc_min = 1, argc_max = 1, arg_types = {'string'}, arg_names = {'Player#0000'}}
help_pages["perms_map"].commands["trust"] = command_list["trust"]
--- !enablecheats
-- Add yourself as an admin if allowed by the module configuration.
local function ChatCommandEnablecheats(user, cheats_enabled)
perms.perms_cheats_enabled = cheats_enabled
if cheats_enabled then
return true, "cheat commands enabled for everyone"
else
return true, "cheat commands enabled for admins only"
end
end
command_list["enablecheats"] = {perms = "admins", func = ChatCommandEnablecheats, desc = "enable cheats commands for everyone", argc_min = 1, argc_max = 1, arg_types = {'boolean'}}
help_pages["perms_map"].commands["enablecheats"] = command_list["enablecheats"]
--- !setperm
-- Add yourself as an admin if allowed by the module configuration.
local function ChatCommandSetcommandperms(user, target, perm, value)
if not perms.HavePerm(user, perm) then
return false, "you cannot give permissions for a command you do not have permissions for"
end
perms_map[target] = perms_map[target] or {}
perms_map[target][perm] = value
local rst = string.format("permission %s %s %s by %s", perm, (value and "given to" or "removed from"), target, user)
for an_admin, void in pairs(admins) do
tfm.exec.chatMessage("<r>[Perms]</r> " .. rst, an_admin)
end
return true, rst
end
command_list["setperm"] = {perms = "admins", func = ChatCommandSetcommandperms, desc = "set permissions for a command", argc_min = 3, argc_max = 3, arg_types = {'string', 'string', 'bool'}, arg_names = {"Player#0000|admins|cheats|everyone", "!command", "yes|no"}}
help_pages["perms_map"].commands["setperm"] = command_list["setperm"]
--- Check if a table is equivalent in syntax to `perms.admins` and set it to `perms.admins` if so
local function SetThirdpartyAdminSet(parent_table, admin_table_name)
local admin_table = parent_table[admin_table_name]
if not admin_table or type(admin_table) ~= "table" then
return false
end
if admin_table[1] then
return false
end
local has_player_keys = false
for key, value in pairs(admin_table) do
if string.match(key, "#....$") and value == true then
has_player_keys = true
end
break
end
if has_player_keys then
parent_table[admin_table_name] = perms.admins
return true
end
return false
end
--- Add the script loader as admin in a thirdparty admin list
local function InsertIntoThirdpartyAdminList(admin_table, admin)
if admin_table[1] and type(admin_table[1]) == "string" then
table.insert(admin_table, admin)
return true
end
return false
end
--- Pshy event eventInit.
function eventInit()
assert(admins == perms.admins)
assert(perms_map == perms.perms)
assert(perms_admins == perms.perms.admins)
assert(perms_cheats == perms.perms.cheats)
assert(perms_everyone == perms.perms.everyone)
for player_name in pairs(tfm.get.room.playerList) do
TouchPlayer(player_name)
end
if perms.auto_admin_authors then
print("<r>[Perms]</r> Authors can join room admins (`see !admins`).")
end
-- Add single admin in thirdparty scripts
if _G.admin and type(_G.admin) == "string" then
_G.admin = room.loader
end
if _G.Admin and type(_G.Admin) == "string" then
_G.Admin = room.loader
end
-- Merge possible existing thirdparty admin sets
local need_add_loader_admin = false
SetThirdpartyAdminSet(_G, "admin")
SetThirdpartyAdminSet(_G, "admins")
if _G.game then
SetThirdpartyAdminSet(_G.game, "admins")
end
-- Add loader to thirdparty admin lists
if _G.admins and type(_G.admins) == "table" then
InsertIntoThirdpartyAdminList(_G.admins, room.loader)
end
if _G.game and _G.game.admins and type(_G.game.admins) == "table" then
InsertIntoThirdpartyAdminList(_G.game.admins, room.loader)
end
end
return perms
end
pshy.modules["pshy.anticheats.adminchat"].load = function()
--- pshy.anticheats.adminchat
--
-- Add an `!ac` command to send a message to room admins.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
local command_list = pshy.require("pshy.commands.list")
pshy.require("pshy.events")
local help_pages = pshy.require("pshy.help.pages")
local perms = pshy.require("pshy.perms")
--- Namespace.
local adminchat = {}
--- Module Help Page:
help_pages["pshy_adminchat"] = {back = "pshy", restricted = true, title = "Admin Chat", text = "Chat for room admins", commands = {}}
help_pages["pshy"].subpages["pshy_adminchat"] = help_pages["pshy_adminchat"]
local displayed_admin_disclaimers = {}		-- set of admins who have been shown the command disclaimer
--- Send a message to room admins.
function adminchat.Message(origin, message)
if not message then
message = origin
origin = "SCRIPT"
end
for admin in pairs(perms.admins) do
if origin then
tfm.exec.chatMessage("<r>⚔ [" .. origin .. "] <o>" .. message, admin)
else
tfm.exec.chatMessage("<r>⚔ <o>" .. message, admin)
end
end
end
--- !adminchat
local function ChatCommandAdminchat(user, message)
displayed_admin_disclaimers[user] = true
for admin in pairs(perms.admins) do
tfm.exec.chatMessage("<r>⚔ [" .. user .. "] <ch2>" .. message, admin)
if not displayed_admin_disclaimers[admin] == true then
tfm.exec.chatMessage("<r>⚔ <o>Use `<r>!ac <message></r>` to send a message to other room admins.", admin)
displayed_admin_disclaimers[admin] = true
end
end
return true
end
command_list["adminchat"] = {aliases = {"ac"}, perms = "admins", func = ChatCommandAdminchat, desc = "send a message to room admins", argc_min = 1, argc_max = 1, arg_types = {"string"}, arg_names = {"room-admin-only message"}}
help_pages["pshy_adminchat"].commands["adminchat"] = command_list["adminchat"]
return adminchat
end
pshy.modules["pshy.anticheats.loadersync"].load = function()
--- pshy.anticheats.loadersync
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
--
-- Temporary mitigation to TFM sync vulnerability.
local adminchat = pshy.require("pshy.anticheats.adminchat")
local command_list = pshy.require("pshy.commands.list")
pshy.require("pshy.events")
local help_pages = pshy.require("pshy.help.pages")
pshy.require("pshy.utils.print")
local room = pshy.require("pshy.room")
local perms = pshy.require("pshy.perms")
--- Namespace.
local loadersync = {}
--- Module Help Page:
help_pages["pshy_loadersync"] = {back = "pshy", restricted = true, text = "Enforce the sync to prevent some exploits.\n", commands = {}}
help_pages["pshy"].subpages["pshy_loadersync"] = help_pages["pshy_loadersync"]
--- Module Settings:
loadersync.enabled = true
--- Internal use:
local wished_sync = room.loader			-- player wished as sync
local forced_sync = nil					-- player currently being forced as sync
local is_get_player_sync_available = (tfm.exec.getPlayerSync() ~= nil)
function eventNewGame()
if loadersync.enabled then
if forced_sync and tfm.exec.getPlayerSync() ~= forced_sync then
adminchat.Message("pshy_loadersync", string.format("Sync changed from %s to %s, restoring the previous one!", forced_sync or "nil", tfm.exec.getPlayerSync() or "nil"))
tfm.exec.setPlayerSync(forced_sync)
end
end
end
function eventNewPlayer(player_name)
if loadersync.enabled then
if player_name == wished_sync then
tfm.exec.setPlayerSync(player_name)
forced_sync = player_name
adminchat.Message("pshy_loadersync", string.format("%s returned and set as sync!", player_name))
end
end
end
function eventPlayerLeft(player_name)
if loadersync.enabled then
if forced_sync == player_name then
for player_name in pairs(perms.admins) do
if tfm.get.room.playerList[player_name] then
tfm.exec.setPlayerSync(player_name)
forced_sync = player_name
adminchat.Message("pshy_loadersync", string.format("Sync left, replacing it with %s!", player_name))
return
end
end
for player_name in pairs(tfm.get.room.playerList) do
tfm.exec.setPlayerSync(player_name)
forced_sync = player_name
print_warn("pshy_loadersync: Sync left, replacing it with %s!", player_name)
return
end
end
end
end
function eventInit()
if not is_get_player_sync_available then
loadersync.enabled = false
else
--- Set the player sync to be the host.
tfm.exec.setPlayerSync(wished_sync)
forced_sync = wished_sync
end
end
--- !loadersync
local function ChatCommandLoadersync(user, enabled, sync_player)
loadersync.enabled = enabled
if sync_player then
wished_sync = sync_player
tfm.exec.setPlayerSync(sync_player)
forced_sync = sync_player
end
adminchat.Message("pshy_loadersync", enabled and string.format("Now enforcing the sync to be %s.", forced_sync) or "No longer enforcing the sync.")
return true
end
command_list["loadersync"] = {perms = "admins", func = ChatCommandLoadersync, desc = "Enable or disable the enforcing of the sync.", argc_min = 1, argc_max = 2, arg_types = {"boolean", "player"}, arg_names = {"on/off", "sync_player"}}
help_pages["pshy_loadersync"].commands["loadersync"] = command_list["loadersync"]
return loadersync
end
pshy.modules["pshy.bases.loopmore"].load = function()
--- pshy.bases.loopmore
--
-- Triggers an event `eventLoopMore` with higger frequency than the default `eventLoop`.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
pshy.require("pshy.events")
--- Namespace.
local loopmore = {}
--- Module Settings:
loopmore.call_standard_loop = false			-- if true, call `eventLoop` on `eventLoopOften`
loopmore.down_keys = {0, 1, 2, 3}				-- keys to listen to when pressed (used to trigger events, not needed if you bind these yourself)
loopmore.up_keys = {0, 2}						-- keys to listen to when released (used to trigger events, not needed if you bind these yourself)
--- Internal use:
local interval = nil						-- interval between calls to `eventLoopMore`
local tfm_timers_interval = nil				-- chosen interval for timers
local map_start_os_time = nil				-- map start os time
local map_end_os_time = nil					-- expected map end os time
local last_loopmore_os_time = os.time()		-- last time of last loopmore loop
local anticipated_skips = 0					-- @todo used to skip event when there is too many, avoiding calls to os.time()
local timers = {}							-- store timers and timers sync
--- Trigger an `eventLoopMore`.
local function RunLoopMore()
-- skip initial times (information missing)
if not map_start_os_time or not map_end_os_time then
return
end
-- ok, loop
local os_time = os.time()
eventLoopMore(os_time - map_start_os_time, map_end_os_time - os_time)
--if last_loopmore_os_time then
--	print("duration: " .. tostring(os_time - last_loopmore_os_time))
--end
last_loopmore_os_time = os_time
end
--- Timer callback
local function TimerCallback(tfmid, id)
local timer = timers[id]
--print("timer #" .. tostring(id) .. "/" .. tostring(#timers) .. ": " .. tostring(os.time() % 10000))
assert(timer ~= nil, "timer #" .. tostring(id) .. "/" .. tostring(#timers) .. ": " .. tostring(os.time() % 10000))
--timer.sync_time = os.time() % tfm_timers_interval
RunLoopMore()
end
--- Callback supposed to create the initial timers with different sync times.
-- When this function is called, the timer is recreated to loop in constent time.
local function InitTimerCallback(tid, i_timer)
local timer = timers[i_timer]
assert(timer.id ~= nil)
system.removeTimer(timer.id)
timer.id = system.newTimer(TimerCallback, tfm_timers_interval, true, i_timer)
end
--- Set the loop_more interval.
-- @public
-- @param interval New loop interval (have limitations).
function loopmore.SetInterval(interval)
assert(type(interval) == "number")
assert(interval >= 50)
assert(interval <= 500)
interval = interval
-- destroy timers
for i_timer, timer in ipairs(timers) do
system.removeTimer(timer.id)
end
timers = {}
-- choose tfm timers intervals and count
local tfm_interval = interval
while tfm_interval < 500 do
tfm_interval = tfm_interval + interval
end
tfm_timers_interval = tfm_interval
local timer_count = tfm_interval / interval
assert(timer_count >= 1)
assert(timer_count <= 10)
-- make place for new timers
for i_timer = 1, timer_count do
timers[i_timer] = {}
local timer = timers[i_timer]
timer.sync_time = interval * (i_timer - 1)
timer.id = system.newTimer(InitTimerCallback, tfm_timers_interval + timer.sync_time, false, i_timer)
timer.i_timer = i_timer
end
end
--- Pshy event eventLoopMore.
function eventLoopMore(time, time_remaining)
if loopmore.call_standard_loop and eventLoop then
eventLoop(time, time_remaining)
end
end
--- TFM event eventNewGame()
function eventNewGame()
map_start_os_time = os.time()
map_end_os_time = nil
anticipated_skips = 0
end
--- TFM event eventLoop()
function eventLoop(time, time_remaining)
local os_time = os.time()
-- eventLoop can also be used to update our information
map_start_os_time = os_time - time
map_end_os_time = os_time + time_remaining
--loopmore.Check()
end
--- Override of `tfm.exec.setGameTime`.
function loopmore.setGameTime(time_remaining, init)
local os_time = os.time()
if init then
map_end_os_time = os_time + time_remaining
elseif map_end_os_time and time_remaining < (map_end_os_time - os_time) then
map_end_os_time = os_time + time_remaining
end
loopmore.original_setGameTime(time_remaining, init)
end
loopmore.original_setGameTime = tfm.exec.setGameTime
tfm.exec.setGameTime = loopmore.setGameTime
--- Initialization:
loopmore.SetInterval(250)
return loopmore
end
pshy.modules["pshy.utils.strings"].load = function()
--- pshy.utils.strings
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
local utils_strings = {}
--- string.isalnum(str)
-- us this instead: `not str:match("%W")`
--- Split a string
-- Ignores empty fields
-- @param str String to split.
-- @param separator Char to split at, default to whitespaces.
-- @param max Max amount of returned strings.
function utils_strings.Split(str, separator, max)
assert(type(str) == "string")
separator = separator or "%s"
max = max or -1
local remlen = #str
local parts = {}
for part in string.gmatch(str, "([^" .. separator .. "]+)") do
if max == 1 and remlen >= 0 then
table.insert(parts, string.sub(str, -remlen))
return parts
end
table.insert(parts, part)
remlen = remlen - #part - 1
max = max - 1
end
return parts
end
--- Same as pshy.Split but does not ignore empty fields.
function utils_strings.Split2(str, separator)
assert(type(str) == "string")
separator = separator or '%s'
local fields = {}
for field, s in string.gmatch(str, "([^".. separator .."]*)(".. separator .."?)") do
table.insert(fields, field)
if s == "" then --@TODO: learn about this
return fields
end
end
return fields
end
--- Split a string to an array of strings of a maximum length.
function utils_strings.LenSplit(str, len)
local to_return = {}
while #str > 0 do
part = string.sub(str, 1, len)
table.insert(to_return, part)
str = string.sub(str, len + 1, #str)
end
return to_return
end
return utils_strings
end
pshy.modules["pshy.ui.dialog"].load = function()
--- pshy.ui.dialog
--
-- Abstraction to show dialogs to a player, using a callback.
-- See dialog.Ask* functions.
-- The callbacks are called as `callback(player_name, answer)`.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
pshy.require("pshy.events")
pshy.require("pshy.utils.print")
--- Namespace:
local dialog = {}
--- Module Settings:
local dialog_arbitrary_popup_id = 8
local dialog_arbitrary_color_picker_id = 8
local dialog_x = 300
local dialog_y = 100
--- Internal use:
local dialog_players_callbacks = {}
--- Open a boolean dialog.
-- @param player_name The player's Name#0000.
-- @param text Text to display in the popup.
-- @param callback A function ton call when the player have answered.
-- @cf dialog.SetPlayerCallback
function dialog.AskForYesOrNo(player_name, text, callback)
dialog_players_callbacks[player_name] = callback
ui.addPopup(dialog_arbitrary_popup_id, 1, text, player_name, dialog_x, dialog_y, nil, true)
end
--- Open a text dialog.
-- @param player_name The player's Name#0000.
-- @param text Text to display in the popup.
-- @param callback A function ton call when the player have answered.
-- @cf dialog.SetPlayerCallback
function dialog.AskForText(player_name, text, callback)
dialog_players_callbacks[player_name] = callback
ui.addPopup(dialog_arbitrary_popup_id, 2, text, player_name, dialog_x, dialog_y, nil, true)
end
--- Open a color dialog.
-- @param player_name The player's Name#0000.
-- @param title Text to display in the popup.
-- @param callback A function ton call when the player have answered.
-- @cf dialog.SetPlayerCallback
function dialog.AskForColor(player_name, title, callback, default_color)
dialog_players_callbacks[player_name] = callback
ui.showColorPicker(dialog_arbitrary_color_picker_id, player_name, default_color or 0xffffff, title)
end
--- Called when a player answered a question.
-- @private
-- @param player_name The player's Name#0000.
local function Answered(player_name, answer)
local callback = dialog_players_callbacks[player_name]
if callback then
dialog_players_callbacks[player_name] = nil
callback(player_name, answer)
else
print_warn("pshy_dialog: no callback for %s: %s", player_name, tostring(answer))
end
end
--- TFM event eventPopupAnswer.
function eventPopupAnswer(popup_id, player_name, answer)
if popup_id == dialog_arbitrary_popup_id then
Answered(player_name, answer)
end
end
--- TFM event eventColorPicked.
function eventColorPicked(popup_id, player_name, color)
if popup_id == dialog_arbitrary_color_picker_id then
Answered(player_name, color)
end
end
return dialog
end
pshy.modules["pshy.enums.colors"].load = function()
--- pshy.enums.colors
--
-- Simple enumeration of color codes
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
--- Public Map:
local colors = {}
-- primary colors
colors.red			= 0xff0000
colors.lime			= 0x00ff00
colors.blue			= 0x0000ff
-- secondary colors
colors.yellow		= 0xffff00
colors.magenta		= 0xff00ff
colors.cyan			= 0x00ffff
-- greys
colors.transparent	= 0x000000	-- because TFM may count 0x000000 as transparent.
colors.black		= 0x010101	-- because TFM may count 0x000000 as transparent.
colors.grey			= 0x808080
colors.gray			= 0x808080
colors.silver		= 0xc0c0c0
colors.white		= 0xffffff
-- odd
colors.maroon		= 0x800000
colors.green		= 0x008000
colors.navy			= 0x000080
colors.olive		= 0x808000
colors.purple		= 0x800080
colors.teal			= 0x008080
-- common
colors.aquamarine	= 0x7fffd4
colors.brown		= 0xa52a2a
colors.bronze		= 0x967444
colors.coral		= 0xff7f50
colors.darkgreen	= 0x006400
colors.gold			= 0xffd700
colors.indigo		= 0x4b0082
colors.lavender		= 0xb2a4d4
colors.orange		= 0xffa500
colors.pink			= 0xffc0cb
colors.tan			= 0xd2b48c
colors.turquoise	= 0x40e0d0
colors.violet		= 0x9b26b6
-- TFM
colors.funcorp		= 0xff8000
return colors
end
pshy.modules["pshy.utils.lua"].load = function()
--- pshy.utils.lua
--
-- Basic functions related to LUA.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
local colors = pshy.require("pshy.enums.colors")
local utils_strings = pshy.require("pshy.utils.strings")
local utils_lua = {}
--- Interpret a namespace expression (resolve lua path from string)
-- @param path lua path (such as "tfm.enum.bonus")*
-- @return the object represented by path or nil if not found
function utils_lua.Get(path, sep)
assert(type(path) == "string", debug.traceback())
sep = sep or "."
local parts = utils_strings.Split(path, sep)
local cur = _G
for index, value in pairs(parts) do
possible_int = tonumber(value)
value = possible_int or value
cur = cur[value]
if cur == nil then
return nil
end
end
return cur
end
--- Set the value to a lua object.
-- The path is created if it does not exist.
-- @param obj_path Lua path to the object.
-- @param value Value to set, any type.
function utils_lua.Set(obj_path, value, sep)
assert(type(obj_path) == "string", debug.traceback())
sep = sep or "."
local parts = utils_strings.Split(obj_path, sep)
local cur = _G
for i_part, part in pairs(parts) do
possible_int = tonumber(part)
part = possible_int or part
if i_part == #parts then
-- last iteration
cur[part] = value
return cur[part]
end
cur[part] = cur[part] or {}
if type(cur) ~= "table" then
return nil
end
cur = cur[part]
end
error("unreachable code")
end
return utils_lua
end
pshy.modules["pshy.utils.tfm"].load = function()
--- pshy.utils.tfm
--
-- Basic functions related to TFM.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
local utils_lua = pshy.require("pshy.utils.lua")
local utils_strings = pshy.require("pshy.utils.strings")
local utils_tfm = {}
--- Get the display nick of a player.
-- @param player_name The player name.
-- @return either the part of the name before '#' or an entry from `pshy.nicks`.
function utils_tfm.GetPlayerNick(player_name)
return string.match(player_name, "([^#]*)")
end
--- Find a player's full Name#0000.
-- @param partial_name The beginning of the player name.
-- @return The player full name or (nil, reason).
-- @todo Search in nicks as well.
function utils_tfm.FindPlayerName(partial_name)
local player_list = tfm.get.room.playerList
if player_list[partial_name] then
return partial_name
else
local real_name
for player_name in pairs(player_list) do
if string.sub(player_name, 1, #partial_name) == partial_name then
if real_name then
return nil, "several players found" -- 2 players have this name
end
real_name = player_name
end
end
if not real_name then
return nil, "player not found"
end
return real_name -- found
end
end
--- Find a player's full Name#0000 or throw an error.
-- @return The player full Name#0000 (or throw an error).
function utils_tfm.FindPlayerNameOrError(partial_name)
local real_name, reason = utils_tfm.FindPlayerName(partial_name)
if not real_name then
error(reason)
end
return real_name
end
--- Convert a tfm enum index to an interger, searching in all tfm enums.
-- Search in bonus, emote, ground, particle and shamanObject.
-- @param index a string, either representing a tfm enum value or integer.
-- @return the existing enum value or nil
function utils_tfm.EnumGet(index)
assert(type(index) == "string")
local value
for enum_name, enum in pairs(tfm.enum) do
value = enum[index]
if value then
return value
end
end
return nil
end
--- Get how many players are alive in tfm.get
function utils_tfm.CountPlayersAlive()
local count = 0
for player_name, player in pairs(tfm.get.room.playerList) do
if not player.isDead then
count = count + 1
end
end
return count
end
return utils_tfm
end
pshy.modules["pshy.utils.types"].load = function()
--- pshy.utils.types
--
-- Basic functions related to LUA.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
local colors = pshy.require("pshy.enums.colors")
local utils_lua = pshy.require("pshy.utils.lua")
local utils_tfm = pshy.require("pshy.utils.tfm")
local utils_types = {}
--- Convert a string to a boolean.
-- @param string "true" or "false".
-- @return Boolean true or false, or nil.
function utils_types.ToBoolean(s)
if s == "true" then
return true
end
if s == "false" then
return false
end
return nil
end
--- Convert a string to a boolean (andles yes/no and on/off).
-- @param string "true" or "false".
-- @return Boolean true or false, or nil.
function utils_types.ToPermissiveBoolean(s)
if s == "true" or s == "on" or s == "yes" then
return true
end
if s == "false" or s == "off" or s == "no" then
return false
end
return nil
end
local ToPermissiveBoolean = utils_types.ToPermissiveBoolean
--- Convert a string representing an hex number to a number.
-- @param s A string representing an hex number, optionally prefixed with `#`.
function utils_types.ToNumberHex(s)
if string.sub(s, 1, 1) == '#' then
s = string.sub(s, 2, #s)
end
return tonumber(s, 16)
end
local ToNumberHex = utils_types.ToNumberHex
--- Convert a string representing a color to a number.
-- @param s A string representing a color as a color name or an hex number (see ToNumberHex).
function utils_types.ToColor(s)
if colors[s] then
return colors[s]
end
return ToNumberHex(s)
end
local ToColor = utils_types.ToColor
--- Converter functions:
utils_types.converters = {}
utils_types.converters["number"] = tonumber
utils_types.converters["string"] = tostring
utils_types.converters["bool"] = utils_types.ToPermissiveBoolean
utils_types.converters["boolean"] = utils_types.ToPermissiveBoolean
utils_types.converters["player"] = utils_tfm.FindPlayerName
utils_types.converters["hexnumber"] = utils_types.ToNumberHex
utils_types.converters["color"] = utils_types.ToColor
utils_types.converters["lua"] = utils_lua.Get
utils_types.converters["lua/"] = function(s) return utils_lua.Get(s, "/") end
local converters = utils_types.converters
--- Convert a string value to the given type.
-- nil value is not supported for `string` and `player`.
-- @param value String to convert.
-- @param type string representing the type to convert to.
-- @return The converted value.
-- @todo Should t be a table to represent enum keys?
function utils_types.ToType(s, t)
assert(type(s) == "string", "wrong argument type")
assert(type(t) == "string", "wrong argument type")
-- string
if t == "string" then
return s
end
-- player
if t == "player" then
return utils_tfm.FindPlayerName(s)
end
-- nil
if s == "nil" then
return nil
end
-- boolean
if t == "bool" or t == "boolean" then
return ToPermissiveBoolean(s)
end
-- number
if t == "number" then
return tonumber(s)
end
-- color
if t == "color" then
if colors[s] then
return colors[s]
end
t = "hexnumber"
end
-- hexnumber
if t == "hexnumber" then
if string.sub(s, 1, 1) == '#' then
s = string.sub(s, 2, #s)
end
return tonumber(s, 16)
end
-- enums
local enum = utils_lua.Get(t)
if type(enum) == "table" then
return enum[s]
end
-- not supported
error("type not supported")
end
--- Convert an argument to anoter type automatically.
-- @param value String to convert.
-- @return the same value represented by the best type possible (bool/number/string).
function utils_types.AutoType(s)
assert(type(s) == "string", "wrong argument type")
local rst
-- nil
if s == "nil" then
return nil
end
-- boolean
if s == "true" then
return true
end
if s == "false" then
return false
end
-- number
rst = tonumber(s, 10)
if rst then
return rst
end
-- empty table
if s == "{}" then
return {}
end
-- tfm enums
rst = utils_tfm.EnumGet(s)
if rst then
return rst
end
-- lua object
rst = utils_lua.Get(s)
if rst then
return rst
end
-- color code / hex number
if string.sub(s, 1, 1) == '#' then
rst = tonumber(string.sub(s, 2, #s), 16)
if rst then
return rst
end
end
-- string
return s
end
local AutoType = utils_types.AutoType
function utils_types.ToTypeFromPrefix(s)
assert(type(s) == "string", "wrong argument type")
local i_colon = s:find(":", 1, true)
if i_colon and i_colon > 1 and i_colon < 16 then
local type_str = s:sub(1, i_colon - 1)
if converters[type_str] then
return converters[type_str](s:sub(i_colon + 1))
end
end
if #s > 1 and s:sub(1, 1) == "\"" and s:sub(-1, -1) == "\"" then
return s:sub(2, -2)
end
return AutoType(s)
end
return utils_types
end
pshy.modules["pshy.commands"].load = function()
--- pshy.commands
--
-- This module can be used to implement in-game commands.
--
-- Example adding a command 'demo':
--   function my.function.demo(user, arg_int, arg_str)
--       print("hello " .. user .. "! " .. tostring(arg_int) .. tostring(arg_str))
--   end
--   command_list["demo"] = {func = my.function.demo}			-- the function to call
--   command_list["demo"].desc = "my demo function"			-- short description
--   command_list["demo"].restricted = true					-- hide this command from non admins, even with `!commands`
--   command_list["demo"].no_user = false						-- true to not pass the command user as the 1st arg
--   command_list["demo"].argc_min = 1							-- need at least 1 arg
--   command_list["demo"].argc_max = 2							-- max args (remaining args will be considered a single one)
--   command_list["demo"].arg_types = {"number", "string"}		-- argument type as a string, nil for auto, a table to use as an enum, or a function to use for the conversion
--   command_list["demo"].arg_names = {"index", "message"}		-- argument names
--   commands.aliases["ddeemmoo"] = "demo"					-- create an alias
--
-- This submodule add the following commands:
--   !help [command]				- show general or command help
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
pshy.require("pshy.events")
local dialog = pshy.require("pshy.ui.dialog")
pshy.require("pshy.utils.print")
local utils_strings = pshy.require("pshy.utils.strings")
local utils_types = pshy.require("pshy.utils.types")
local perms = pshy.require("pshy.perms")
local command_list = pshy.require("pshy.commands.list")
--- commands.
local commands = {}
--- Module Settings:
commands.require_prefix = false		-- if true, all commands must start with `!pshy.`
commands.always_enable_ui = true		-- if true, missing arguments will be asked to be completed with a popup
--- Internal Use:
local ignore_next_command = false
commands.names_ordered = {}
--- Map of command aliases (string -> string)
commands.aliases = commands.aliases or {}
--- Get the real command name
-- @param alias_name Command name or alias without `!`.
local function ResolveAlias(alias_name)
while not command_list[alias_name] and commands.aliases[alias_name] do
alias_name = commands.aliases[alias_name]
end
return alias_name
end
--- Get a chat command by name
-- @param alias_name Can be the command name or an alias, without `!`.
local function GetCommand(alias_name)
return (command_list[ResolveAlias(alias_name)])
end
--- Alias for GetCommand
commands.GetCommand = GetCommand
--- Get html things to add before and after a command to display it with the right color.
function commands.GetPermColorMarkups(perm)
if perms.perms.everyone[perm] then
return "<v>", "</v>"
elseif perms.perms.cheats[perm] then
return "<j>", "</j>"
elseif perms.perms.admins[perm] then
return "<r>", "</r>"
else
return "<vi>", "</vi>"
end
end
--- Get a command usage.
-- The returned string represent how to use the command.
-- @param cmd_name The name of the command.
-- @return HTML text for the command's usage.
function commands.GetUsage(cmd_name)
local text = "!" .. cmd_name
local real_command = GetCommand(cmd_name)
if not real_command then
return "This command does not exist or is unavailable."
end
if real_command.aliases then
text = text .. "("
local first_alias = true
for i_alias, alias in ipairs(real_command.aliases) do
if not first_alias then
text = text .. ","
end
first_alias = false
text = text .. alias
end
text = text .. ")"
end
local min = real_command.argc_min or 0
local max = real_command.argc_max or min
if max > 0 then
for i = 1, max do
text = text .. " " .. ((i <= min) and "&lt;" or "[")
if real_command.arg_names and i <= #real_command.arg_names then
text = text .. real_command.arg_names[i]
elseif real_command.arg_types and i <= #real_command.arg_types then
if type(real_command.arg_types[i]) == "string" then
text = text .. real_command.arg_types[i]
else
text = text .. type(real_command.arg_types[i])
end
else
text = text .. "?"
end
text = text .. ((i <= min) and "&gt;" or "]")
end
end
if not real_command.argc_max then
text = text .. " [...]"
end
return text
end
--- Convert string arguments of a table to the specified types,
-- or attempt to guess the types.
-- @param args Table of elements to convert.
-- @param types Table of types.
-- @return true or (false, reason)
local function ConvertArgs(args, types)
local reason
local has_multiple_players = false
for index = 1, #args do
if (not types) or index > #types or types[index] == nil then
-- automatic conversion
args[index] = utils_types.ToTypeFromPrefix(args[index])
elseif type(types[index]) == "function" then
-- a function is used for conversion
args[index], reason = types[index](args[index])
if args[index] == nil then
return false, (reason or ("wrong type for argument " .. tostring(index) .. ", conversion function returned `nil`"))
end
elseif type(types[index]) == "table" then
-- a function is used as an enum
args[index] = types[index][args[index]]
if args[index] == nil then
return false, "wrong type for argument " .. tostring(index) .. ", expected an enum value"
end
elseif types[index] == 'player' and args[index] == '*' then
if has_multiple_players then
return false, "only a single '*' argument may represent all the players"
end
has_multiple_players = true
else
-- using pshy.ToType with the given type string
args[index], reason = utils_types.ToType(args[index], types[index])
if reason ~= nil then
return false, reason
end
if args[index] == nil then
return false, "wrong type for argument " .. tostring(index) .. ", expected " .. types[index]
end
end
end
return true
end
local players_resumable_commands = {}
local function AnsweredArg(user, answer)
local resumable_command = players_resumable_commands[user]
if not resumable_command then
print_warn("pshy_commands: no command to resume for %s", user)
return
end
local arg_type = "string"
if resumable_command.command.arg_types then
arg_type = resumable_command.command.arg_types[#resumable_command.argv + 1] or "string"
end
if arg_type == "color" and type(answer) == "number" then
answer = string.format("#%06x", answer)
end
--print_debug("chosen answer: %s", answer)
table.insert(resumable_command.argv, tostring(answer))
local command = resumable_command.command
local argv = resumable_command.argv
players_resumable_commands[user] = nil
commands.RunCommandWithArgs(user, command, argv)
end
--- Ask the player for a missing information.
local function AskNextArg(user, command, argv)
local arg_type = "string"
local arg_index = #argv + 1
if command.arg_types then
arg_type = command.arg_types[#argv + 1] or "string"
end
local arg_name = nil
if command.arg_names and command.arg_names[arg_index] then
arg_name = command.arg_names[arg_index]
end
local text
if arg_name then
text = string.format("<n><b>%s</b></n> (argument %d):", arg_name, arg_index)
else
text = string.format("<n><b>%s</b></n> (argument %d):", arg_type, arg_index)
end
players_resumable_commands[user] = {command = command, argv = argv}
if arg_type == "bool" or arg_type == "boolean" then
dialog.AskForYesOrNo(user, text, AnsweredArg)
elseif arg_type == "color" then
dialog.AskForColor(user, (arg_type or arg_name or "anything"), AnsweredArg)
else
dialog.AskForText(user, text, AnsweredArg)
end
end
--- Answer a player's command.
-- @param msg The message to send.
-- @param player_name The player who will receive the message.
local function Answer(msg, player_name)
assert(player_name ~= nil)
tfm.exec.chatMessage("<n> ↳ " .. tostring(msg), player_name)
end
--- Answer a player's command (on error).
-- @param msg The message to send.
-- @param player_name The player who will receive the message.
local function AnswerError(msg, player_name)
assert(player_name ~= nil)
tfm.exec.chatMessage("<r> × " .. tostring(msg), player_name)
end
--- Run a command as a player.
-- @param user The Name#0000 of the player running the command.
-- @param command_str The full command the player have input, without "!".
-- @return false on permission failure, true if handled and not to handle, nil otherwise
function commands.Run(user, command_str)
-- input asserts
assert(type(user) == "string")
assert(type(command_str) == "string")
-- ignore commands shreduled to be ignored
if ignore_next_command then
ignore_next_command = false
return
end
-- log commands used by non-admin players
if not perms.admins[user] then
print("<g>[" .. user .. "] !" .. command_str)
end
-- ignore 'other.' commands
if string.sub(command_str, 1, 6) == "other." then
ignore_next_command = true
return eventChatCommand(user, string.sub(command_str, 7)) or false
end
-- remove 'pshy.' prefix
local had_pshy_prefix = false
if string.sub(command_str, 1, 5) == "pshy." then
command_str = string.sub(command_str, 6, #command_str)
had_pshy_prefix = true
elseif commands.require_prefix then
return
end
-- get the command alias (command name) and the argument string
local command_alias_and_args_str = utils_strings.Split(command_str, " ", 2)
local command_alias = command_alias_and_args_str[1]
local args_str = command_alias_and_args_str[2]
local command = GetCommand(command_alias)
-- non-existing command
if not command then
if had_pshy_prefix then
AnswerError("Unknown pshy command.", user)
return nil
end
tfm.exec.chatMessage("Another module may handle this command.", user)
return nil
end
-- check permissions
if not perms.HavePerm(user, "!" .. command.name) then
AnswerError("You do not have permission to use this command.", user)
return false
end
-- get args
args = args_str and utils_strings.Split(args_str, " ", command.argc_max or 16) or {} -- max command args set to 16 to prevent abuse
return commands.RunCommandWithArgs(user, command, args)
end
--- Run a command (from a command table) with given args.
-- @param user Name#0000 of the user to run the command as.
-- @param command The command table representing the command to run.
-- @param argv List of arguments (strings).
-- @return false on permission failure, true if handled and not to handle, nil otherwise
function commands.RunCommandWithArgs(user, command, argv)
-- check permissions
if not perms.HavePerm(user, "!" .. command.name) then
AnswerError("You do not longer have permission to use this command.", user)
return false
end
-- missing arguments
if command.argc_min and #argv < command.argc_min then
if command.ui or commands.always_enable_ui then
AskNextArg(user, command, argv)
return true
end
AnswerError("Usage: " .. (command.usage or "(no usage, error)"), user)
return false
end
-- too many arguments
if command.argc_max and #argv > command.argc_max then
AnswerError("This command do not use arguments.", user)
return false
end
-- multiple players args
local multiple_players_index = nil
if command.arg_types then
for i_type, type in ipairs(command.arg_types) do
if type == "player" and argv[i_type] == '*' then
multiple_players_index = i_type
end
end
end
-- convert arguments
local rst, rtn = ConvertArgs(argv, command.arg_types)
if not rst then
AnswerError(tostring(rtn), user)
return not had_prefix
end
-- runing the command
local pcallrst, rst, rtn
if multiple_players_index then
-- command affect all players
for player_name in pairs(tfm.get.room.playerList) do
argv[multiple_players_index] = player_name
if not command.no_user then
pcallrst, rst, rtn = pcall(command.func, user, table.unpack(argv))
else
pcallrst, rst, rtn = pcall(command.func, table.unpack(argv))
end
if pcallrst == false or rst == false then
break
end
end
else
-- command affect at most 1 player
if not command.no_user then
pcallrst, rst, rtn = pcall(command.func, user, table.unpack(argv))
else
pcallrst, rst, rtn = pcall(command.func, table.unpack(argv))
end
end
-- display command results
if pcallrst == false then
-- pcall failed
AnswerError(rst, user)
elseif rst == false then
-- command function returned false
AnswerError(rtn, user)
elseif rst == nil then
-- command function returned false
Answer("Command executed.", user)
elseif rst == true and rtn ~= nil then
-- command function returned true
if type(rtn) == "string" then
Answer(rtn, user)
else
Answer(string.format("Command returned %s.", tostring(rtn)), user)
end
end
end
--- !commands(cmds) [page_index]
-- List commands.
local function ChatCommandCommands(user, page_index)
page_index = page_index or 1
local commands_per_page = 10
tfm.exec.chatMessage(string.format("<n>Commands (page %d/%d):</n>", page_index, math.ceil(#commands.names_ordered / commands_per_page)), user)
local i_command_first = ((page_index - 1) * commands_per_page) + 1
local i_command_last = ((page_index - 1) * commands_per_page + 10)
for i_command = i_command_first, i_command_last do
local command_name = commands.names_ordered[i_command]
if command_name then
local real_command = GetCommand(command_name)
local is_admin = perms.admins[user]
if not real_command.restricted or is_admin then
local usage = real_command.usage or "(no usage, error)"
local markup_1, markup_2 = commands.GetPermColorMarkups("!" .. command_name)
tfm.exec.chatMessage(string.format("  %s%s%s", markup_1, usage, markup_2), user)
end
else
break
end
end
return true
end
command_list["commands"] = {aliases = {"cmds"}, perms = "everyone", func = ChatCommandCommands, desc = "list commands", argc_min = 0, argc_max = 1, arg_types = {"number"}}
function eventChatCommand(player_name, message)
return commands.Run(player_name, message)
end
function eventInit()
for command_name, command in pairs(command_list) do
command.name = command_name
command.usage = commands.GetUsage(command_name)
if command.aliases then
for i_alias, alias in ipairs(command.aliases) do
commands.aliases[alias] = command_name
end
end
table.insert(commands.names_ordered, command_name)
if command.perms then
if command.perms == "cheats" or command.perms == "admins" or command.perms == "everyone" then
perms.perms[command.perms]["!" .. command_name] = true
perms.perms["admins"]["!" .. command_name .. "-others"] = true
else
print_warn(string.format("Invalid `perms == \"%s\"` for command `%s`!", command.perms, command_name))
end
end
end
table.sort(commands.names_ordered)
end
return commands
end
pshy.modules["pshy.ui.v1"].load = function()
--- pshy.ui.v1
--
-- Module simplifying ui creation.
-- Every ui is represented by a pshy ui table storing its informations.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
pshy.require("pshy.events")
local utils_strings = pshy.require("pshy.utils.strings")
local perms = pshy.require("pshy.perms")
local commands = pshy.require("pshy.commands")
-- ui.addTextArea (id, text, targetPlayer, x, y, width, height, backgroundColor, borderColor, backgroundAlpha, fixedPos)
-- ui.updateTextArea (id, text, targetPlayer)
-- ui.removeTextArea (id, targetPlayer)
--
-- ui.addPopup (id, type, text, targetPlayer, x, y, width, fixedPos)
-- ui.showColorPicker (id, targetPlayer, defaultColor, title)
--
-- <p align='center'><font color='#badb2f' size='24' face='Soopafresh'>Help</font></p><br>hejsfsejh<u></u><i></i><b></b>
--- Create a pshy ui
function pshy.UICreate(text)
local ui = {}
ui.id = 2049
ui.text = text or "<b>New Control</b>"
ui.player = nil
ui.x = 50
ui.y = 50
ui.w = nil --700
ui.h = nil --500
--ui.back_color = 0x010101
--ui.border_color = 0xffff00
ui.alpha = 1.0
ui.fixed = true
return ui
end
--- Show a pshy ui
function pshy.UIShow(u, player_name)
ui.addTextArea(u.id, u.text, player_name or u.player, u.x, u.y, u.w, u.h, u.back_color, u.border_color, u.alpha, u.fixed)
end
--- TFM text area click
-- events are separated by a '\n', so a single click can trigger several events.
-- events close, closeall, pcmd and cmd are hardcoded
function eventTextAreaCallback(textAreaId, playerName, callback)
if type(callback) ~= "string" then
print(string.format("WARNING: eventTextAreaCallback callback was %s", type(callback)))
return
end
local callbacks = utils_strings.Split(callback, "\n")
for i_c, c in ipairs(callbacks) do
-- close callback
if (c == "close") then
ui.removeTextArea(textAreaId, playerName)
end
-- closeall callback
if (c == "closeall") then
if perms.admins[playerName] then
ui.removeTextArea(textAreaId, nil)
end
end
-- pcmd callback
if (string.sub(c, 1, 5) == "pcmd ") then
commands.Run(playerName, utils_strings.Split(c, " ", 2)[2])
end
-- apcmd callback
if (string.sub(c, 1, 6) == "apcmd ") then
if perms.admins[playerName] then
commands.Run(playerName, utils_strings.Split(c, " ", 2)[2])
else
return
end
end
-- cmd callback
if (string.sub(c, 1, 4) == "cmd ") then
eventChatCommand(playerName, utils_strings.Split(c, " ", 2)[2])
eventChatMessage(playerName, "!" .. utils_strings.Split(c, " ", 2)[2])
end
-- custom function callback
--if (string.sub(c, 1, 5) == "cbfnt ") then
--end
end
end
--- TFM event eventChatMessage
-- This is just to touch the event so it exists.
function eventChatMessage(player_name, message)
end
end
pshy.modules["pshy.bases.scores"].load = function()
--- pshy.bases.scores
--
-- Provide customisable player scoring.
-- Adds an event "eventPlayerScore(player_name, points)".
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
pshy.require("pshy.events")
local help_pages = pshy.require("pshy.help.pages")
pshy.require("pshy.ui.v1")
--- Namespace.
local scores = {}
--- TFM Settings
tfm.exec.disableAutoScore(true)
--- Module Help Page.
--help_pages["pshy_scores"] = {back = "pshy", title = "Scores", text = "This module allows to customize how players make score points.\n", commands = {}}
--help_pages["pshy"].subpages["pshy_scores"] = help_pages["pshy_scores"]
--- Module Settings.
scores.per_win = 0								-- points earned per wins
scores.per_first_wins = {}						-- points earned by the firsts to win
--scores.per_first_wins[1] = 1					-- points for the very first
scores.per_cheese = 0							-- points earned per cheese touched
scores.per_first_cheeses = {}					-- points earned by the firsts to touch the cheese
scores.per_death = 0							-- points earned by death
scores.per_first_deaths = {}					-- points earned by the very first to die
scores.survivors_win = false					-- this round is a survivor round (players win if they survive) (true or the points for surviving)
scores.ui_arbitrary_id = 2918					-- arbitrary ui id
scores.show = true								-- show stats for the map
scores.per_bonus = 0							-- points earned by gettings bonuses of id <= 0
scores.reset_on_leave = true					-- reset points on leave
--- Internal use.
scores.scores = {}						-- total scores points per player
scores.firsts_win = {}				-- total firsts points per player
scores.round_wins = {}				-- current map's first wins
scores.round_cheeses = {}			-- current map's first cheeses
scores.round_deaths = {}			-- current map's first deathes
scores.round_ended = true			-- the round already ended (now counting survivors, or not counting at all)
scores.should_update_ui = false	-- if true, scores ui have to be updated
--- pshy event eventPlayerScore
-- Called when a player earned points according to the module configuration.
function eventPlayerScore(player_name, points)
tfm.exec.setPlayerScore(player_name, scores.scores[player_name], false)
end
--- Give points to a player
function scores.Add(player_name, points)
scores.scores[player_name] = scores.scores[player_name] + points
eventPlayerScore(player_name, points)
end
--- Give points to a player
function scores.Set(player_name, points)
scores.scores[player_name] = points
tfm.exec.setPlayerScore(player_name, scores.scores[player_name], false)
end
--- Update the top players scores ui
-- @param player_name optional player who will see the changes
local function ScoresUpdateRoundTop(player_name)
if ((#scores.round_wins + #scores.round_cheeses + #scores.round_deaths) == 0) then
return
end
local text = "<font size='10'><p align='left'>"
if #scores.round_wins > 0 then
text = text .. "<font color='#ff0000'><b> First Win: " .. scores.round_wins[1] .. "</b></font>\n"
end
if #scores.round_cheeses > 0 then
text = text .. "<d><b> First Cheese: " .. scores.round_cheeses[1] .. "</b></d>\n"
end
if #scores.round_deaths > 0 then
text = text .. "<bv><b> First Death: " .. scores.round_deaths[1] .. "</b></bv>\n"
end
text = text .. "</p></font>"
local title = pshy.UICreate(text)
title.id = scores.ui_arbitrary_id
title.x = 810
title.y = 30
title.w = nil
title.h = nil
title.back_color = 0
title.border_color = 0
pshy.UIShow(title, player_name)
end
--- Reset a player scores
function scores.ResetPlayer(player_name)
assert(type(player_name) == "string")
scores.scores[player_name] = 0
scores.firsts_win[player_name] = 0
tfm.exec.setPlayerScore(player_name, 0, false)
end
--- Reset all players scores
function scores.ResetPlayers()
scores.scores = {}
for player_name, player in pairs(tfm.get.room.playerList) do
scores.ResetPlayer(player_name)
end
end
--- TFM event eventNewGame
function eventNewGame()
scores.round_wins = {}
scores.round_cheeses = {}
scores.round_deaths = {}
scores.round_ended = false
scores.should_update_ui = false
ui.removeTextArea(scores.ui_arbitrary_id, nil)
for player_name, score in pairs(scores.scores) do
tfm.exec.setPlayerScore(player_name, score, false)
end
end
--- TFM event eventLoop
function eventLoop(time, time_remaining)
-- update score if needed
if scores.show and scores.should_update_ui then
ScoresUpdateRoundTop()
scores.should_update_ui = false
end
-- make players win at the end of survivor rounds
if time_remaining < 1000 and scores.survivors_win ~= false then
scores.round_ended = true
for player_name, player in pairs(tfm.get.room.playerList) do
tfm.giveCheese(player_name, true)
tfm.playerVictory(player_name)
end
end
end
--- TFM event eventPlayerDied
function eventPlayerDied(player_name)
if not scores.round_ended then
local points = scores.per_death
table.insert(scores.round_deaths, player_name)
local rank = #scores.round_deaths
if scores.per_first_deaths[rank] then
points = points + scores.per_first_deaths[rank]
end
if points ~= 0 then
scores.Add(player_name, points)
end
end
scores.should_update_ui = true
end
--- TFM event eventPlayerGetCheese
function eventPlayerGetCheese(player_name)
if not scores.round_ended then
local points = scores.per_cheese
table.insert(scores.round_cheeses, player_name)
local rank = #scores.round_cheeses
if scores.per_first_cheeses[rank] then
points = points + scores.per_first_cheeses[rank]
end
if points ~= 0 then
scores.Add(player_name, points)
end
end
scores.should_update_ui = true
end
--- TFM event eventPlayerLeft
function eventPlayerLeft(player_name)
if scores.reset_on_leave then
scores.scores[player_name] = 0
end
end
--- TFM event eventPlayerWon
function eventPlayerWon(player_name, time_elapsed)
local points = 0
if scores.round_ended and scores.survivors_win ~= false then
-- survivor round
points = points + ((scores.survivors_win == true) and scores.per_win or scores.survivors_win)
elseif not scores.round_ended then
-- normal
points = points + scores.per_win
table.insert(scores.round_wins, player_name)
local rank = #scores.round_wins
if scores.per_first_wins[rank] then
points = points + scores.per_first_wins[rank]
end
if rank == 1 then
scores.firsts_win[player_name] = scores.firsts_win[player_name] + points
end
end
if points ~= 0 then
scores.Add(player_name, points)
end
scores.should_update_ui = true
end
--- TFM event eventPlayerBonusGrabbed
function eventPlayerBonusGrabbed(player_name, bonus_id)
if scores.per_bonus ~= 0 then
scores.Add(player_name, scores.per_bonus)
end
end
--- TFM event eventNewPlayer
function eventNewPlayer(player_name)
if not scores.scores[player_name] then
scores.ResetPlayer(player_name)
else
tfm.exec.setPlayerScore(player_name, scores.scores[player_name], false)
end
end
--- Initialization
scores.ResetPlayers()
return scores
end
pshy.modules["pshy.bases.splashscreen"].load = function()
--- pshy.bases.splashscreen
--
-- Adds a splashscreen to a module that is displayed on startup or when a player join.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
pshy.require("pshy.events")
--- Namespace.
local splashscreen = {}
--- Module Settings:
splashscreen.image = "17ab692dc8e.png"		-- splash image
splashscreen.x = 100						-- x location
splashscreen.y = -10						-- y location
splashscreen.sx = 1							-- scale on x
splashscreen.sy = 1							-- scale on y
splashscreen.text = "<fc>Pshy Module</fc>"	-- @todo splash text (over the image)
splashscreen.text_x = 0						-- x location of the text
splashscreen.text_y = 0						-- y location of the text
splashscreen.text_w = nil					-- width of the text, nil for auto
splashscreen.text_h = nil					-- height of the text, nil for auto
splashscreen.text_arbitrary_id = 13
splashscreen.text_backcolor = 0x0			-- back color of the text area
splashscreen.text_bordercolor = 0x0			-- border color of the text area
splashscreen.text_alpha = 1.0				-- opacity of the text
splashscreen.duration = 6 * 1000			-- duration of the splashscreen in milliseconds
--- Internal Use
local first_new_game = true
--- Called by timers when the splashscreen have to be deleted.
local function removeSplashImageCallback(callback_id, image_id)
tfm.exec.removeImage(image_id)
end
--- Show the splashscreen to a player.
-- This is called automatically when a player join or the game start.
local function Show(player_name)
local splash_image_id = tfm.exec.addImage(splashscreen.image, "&0", splashscreen.x, splashscreen.y, player_name, splashscreen.sx, splashscreen.sy)
system.newTimer(removeSplashImageCallback, splashscreen.duration, false, splash_image_id)
end
--- Called by a timer 1 second after the script loaded, in case there were no new game.
local function showSplashIfNoNewgameCallback()
if first_new_game then
Show(nil)
first_new_game = false
end
end
function eventNewGame()
if first_new_game then
Show(nil)
first_new_game = false
end
end
function eventNewPlayer(player_name)
if not first_new_game then
Show(player_name)
end
end
function eventInit()
system.newTimer(showSplashIfNoNewgameCallback, 1000, false)
end
return splashscreen
end
pshy.modules["pshy.bases.version"].load = function()
--- pshy.bases.version
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
pshy = pshy or {}
--- Namespace.
local version = {}
--- Module Settings:
pshy.TFM_VERSION = "8.16"							-- The last tfm version this script was made for.
pshy.TFM_API_VERSION = "0.28"						-- The last tfm api version this script was made for.
version.days_before_update_suggested = 14			-- How old the script should be before suggesting an update (`nil` to disable).
version.days_before_update_advised = 30				-- How old the script should be before requesting an update (`nil` to disable).
version.days_before_update_required = nil			-- How old the script should be before refusing to start (`nil` to disable).
--- Get a table of version numbers from a string representing that version.
-- @param str_v String representing a version such as "8.1".
local function StringToVersion(str_v)
local version_numbers = {}
for number_str in string.gmatch(str_v, "([^%.]+)") do
table.insert(version_numbers, tonumber(number_str))
end
return version_numbers
end
--- Get a table of version numbers from a number representing that version.
-- @param str_v String representing a version such as `8.1`.
local function NumberToVersion(num_v)
local num_1 = math.floor(num_v)
local num_2 = math.floor((num_v - num_1 + 0.001) * 100)
return {num_1, num_2}
end
--- Convert either a number or a string to a version table.
-- See StringToVersion() and NumberToVersion().
local function ToVersion(string_or_number)
if type(string_or_number) == "string" then
return StringToVersion(string_or_number)
else
return NumberToVersion(string_or_number)
end
end
--- Compare 2 version numbers, and return the order of the change (0 == no update, 1 == major, 2 == minor, -1 == behind)
-- @param current The current version, as a list of the numbers in the version.
-- @param current The expected version, as a list of the numbers in the version.
-- @return 0 if the versions are the same, or the index of the number changed. A negative number if the current version is behind the expected one.
local function CompareVersions(expected, current)
local order = 1
while current[order] or expected[order] do
if (current[order] or 0) < (expected[order] or 0) then
return -order
elseif (current[order] or 0) > (expected[order] or 0) then
return order
else
order = order + 1
end
end
return 0
end
--- Compare 2 version numbers represented either by strings or numbers.
-- @return (cf CompareVersions).
local function CompareVersionStrings(expected, current)
return CompareVersions(ToVersion(expected), ToVersion(current))
end
--- Logs informations about the current version.
-- Warn if a version is old or if Transformice or the Lua api were updated.
function version.Check()
print("<v>Pshy version <ch>" .. tostring(pshy.PSHY_VERSION) .. "</ch></v>")
-- check release age
local release_days = pshy.BUILD_TIME / 60 / 60 / 24
local current_days = os.time() / 1000 / 60 / 60 / 24
local days_old = current_days - release_days
if version.days_before_update_required and days_old > version.days_before_update_required then
print(string.format("<r>This build is <vi>%d days</vi> old. Please consider obtaining a newer version.</r>", days_old))
error(string.format("<r>This build is <vi>%d days</vi> old. Please consider obtaining a newer version.</r>", days_old))
elseif version.days_before_update_advised and days_old > version.days_before_update_advised then
print(string.format("<o>This build is <r>%d days</r> old. Please obtain a newer version as soon as possible.</o>", days_old))
elseif version.days_before_update_suggested and days_old > version.days_before_update_suggested then
print(string.format("<j>This build is <o>%d days</o> old. An update may be available.</j>", days_old))
else
print(string.format("<v>This build is <ch>%d days</ch> old.</v>", days_old))
end
if version.days_before_update_required and days_old > version.days_before_update_required / 2 then
print(string.format("<r>⚠ This script will not start after being %d days old.</r>", version.days_before_update_required))
end
-- check tfm api version
local tfm_api_version_diff = CompareVersionStrings(pshy.TFM_API_VERSION, tfm.get.misc.apiVersion)
if tfm_api_version_diff == 1 then
print("<o>⚠ The TFM LUA API had a major update, an update of pshy's script may be available for this new version.</o>")
elseif tfm_api_version_diff == 2 then
print("<j>⚠ The TFM LUA API had a minor update, an update of pshy's script may be available for this new version.</j>")
elseif tfm_api_version_diff < 0 then
print("<vi>⚠ The TFM LUA API version is behind what it is supposed to be</vi>")
end
-- check tfm version
local rounded_tfm_version = math.floor(tfm.get.misc.transformiceVersion * 100 + 0.1) / 100
local tfm_version_diff = CompareVersionStrings(pshy.TFM_VERSION, rounded_tfm_version)
if tfm_version_diff == 1 then
print("<o>⚠ Transformice had a major update, an update of pshy's script may be available for this new version.</o>")
elseif tfm_version_diff == 2 then
print("<j>⚠ Transformice had a minor update, an update of pshy's script may be available for this new version.</j>")
elseif tfm_version_diff < 0 then
print("<vi>⚠ Transformice's version is behind what it is supposed to be!</vi>")
end
end
--- Init
version.Check()
return version
end
do
--- pshy.utils.tfm_enum_fix
--
-- Adds missing values to `tfm.enum.shamanObject`.
-- Also fix some errors.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998 (script)
--
-- @preload
tfm.enum.shamanObject.spirit = 24			-- missing
tfm.enum.shamanObject.bluePortal = 26		-- correct
tfm.enum.shamanObject.orangePortal = 27		-- currently 26 in the API
tfm.enum.shamanObject.fish = 63				-- missing
tfm.enum.shamanObject.oldBox = 96			-- missing but supposed to be removed
tfm.enum.shamanObject.powerOrb = 97			-- missing
end
pshy.modules["pshy.utils.tfm_enum_fix"].loaded = true
pshy.modules["pshy.images.list"].load = function()
--- pshy.images.list
--
-- Images available for TFM scripts.
-- Note: I did not made the images,
-- I only gathered and classified them in this script.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998 (script)
local command_list = pshy.require("pshy.commands.list")
local help_pages = pshy.require("pshy.help.pages")
pshy.require("pshy.utils.tfm_enum_fix")
local utils_strings = pshy.require("pshy.utils.strings")
--- Module Help Page:
help_pages["pshy_imagedb"] = {back = "pshy", title = "Image Search", text = "List of common module images.\n", commands = {}}
help_pages["pshy"].subpages["pshy_imagedb"] = help_pages["pshy_imagedb"]
--- Module Settings:
pshy.imagedb_max_search_results = 20		-- maximum search displayed results
--- Map of images.
-- The key is the image code.
-- The value is a table with the following fields:
--	- w: The pixel width of the picture.
--	- h: The pixel height of the picture (default to `w`).
local images = {}
--- example:
--images["00000000000.png"] = {w = nil, h = nil, desc = ""}
--- Image used as a default by some scripts:
images["15568238225.png"] = {meme = true, w = 40, h = 40, desc = "FUUU"}
--- Tell if an image should be oriented
function pshy.imagedb_IsOriented(image)
if type(image) == "string" then
image = images[image]
end
assert(type(image) == "table", "wrong type " .. type(image))
if image.oriented ~= nil then
return image.oriented
end
if image.meme or image.emoticon or image.w <= 30 then
return false
end
return true
end
--- Search for an image.
-- @private
-- This function is currently for testing only.
-- @param desc Text to find in the image's description.
-- @param words words to search for.
-- @return A list of images matching the search.
function pshy.imagedb_Search(words)
local results = {}
for image_name, image in pairs(images) do
local not_matching = false
for i_word, word in pairs(words) do
if not string.find(image.desc, word) and not image[word] then
not_matching = true
break
end
end
if not not_matching then
table.insert(results, image_name)
end
end
return results
end
--- !searchimage [words...]
local function ChatCommandSearchimage(user, word)
local words = utils_strings.Split(word, ' ', 5)
if #words >= 5 then
return false, "You can use at most 4 words per search!"
end
if #words == 1 and #words[1] <= 1 then
return false, "Please perform a more accurate search!"
end
local image_names = pshy.imagedb_Search(words)
if #image_names == 0 then
tfm.exec.chatMessage("No image found.", user)
else
for i_image, image_name in pairs(image_names) do
if i_image > pshy.imagedb_max_search_results then
tfm.exec.chatMessage("+ " .. tostring(#image_names - pshy.imagedb_max_search_results), user)
break
end
local image = images[image_name]
tfm.exec.chatMessage(image_name .. "\t - " .. tostring(image.desc) .. " (" .. tostring(image.w) .. "," .. tostring(image.w or image.h) .. ")", user)
end
end
return true
end
command_list["searchimage"] = {perms = "cheats", func = ChatCommandSearchimage, desc = "search for an image", argc_min = 1, argc_max = 1, arg_types = {"string"}}
help_pages["pshy_imagedb"].commands["searchimage"] = command_list["searchimage"]
--- Draw an image (wrapper to tfm.exec.addImage).
-- @public
-- @param image_name The image code (called imageId in te original function).
-- @param target On what game element to attach the image to.
-- @param center_x Center coordinates for the image.
-- @param center_y Center coordinates for the image.
-- @param player_name The player who will see the image, or nil for everyone.
-- @param width Width of the image.
-- @param height Height of the image.
-- @param angle The image's rotation (in radians).
-- @param height Opacity of the image.
-- @return The image ID.
function pshy.imagedb_AddImage(image_name, target, center_x, center_y, player_name, width, height, angle, alpha)
if image_name == "none" then
return nil
end
local image = images[image_name] or images["15568238225.png"]
if image.left then
width = -width
end
target = target or "!0"
width = width or image.w
height = height or image.h or image.w
local x = center_x + ((width > 0) and 0 or math.abs(width))-- - width / 2
local y = center_y + ((height > 0) and 0 or math.abs(height))-- - height / 2
local sx = width / (image.w)
local sy = height / (image.h or image.w)
local anchor_x, anchor_y = 0.5, 0.5
return tfm.exec.addImage(image_name, target, x, y, player_name, sx, sy, angle, alpha, anchor_x, anchor_y)
end
--- Draw an image (wrapper to tfm.exec.addImage) but keep the image dimentions (making it fit at least the given area).
-- @public
-- @param image_name The image code (called imageId in te original function).
-- @param target On what game element to attach the image to.
-- @param center_x Center coordinates for the image.
-- @param center_y Center coordinates for the image.
-- @param player_name The player who will see the image, or nil for everyone.
-- @param width Width of the image.
-- @param height Height of the image.
-- @param angle The image's rotation (in radians).
-- @param height Opacity of the image.
-- @return The image ID.
function pshy.imagedb_AddImageMin(image_name, target, center_x, center_y, player_name, min_width, min_height, angle, alpha)
if image_name == "none" then
return nil
end
local image = images[image_name] or images["15568238225.png"]
if image.left then
width = -width
end
target = target or "!0"
local xsign = min_width / (math.abs(min_width))
local ysign = min_height / (math.abs(min_height))
width = min_width or image.w
height = min_height or image.h or image.w
local sx = width / (image.w)
local sy = height / (image.h or image.w)
local sboth = math.max(math.abs(sx), math.abs(sy))
width = image.w * sboth * xsign
height = (image.h or image.w) * sboth * ysign
local x = center_x + ((width > 0) and 0 or math.abs(width))-- - width / 2
local y = center_y + ((height > 0) and 0 or math.abs(height))-- - height / 2
local anchor_x, anchor_y = 0.5, 0.5
return tfm.exec.addImage(image_name, target, x, y, player_name, sboth * xsign, sboth, angle, alpha, anchor_x, anchor_y)
end
return images
end
pshy.modules["pshy.images.list.bonuses"].load = function()
--- pshy.images.list.bonuses
--
-- Bonus images.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998 (script)
local images = pshy.require("pshy.images.list")
-- Bonuses (Pshy#3752)
images["17bef4f49c5.png"] = {bonus = true, w = 30, h = 30, desc = "empty bonus"}
images["17bf4b75aa7.png"] = {bonus = true, w = 30, h = 30, desc = "question bonus"}
images["17bf4ba4ce5.png"] = {bonus = true, w = 30, h = 30, desc = "teleporter bonus"}
images["17bf4b9e11d.png"] = {bonus = true, w = 30, h = 30, desc = "crate bonus"}
images["17bf4b9af56.png"] = {bonus = true, w = 30, h = 30, desc = "high speed bonus"}
images["17bf4b977f5.png"] = {bonus = true, w = 30, h = 30, desc = "ice cube bonus"}
images["17bf4b94d8a.png"] = {bonus = true, w = 30, h = 30, desc = "snowflake bonus"}
images["17bf4b91c35.png"] = {bonus = true, w = 30, h = 30, desc = "broken heart bonus"}
images["17bf4b8f9e4.png"] = {bonus = true, w = 30, h = 30, desc = "heart bonus"}
images["17bf4b8c42d.png"] = {bonus = true, w = 30, h = 30, desc = "feather bonus"}
images["17bf4b89eba.png"] = {bonus = true, w = 30, h = 30, desc = "cross"}
images["17bf4b868c3.png"] = {bonus = true, w = 30, h = 30, desc = "jumping mouse bonus"}
images["17bf4b80fc3.png"] = {bonus = true, w = 30, h = 30, desc = "balloon bonus"}
images["17bef4f49c5.png"] = {bonus = true, w = 30, h = 30, desc = "empty bonus"}
images["17bf4b7ddd6.png"] = {bonus = true, w = 30, h = 30, desc = "triggered mouse trap"}
images["17bf4b7a091.png"] = {bonus = true, w = 30, h = 30, desc = "mouse trap"}
images["17bf4b7250e.png"] = {bonus = true, w = 30, h = 30, desc = "wings bonus"}
images["17bf4b6f226.png"] = {bonus = true, w = 30, h = 30, desc = "transformations bonus"}
images["17bf4b67579.png"] = {bonus = true, w = 30, h = 30, desc = "grow bonus"}
images["17bf4b63aaa.png"] = {bonus = true, w = 30, h = 30, desc = "shrink bonus"}
images["17bf4c421bb.png"] = {bonus = true, w = 30, h = 30, desc = "white flag bonus"}
images["17e59dbef1e.png"] = {bonus = true, w = 30, h = 30, desc = "racing flag bonus"}
images["17bf4f3f2fb.png"] = {bonus = true, w = 30, h = 30, desc = "v check"}
images["17e53fb43dc.png"] = {bonus = true, w = 30, h = 30, desc = "cannonball bonus"}
images["17e59ba43a6.png"] = {bonus = true, w = 30, h = 30, desc = "fish bonus"}
images["17ebfdb85bd.png"] = {bonus = true, w = 30, h = 30, desc = "mouse skull bonus"}
return images
end
pshy.modules["pshy.utils.tables"].load = function()
--- pshy.utils.tables
--
-- Basic functions related to tables.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
local utils_tables = {}
--- Copy a table.
-- @param t The table to copy.
-- @return a copy of the table.
-- disabled because not used
function utils_tables.Copy(t)
assert(type(t) == "table")
local new_table = {}
for key, value in pairs(t) do
new_table[key] = value
end
return new_table
end
--- Copy a table, recursively.
-- @param t The table to copy.
-- @return a copy of the table.
function utils_tables.DeepCopy(t)
assert(type(t) == "table")
local new_table = {}
for key, value in pairs(t) do
if type(value) == "table" then
value = utils_tables.DeepCopy(value)
end
new_table[key] = value
end
return new_table
end
--- Copy a list table.
-- @param t The list table to copy.
-- @return a copy of the list table.
function utils_tables.ListCopy(t)
assert(type(t) == "table")
local new_table = {}
for key, value in ipairs(t) do
table.insert(new_table, value)
end
return new_table
end
--- Get a table's keys as a list.
-- @public
-- @param t The table.
-- @return A list of the keys from the given table.
function utils_tables.Keys(t)
local keys = {}
for key in pairs(t) do
table.insert(keys, key)
end
return keys
end
--- Get a table's keys as a sorted list.
-- @public
-- @param t The table.
-- @return A list of the keys from the given table, sorted.
function utils_tables.SortedKeys(t)
local keys = utils_tables.Keys(t)
table.sort(keys)
return keys
end
--- Count the keys in a table.
-- @public
-- @param t The table.
-- @return The count of keys in the given table.
function utils_tables.CountKeys(t)
local count = 0
for key, value in pairs(t) do
count = count + 1
end
return count
end
--- Check if a table has any key.
-- @public
-- @param t The table.
-- @return true if the table contains a key.
-- disabled because not used
--function pshy.TableHasAnyKey(t)
--	for key in pairs(t) do
--		return true
--	end
--	return false
--end
--- Remove duplicates in a sorted list.
-- @return Count of removed items.
function utils_tables.SortedListRemoveDuplicates(t)
local prev_size = #t
local i = #t - 1
while i >= 1 do
if t[i] == t[i + 1] then
table.remove(t, i + 1)
end
i = i - 1
end
return prev_size - #t
end
--- Remove duplicates in a table.
-- @return Count of removed items.
-- disabled because not used
--function utils_tables.TableRemoveDuplicates(t)
--	local prev_size = #t
--	local keys = {}
--	local i = #t
--	while i >= 1 do
--		if keys[t[i]] then
--			table.remove(t, i + 1)
--		else
--			keys[t[i]] = true
--		end
--		i = i - 1
--	end
--	return prev_size - #t
--end
--- Append a list to another.
-- @param dst_list The list receiving the new items.
-- @param src_list The list containing the items to appen to the other list.
function utils_tables.ListAppend(dst_list, src_list)
assert(type(dst_list) == "table")
assert(type(dst_list) == "table")
for i_item, item in ipairs(src_list) do
table.insert(dst_list, item)
end
end
--- Get a random key from a table.
-- @param t The table.
-- disabled because not used
--function utils_tables.TableGetRandomKey(t)
--	local keylist = {}
--	for k in pairs(t) do
--	    table.insert(keylist, k)
--	end
--	return keylist[math.random(#keylist)]
--end
--- Count a value in a table.
-- @param t The table to count from.
-- @param v The value to search.
function utils_tables.CountValue(t, v)
local count = 0
for key, value in pairs(t) do
if value == v then
count = count + 1
end
end
return count
end
--- Remove all instances of a value from a list.
-- @param l List to remove from.
-- @param v Value to remove.
function utils_tables.ListRemoveValue(l, v)
for i = #l, 1, -1 do
if l[i] == v then
table.remove(l, i)
end
end
end
--- Get a random key from a table.
-- @param t The table.
function utils_tables.RandomTableKey(t)
local keylist = {}
for k in pairs(t) do
table.insert(keylist, k)
end
return keylist[math.random(#keylist)]
end
return utils_tables
end
pshy.modules["pshy.bonuses.list"].load = function()
--- pshy.bonuses.list
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
--- Namespace.
local bonus_types = {}
return bonus_types
end
pshy.modules["pshy.bonuses"].load = function()
--- pshy.bonuses
--
-- Add custom bonuses.
--
-- Either use `bonuses.SetList()` to set the current bonus list.
-- Or add them individually with `bonuses.AddNoCopy(bonus_table)`.
--
-- Fields:
--	x (bonus only):				int, bonus location
--	y (bonus only):				int, bonus location
--	image:						string, bonus image name in pshy_imagedb
--	func:						function to call when the bonus is picked
--								if func returns false then the bonus will not be considered picked by the script (but TFM will)
--	behavior:					how respawning the bonus should be handled
--	enabled (bonus only):		if this bonus is enabled/visible by default
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
pshy.require("pshy.events")
pshy.require("pshy.images.list.bonuses")
pshy.require("pshy.utils.print")
local utils_tables = pshy.require("pshy.utils.tables")
local bonus_types = pshy.require("pshy.bonuses.list")
local players = pshy.require("pshy.players")
local commands_list = pshy.require("pshy.commands.list")
--- Namespace.
local bonuses = {}
--- Bonuses behaviors.
bonuses.BEHAVIOR_STANDARD = nil	-- Standard bonus that can be taken once per player.
bonuses.BEHAVIOR_SHARED = 1		-- Shared bonus that disapear for everyone if someone takes it.
bonuses.BEHAVIOR_REMAIN = 2		-- Bonus that cannot be taken but still does its effect to players passing on it.
bonuses.BEHAVIOR_RESPAWN = 3		-- Standard bonus that respawn when the player respawn.
local PSHY_BONUS_BEHAVIOR_STANDARD = bonuses.BEHAVIOR_STANDARD
local PSHY_BONUS_BEHAVIOR_SHARED = bonuses.BEHAVIOR_SHARED
local PSHY_BONUS_BEHAVIOR_REMAIN = bonuses.BEHAVIOR_REMAIN
local PSHY_BONUS_BEHAVIOR_RESPAWN = bonuses.BEHAVIOR_RESPAWN
--- Temporary function to convert from the old format to the new one.
local function ConvertBonus(bonus)
if type(bonus.type) == "table" then
bonus.type_name = bonus.type_name or "UNKNOWN"
elseif type(bonus.type) == "string" then
bonus.type_name = bonus.type
bonus.type = nil
end
if not bonus.type then
bonus.type = bonus_types[bonus.type_name]
assert(bonus.type, string.format("bonus type %s not found", bonus.type_name))
end
if not bonus.behavior then
if bonus.shared or bonus.type.shared then
bonus.behavior = PSHY_BONUS_BEHAVIOR_SHARED
elseif bonus.remain or bonus.type.remain then
bonus.behavior = PSHY_BONUS_BEHAVIOR_REMAIN
elseif bonus.respawn or bonus.type.respawn then
bonus.behavior = PSHY_BONUS_BEHAVIOR_RESPAWN
end
end
assert(bonus.type)
assert(bonus.type_name)
end
--- Bonus List.
-- Keys: The bonus ids.
-- Values: A table with the following fields:
--	- type: Bonus type, as a table.
--	- x: Bonus coordinates.
--	- y: Bonus coordinates.
--	- enabled: Is it enabled by default (true == always, false == never/manual, nil == once only).
bonuses.list	= {}					-- list of ingame bonuses
local bonuses_taken	= {}					-- set of taken bonus indices (non-shared bonuses use a table)
--- Internal Use:
local bonuses_list = bonuses.list
local players_image_ids = {}					-- Table of players's list of bonus image ids.
local shared_image_ids = {}						-- List of shared bonuses image ids.
local delayed_player_bonuses_refresh = {}		-- Per-player lists of bonuses to readd to the map.
local taken_shared_bonuses = {}					-- Map of taken shared bonuses.
local players_taken_bonuses = {}				-- Per-player map of taken bonuses.
local new_player_joined = false
local loop_count = 0
--- Set the list of bonuses, and show them.
-- @public
function bonuses.SetList(bonus_list)
DisableAllBonuses()
bonuses.list = utils_tables.ListCopy(bonus_list)
bonuses_list = bonuses.list
for bonus_id, bonus in ipairs(bonuses_list) do
ConvertBonus(bonus)
end
EnableAllBonuses()
end
--- Create and enable a bonus.
-- @public
-- @deprecated Use bonuses.AddNoCopy instead.
-- Either use this function or `bonuses.SetList`, but not both.
-- @param bonus_type The name or table corresponding to the bonus type.
-- @param bonus_x The bonus location.
-- @param bonus_y The bonus location.
-- @param enabled Is the bonus enabled for all players by default (nil is yes but not for new players).
-- @return The id of the created bonus.
function bonuses.Add(bonus_type_name, bonus_x, bonus_y, bonus_enabled, angle)
return bonuses.AddNoCopy({type_name = bonus_type_name, x = bonus_x, y = bonus_y, enabled = bonus_enabled, angle = angle})
end
--- Add a bonus to the map.
function bonuses.AddNoCopy(bonus)
-- converty bonus type
ConvertBonus(bonus)
-- id
bonus.id = #bonuses.list + 1
-- insert
bonuses.list[bonus.id] = bonus
-- enable/show
if bonus.enabled ~= false then
bonuses.Enable(bonus.id)
end
if not bonus.angle then
bonus.angle = 0
end
return bonus.id
end
--- Readd a shared image for shared bonuses.
local function RefreshSharedBonusesImages()
for bonus_id, bonus in ipairs(bonuses.list) do
if shared_image_ids[bonus_id] then
-- replace shared bonuses images --@TODO: have separate lists for new players ?
local bonus_behavior = bonus.behavior or bonus.type.behavior
local bonus_image = bonus.image or bonus.type.image
if bonus_behavior == PSHY_BONUS_BEHAVIOR_SHARED or bonus_behavior == PSHY_BONUS_BEHAVIOR_REMAIN then
if bonus_image then
local old_image_id = shared_image_ids[bonus_id]
shared_image_ids[bonus_id] = pshy.imagedb_AddImage(bonus_image, (bonus.foreground or bonus.type.foreground) and "!9999" or "?9999", bonus.x, bonus.y, nil, nil, nil, (bonus.angle or 0) * math.pi * 2 / 360, 1.0)
if old_image_id then
tfm.exec.removeImage(old_image_id)
end
end
end
end
end
end
--- Enable a bonus.
-- @public
-- When a bonus is enabled, it can be picked by players.
function bonuses.Enable(bonus_id, player_name)
assert(type(bonus_id) == "number")
local bonus = bonuses.list[bonus_id]
-- get bonus type
local bonus_type = bonus.type
local bonus_behavior = bonus.behavior or bonus_type.behavior
local bonus_image = bonus.image or bonus_type.image
local bonus_foreground = bonus.foreground or bonus_type.foreground
-- add bonus
tfm.exec.removeBonus(bonus_id, player_name)
tfm.exec.addBonus(0, bonus.x, bonus.y, bonus_id, 0, false, player_name)
-- add image
if bonus_image then
if bonus_behavior == PSHY_BONUS_BEHAVIOR_SHARED or bonus_behavior == PSHY_BONUS_BEHAVIOR_REMAIN then
assert(player_name == nil, "Bonuses of behavior type SHARED or REMAIN can only be enabled/disabled for all players.")
if not shared_image_ids[bonus_id] then
shared_image_ids[bonus_id] = pshy.imagedb_AddImage(bonus_image, (bonus.foreground or bonus.type.foreground) and "!9999" or "?9999", bonus.x, bonus.y, nil, nil, nil, (bonus.angle or 0) * math.pi * 2 / 360, 1.0)
end
else
for player_name in pairs(player_name and {[player_name] = true} or players.in_room) do
if not players_image_ids[player_name] then
players_image_ids[player_name] = {}
end
local ids = players_image_ids[player_name]
if bonus_image and not ids[bonus_id] then
ids[bonus_id] = pshy.imagedb_AddImage(bonus_image, bonus_foreground and "!9999" or "?9999", bonus.x, bonus.y, player_name, nil, nil, (bonus.angle or 0) * math.pi * 2 / 360, 1.0)
end
end
end
end
-- reenabling a bonus cause it to be non-taken
if (bonus.bahavior or bonus_type.behavior) == PSHY_BONUS_BEHAVIOR_SHARED then
taken_shared_bonuses[bonus_id] = nil
else
if players_taken_bonuses[player_name] then
players_taken_bonuses[player_name][bonus_id] = nil
end
end
end
--- Hide a bonus.
-- @public
-- @deprecated Being reworked.
-- This prevent the bonus from being picked, without deleting it.
function bonuses.Disable(bonus_id, player_name)
assert(type(bonus_id) == "number")
if player_name == nil then
for player_name in pairs(tfm.get.room.playerList) do
bonuses.Disable(bonus_id, player_name)
end
return
end
if not players_image_ids[player_name] then
return
end
local bonus = bonuses.list[bonus_id]
local ids = players_image_ids[player_name]
-- if already hidden
if ids[bonus_id] == nil then
return
end
-- remove bonus
tfm.exec.removeBonus(bonus_id, player_name)
-- remove image
tfm.exec.removeImage(ids[bonus_id])
end
--- Show all bonuses.
local function EnableAllBonuses()
print_warn("called EnableAllBonuses() but it isnt supposed to be used")
-- add bonuses
for bonus_id, bonus in pairs(bonuses.list) do
if bonus.enabled ~= false then
tfm.exec.removeBonus(bonus.id, nil)
tfm.exec.addBonus(0, bonus.x, bonus.y, bonus.id, 0, false, nil)
-- add shared bonuses images
local bonus_behavior = bonus.behavior or bonus.type.behavior
if bonus_behavior == PSHY_BONUS_BEHAVIOR_SHARED or bonus_behavior == PSHY_BONUS_BEHAVIOR_REMAIN then
if bonus.image then
shared_image_ids[bonus_id] = pshy.imagedb_AddImage(bonus.image, (bonus.foreground or bonus.type.foreground) and "!9999" or "?9999", bonus.x, bonus.y, nil, nil, nil, (bonus.angle or 0) * math.pi * 2 / 360, 1.0)
end
end
end
end
-- add player bonuses images
for player_name in pairs(players.in_room) do
local images_ids = players_image_ids[player_name]
for bonus_id, bonus in pairs(bonuses.list) do
if bonus.enabled ~= false then
local bonus_behavior = bonus.behavior or bonus.type.behavior
if bonus_behavior == PSHY_BONUS_BEHAVIOR_STANDARD or bonus_behavior == PSHY_BONUS_BEHAVIOR_RESPAWN then
images_ids[bonus_id] = pshy.imagedb_AddImage(bonus.image, (bonus.foreground or bonus.type.foreground) and "!9999" or "?9999", bonus.x, bonus.y, player_name, nil, nil, (bonus.angle or 0) * math.pi * 2 / 360, 1.0)
end
end
end
end
-- non-taken
taken_shared_bonuses = {}
players_taken_bonuses = {}
end
--- Disable all bonuses for all players.
local function DisableAllBonuses()
-- remove bonuses
for bonus_id, bonus in pairs(bonuses.list) do
tfm.exec.removeBonus(bonus.id, nil)
end
-- remove images
for bonus_id, image_id in pairs(shared_image_ids) do
tfm.exec.removeImage(image_id)
end
shared_image_ids = {}
for player_name, images_ids in pairs(players_image_ids) do
for bonus_id, image_id in pairs(images_ids) do
tfm.exec.removeImage(image_id)
end
end
players_image_ids = {}
end
--- Cause a shared bonus to be considered taken.
local function SharedBonusTaken(bonus)
assert(bonus.behavior == PSHY_BONUS_BEHAVIOR_SHARED or bonus.type.behavior == PSHY_BONUS_BEHAVIOR_SHARED)
taken_shared_bonuses[bonus.id] = true
-- remove bonus
tfm.exec.removeBonus(bonus.id, nil)
-- remove image
tfm.exec.removeImage(shared_image_ids[bonus.id])
shared_image_ids[bonus.id] = nil
-- set as taken
taken_shared_bonuses[bonus.id] = bonus
end
--- TFM event eventPlayerBonusGrabbed.
function eventPlayerBonusGrabbed(player_name, id)
-- test for invalid ids
if id < 1 or id > #bonuses.list then
print_warn("%s grabbed a bonus with id %d", player_name, id)
return
end
-- ignoring bonuses taken before the 4th loop
if loop_count < 4 then
print_warn("%s grabbed bonus %d within 2 seconds", player_name, id)
return
end
-- getting the bonus
local bonus = bonuses.list[id]
if not bonus then
print_error("%s grabbed non-existing bonus with id %d", player_name, id)
return
end
-- getting bonus type
local bonus_type = bonus.type
local bonus_behavior = bonus.behavior or bonus_type.behavior
-- checking if that bonus was already taken
if bonus_behavior == PSHY_BONUS_BEHAVIOR_SHARED and taken_shared_bonuses[id] then
return false
-- @TODO: in case of abuse, check if non-shared bonuses were taken already
end
-- running the callback
local func = bonus.func or bonus_type.func
local pick_rst = nil
if func then
pick_rst = func(player_name, bonus)
end
-- bonus fate
if pick_rst == false or bonus_behavior == PSHY_BONUS_BEHAVIOR_REMAIN then
-- bonus remain
if not delayed_player_bonuses_refresh[player_name] then
delayed_player_bonuses_refresh[player_name] = {}
end
table.insert(delayed_player_bonuses_refresh[player_name], bonus)
else
-- bonus is to be removed
if bonus_behavior == PSHY_BONUS_BEHAVIOR_SHARED then
SharedBonusTaken(bonus)
else
-- set bonus as taken
if not players_taken_bonuses[player_name] then
players_taken_bonuses[player_name] = {}
end
local taken_set = players_taken_bonuses[player_name]
taken_set[id] = true
-- remove image
if players_image_ids[player_name] then
tfm.exec.removeImage(players_image_ids[player_name][id])
players_image_ids[player_name][id] = nil
end
end
end
end
function eventNewGame()
bonuses.list = {}
bonuses_list = bonuses.list
players_image_ids = {}
shared_image_ids = {}
delayed_player_bonuses_refresh = {}
taken_shared_bonuses = {}
players_taken_bonuses = {}
loop_count = 0
end
function eventPlayerRespawn(player_name)
for bonus_id, bonus in pairs(bonuses.list) do
local bonus_behavior = bonus.behavior or bonus.type.behavior
if bonus_behavior == PSHY_BONUS_BEHAVIOR_RESPAWN then
bonuses.Enable(bonus_id, player_name)
end
end
end
function eventNewPlayer(player_name)
new_player_joined = true
local taken_set = players_taken_bonuses[player_name]
for bonus_id, bonus in pairs(bonuses.list) do
local bonus_behavior = bonus.behavior or bonus.type.behavior
-- decide wether to spawn bonus in
if bonus_behavior == PSHY_BONUS_BEHAVIOR_RESPAWN then
-- respawn when respawning:
--bonuses.Enable(bonus_id, player_name)
elseif bonus_behavior == PSHY_BONUS_BEHAVIOR_SHARED or bonus_behavior == PSHY_BONUS_BEHAVIOR_REMAIN then
if not taken_shared_bonuses[bonus_id] then
tfm.exec.addBonus(0, bonus.x, bonus.y, bonus.id, 0, false, player_name)
-- redrawn on refresh:
--bonuses.Enable(bonus_id, player_name)
end
else
if not taken_set or not taken_set[bonus_id] then
bonuses.Enable(bonus_id, player_name)
end
end
end
end
function eventPlayerLeft(player_name)
players_image_ids[player_name] = nil
end
function eventLoop()
-- bonuses cannot be taken durring the first 4 loops every game (2 seconds)
loop_count = loop_count + 1
-- refresh shared bonuses on new players
if new_player_joined then
new_player_joined = false
RefreshSharedBonusesImages()
end
-- readd 'remain' bonuses that were taken between last loop.
for player_name, bonus_list in pairs(delayed_player_bonuses_refresh) do
for i_bonus, bonus in ipairs(bonus_list) do
tfm.exec.addBonus(0, bonus.x, bonus.y, bonus.id, 0, false, player_name)
end
end
delayed_player_bonuses_refresh = {}
end
--- Change a team's score.
local function CommandBonusEffect(user, bonus_type, target_player)
target_player = target_player or user
local tfm_player = tfm.get.room.playerList[target_player]
bonus_type.func(target_player, {x = tfm_player.x, y = tfm_player.y})
end
commands_list["bonuseffect"] = {perms = "admins", func = CommandBonusEffect, desc = "play a bonus effect", argc_min = 1, argc_max = 2, arg_types = {bonus_types, "player"}}
return bonuses
end
pshy.modules["pshy.bases.checkpoints"].load = function()
--- pshy.bases.checkpoints
--
-- Adds respawn features.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
local command_list = pshy.require("pshy.commands.list")
pshy.require("pshy.events")
local help_pages = pshy.require("pshy.help.pages")
local players = pshy.require("pshy.players")
local player_list = players.list			-- optimization
--- Namespace.
local checkpoints = {}
--- Module Help Page:
help_pages["pshy_checkpoints"] = {back = "pshy", title = "Checkpoints", text = nil, details = "Use `<ch>!setperm everyone !setcheckpoint yes</ch>` to enable checkpoints for all players.\n", commands = {}}
help_pages["pshy"].subpages["pshy_checkpoints"] = help_pages["pshy_checkpoints"]
--- Internal use:
if not player_list then			-- adds checkpoint_x, checkpoint_y, checkpoint_hasCheese
player_list = {}
end
local just_dead_players = {}
--- Set the checkpoint of a player.
-- @param player_name The player's name.
-- @param x Optional player x location.
-- @param y Optional player y location.
-- @param hasCheese Optional hasCheese tfm player property.
function checkpoints.SetPlayerCheckpoint(player_name, x, y, hasCheese)
player_list[player_name] = player_list[player_name] or {}
local player = player_list[player_name]
x = x or tfm.get.room.playerList[player_name].x
y = y or tfm.get.room.playerList[player_name].y
hasCheese = hasCheese or tfm.get.room.playerList[player_name].hasCheese
player.checkpoint_x = x
player.checkpoint_y = y
player.checkpoint_hasCheese = hasCheese
end
--- Set the checkpoint of a player.
-- @param player_name The player's name.
function checkpoints.UnsetPlayerCheckpoint(player_name)
local player = player_list[player_name]
player.checkpoint_x = nil
player.checkpoint_y = nil
player.checkpoint_hasCheese = nil
end
--- Teleport a player to its checkpoint.
-- Also gives him the cheese if he had it.
-- @param player_name The player's name.
-- @param x Optional player x location.
-- @param y Optional player y location.
function checkpoints.PlayerCheckpoint(player_name)
local player = player_list[player_name]
if player.checkpoint_x then
tfm.exec.respawnPlayer(player_name)
tfm.exec.movePlayer(player_name, player.checkpoint_x, player.checkpoint_y, false, 0, 0, true)
if player.checkpoint_hasCheese then
tfm.exec.giveCheese(player_name)
end
end
end
--- TFM event eventPlayerWon.
-- temporary fix
function eventPlayerWon(player_name)
tfm.get.room.playerList[player_name].hasCheese = false
end
--- TFM event eventPlayerDied.
function eventPlayerDied(player_name)
just_dead_players[player_name] = true
end
--- TFM event eventLoop.
function eventLoop()
for dead_player in pairs(just_dead_players) do
if player_list[dead_player].checkpoint_x then
tfm.exec.respawnPlayer(dead_player)
end
just_dead_players[dead_player] = false
end
end
--- TFM event eventPlayerRespawn.
function eventPlayerRespawn(player_name)
just_dead_players[player_name] = false
checkpoints.PlayerCheckpoint(player_name)
end
--- TFM event eventNewGame.
function eventNewGame(player_name)
for player_name, player in pairs(player_list) do
player.checkpoint_x = nil
player.checkpoint_y = nil
player.checkpoint_hasCheese = nil
end
just_dead_players = {}
end
--- !checkpoint
command_list["gotocheckpoint"] = {perms = "cheats", func = checkpoints.PlayerCheckpoint, desc = "teleport to your checkpoint if you have one", argc_min = 0, argc_max = 0, arg_types = {}}
help_pages["pshy_checkpoints"].commands["gotocheckpoint"] = command_list["gotocheckpoint"]
--- !setcheckpoint
command_list["setcheckpoint"] = {perms = "cheats", func = checkpoints.SetPlayerCheckpoint, desc = "set your checkpoint to the current location", argc_min = 0, argc_max = 0, arg_types = {}}
help_pages["pshy_checkpoints"].commands["setcheckpoint"] = command_list["setcheckpoint"]
--- !setcheckpoint
command_list["unsetcheckpoint"] = {perms = "cheats", func = checkpoints.UnsetPlayerCheckpoint, desc = "delete your checkpoint", argc_min = 0, argc_max = 0, arg_types = {}}
help_pages["pshy_checkpoints"].commands["unsetcheckpoint"] = command_list["unsetcheckpoint"]
return checkpoints
end
pshy.modules["pshy.players.keyboard"].load = function()
--- pshy.players.keyboard
--
-- Extends `pshy.players` with features using the `eventKeyboard` event.
--
-- Adds the following fields:
-- - `is_facing_right`: Is the player facing right.
--
-- Adds the following events:
-- - `eventPlayerDirectionChanged(player_name, is_facing_right)`
-- - `eventPlayerJumpKey(player_name)`
-- - `eventPlayerCrouchKey(player_name)`
-- - `eventPlayerMeepKey(player_name)`
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
pshy.require("pshy.events")
local players = pshy.require("pshy.players")
local player_list = players.list			-- optimization
--- Tell the script that a player exist.
local function TouchPlayer(player_name)
-- direction
player_list[player_name].is_facing_right = true
system.bindKeyboard(player_name, 0, true, true)
system.bindKeyboard(player_name, 2, true, true)
end
function eventPlayerRespawn(player_name)
-- direction
player_list[player_name].is_facing_right = true
end
function eventKeyboard(player_name, keycode, down, x, y)
local player = player_list[player_name]
if down then
-- direction
if keycode == 0 then
if player.is_facing_right ~= false then
player.is_facing_right = false
if eventPlayerDirectionChanged then
eventPlayerDirectionChanged(player_name, false)
end
end
elseif keycode == 2 then
if player.is_facing_right ~= true then
player.is_facing_right = true
if eventPlayerDirectionChanged then
eventPlayerDirectionChanged(player_name, true)
end
end
-- eventPlayerJumpKey
--elseif keycode == 1 then
--	if eventPlayerJumpKey then
--		eventPlayerJumpKey(player_name)
--	end
-- eventPlayerCrouchKey
--elseif keycode == 3 then
--	if eventPlayerCrouchKey then
--		eventPlayerCrouchKey(player_name)
--	end
-- eventPlayerMeepKey
--elseif keycode == 32 then
--	if eventPlayerMeepKey then
--		eventPlayerMeepKey(player_name)
--	end
end
end
end
function eventNewPlayer(player_name)
TouchPlayer(player_name)
end
function eventNewGame()
for player_name in pairs(tfm.get.room.playerList) do
-- direction
player_list[player_name].is_facing_right = true
end
end
function eventInit()
for player_name in pairs(tfm.get.room.playerList) do
TouchPlayer(player_name)
end
end
end
pshy.modules["pshy.bonuses.list.mario"].load = function()
--- pshy.bonuses.list.mario
--
-- Mario related bonuses.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
local bonuses = pshy.require("pshy.bonuses")
local bonus_types = pshy.require("pshy.bonuses.list")
local checkpoints = pshy.require("pshy.bases.checkpoints")
pshy.require("pshy.events")
pshy.require("pshy.images.list.bonuses")
local players = pshy.require("pshy.players")
local player_list = players.list			-- optimization
pshy.require("pshy.players.keyboard")
--- Module Settings
local mario_powerball_delay = 3000
-- Extends players.list items
--		.mario_coins						-- coint of coins grabbed
--		.mario_grown						-- if the player was grown
--		.mario_flower						-- if the player unlocked powerballs
--		.mario_thrown_powerball_id			-- object id of the thrown powerball
--		.mario_next_powerball_time			-- next time the powerball can be used
local tfm_exec_displayParticle = tfm.exec.displayParticle
--- Touch a player.
-- @TODO: this is probably the wrong place.
local function TouchPlayer(player_name)
local player = player_list[player_name]
player.mario_coins = player.mario_coins or 0
player.mario_grown = player.mario_grown or false
player.mario_flower = player.mario_flower or false
player.powerball_type = tfm.enum.shamanObject.snowBall --tfm.enum.shamanObject.(snowBall powerBall chicken)
player.mario_thrown_powerball_id = player.mario_thrown_powerball_id or nil
player.mario_next_powerball_time = player.mario_next_powerball_time or nil
player.mario_name_color = player.mario_name_color or 0xbbbbbb
tfm.exec.setNameColor(player_name, player.mario_name_color)
end
--- MarioCoin.
function bonuses.callback_MarioCoin(player_name, bonus)
local player = player_list[player_name]
player.mario_coins = player.mario_coins + 1
tfm.exec.setPlayerScore(player_name, 1, true)
tfm_exec_displayParticle(tfm.enum.particle.yellowGlitter, bonus.x, bonus.y - 1, 0, -6, 0, 0.4, player_name)
tfm_exec_displayParticle(tfm.enum.particle.yellowGlitter, bonus.x - 1, bonus.y, 0, -6, 0, 0.4, player_name)
tfm_exec_displayParticle(tfm.enum.particle.yellowGlitter, bonus.x, bonus.y + 1, 0, -6, 0, 0.4, player_name)
tfm_exec_displayParticle(tfm.enum.particle.yellowGlitter, bonus.x + 1, bonus.y, 0, -6, 0, 0.4, player_name)
-- update player color
if player.mario_coins == 9 then
player.mario_name_color = 0x6688ff -- blue
elseif player.mario_coins == 25 then
player.mario_name_color = 0x00eeee -- cyan
elseif player.mario_coins == 35 then
player.mario_name_color = 0x77ff77 -- green
elseif player.mario_coins == 55 then
player.mario_name_color = 0xeeee00 -- yellow
elseif player.mario_coins == 75 then
player.mario_name_color = 0xff7700 -- orange
elseif player.mario_coins == 100 then
player.mario_name_color = 0xff0000 -- red
elseif player.mario_coins == 125 then
player.mario_name_color = 0xff00bb -- pink
elseif player.mario_coins == 150 then
player.mario_name_color = 0xbb00ff -- purple
else
return
end
tfm.exec.setNameColor(player_name, player.mario_name_color)
end
bonus_types["MarioCoin"] = {image = "17aa6f22c53.png", func = bonuses.callback_MarioCoin}
--- MarioMushroom.
function bonuses.callback_MarioMushroom(player_name, bonus)
local player = player_list[player_name]
tfm.exec.changePlayerSize(player_name, 1.4)
player.mario_grown = true
tfm_exec_displayParticle(tfm.enum.particle.redGlitter, bonus.x - 1, bonus.y, -1, -2, 0, 0.1, player_name)
tfm_exec_displayParticle(tfm.enum.particle.redGlitter, bonus.x + 0, bonus.y, 0, -2, 0, 0.1, player_name)
tfm_exec_displayParticle(tfm.enum.particle.redGlitter, bonus.x + 1, bonus.y, 1, -2, 0, 0.1, player_name)
end
bonus_types["MarioMushroom"] = {image = "17c431c5e88.png", func = bonuses.callback_MarioMushroom, behavior = bonuses.BEHAVIOR_RESPAWN}
--- MarioFlower.
function bonuses.callback_MarioFlower(player_name, bonus)
local player = player_list[player_name]
tfm.exec.bindKeyboard(player_name, 32, true, true)
player.mario_flower = true
player.mario_next_powerball_time = os.time()
tfm.exec.chatMessage("<ch>Press SPACE to throw a fireball.</ch2>", player_name)
tfm_exec_displayParticle(tfm.enum.particle.orangeGlitter, bonus.x - 1, bonus.y, -1, -2, 0, 0.1, player_name)
tfm_exec_displayParticle(tfm.enum.particle.orangeGlitter, bonus.x + 0, bonus.y, 0, -2, 0, 0.1, player_name)
tfm_exec_displayParticle(tfm.enum.particle.orangeGlitter, bonus.x + 1, bonus.y, 1, -2, 0, 0.1, player_name)
end
bonus_types["MarioFlower"] = {image = "17c41851d61.png", func = bonuses.callback_MarioFlower}
--- MarioCheckpoint.
function bonuses.callback_MarioCheckpoint(player_name, bonus)
local player = player_list[player_name]
tfm.exec.bindKeyboard(player_name, 32, true, true)
player.mario_flower = true
player.mario_next_powerball_time = os.time()
tfm.exec.chatMessage("<d>Checkpoint!</d>", player_name)
checkpoints.SetPlayerCheckPoint(player_name)
end
-- TODO: bonus image
bonus_types["MarioCheckpoint"] = {image = "17bf4c421bb.png", func = bonuses.callback_MarioCheckpoint, behavior = bonuses.BEHAVIOR_REMAIN}
--- TFM event eventKeyboard
-- Handle player teleportations for pipes.
function eventKeyboard(player_name, key_code, down, x, y)
if key_code == 32 and down then
local player = player_list[player_name]
if player.mario_flower and player.mario_next_powerball_time + mario_powerball_delay < os.time() then
if player.mario_thrown_powerball_id then
tfm.exec.removeObject(player.mario_thrown_powerball_id)
player.mario_thrown_powerball_id = nil
end
tfm.exec.playEmote(player_name, tfm.enum.emote.highfive_1, nil)
local speed = player.is_facing_right and 11 or -11
player.mario_thrown_powerball_id = tfm.exec.addShamanObject(player.powerball_type, x + speed * 2, y, 0, speed, 0, false)
tfm.exec.displayParticle(tfm.enum.particle.redGlitter, x + speed * 2, y, speed * 0.15, -0.15)
tfm.exec.displayParticle(tfm.enum.particle.orangeGlitter, x + speed * 2, y, speed * 0.3, 0)
tfm.exec.displayParticle(tfm.enum.particle.redGlitter, x + speed * 2, y, speed * 0.4, 0)
tfm.exec.displayParticle(tfm.enum.particle.orangeGlitter, x + speed * 2, y, speed * 0.26, 0.15)
player.mario_next_powerball_time = os.time()
end
end
end
--- TFM event eventPlayerDied.
function eventPlayerDied(player_name)
local player = player_list[player_name]
if player.mario_grown then
local death_x = tfm.get.room.playerList[player_name].x
local death_y = tfm.get.room.playerList[player_name].y
player.mario_grown = false
tfm.exec.changePlayerSize(player_name, 1)
tfm.exec.respawnPlayer(player_name)
tfm.exec.movePlayer(player_name, death_x, death_y - 30, false)
return false
end
end
--- Cancel changes the module have made.
local function CancelChanges()
for player_name, player in pairs(player_list) do
tfm.exec.changePlayerSize(player_name, 1.0)
player.mario_coins = 0 -- @TODO: do i realy want to reset this ?
player.mario_grown = false
player.mario_flower = false -- @TODO: do i realy want to reset this ?
end
end
--- Pshy event eventGameEnded()
function eventGameEnded()
CancelChanges()
end
--- TFM event eventnewGame
function eventNewGame()
for player_name, player in pairs(player_list) do
player.mario_thrown_powerball_id = nil
player.mario_next_powerball_time = 0
end
CancelChanges()
end
--- TFM event eventNewPlayer.
function eventNewPlayer(player_name)
TouchPlayer(player_name)
end
--- Pshy event eventInit.
function eventInit()
for player_name in pairs(tfm.get.room.playerList) do
TouchPlayer(player_name)
end
end
end
pshy.modules["pshy.events.enable"].load = function()
--- pshy.events.enable
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
local events = pshy.require("pshy.events")
--- Enable a module.
local function EnableModuleEvents(module_name)
local module = pshy.modules[module_name]
if not module then
print(string.format("<r>[ERROR]: EnableModule: Module `%s` not found!<n>", module_name))
return
end
if module.enabled == false then
module.enabled = true
for event_name, event in pairs(events.events) do
module_index = event.module_indices[module_name]
if module_index then
event.functions[module_index] = event.original_functions[module_index]
end
end
end
end
return EnableModuleEvents
end
pshy.modules["pshy.events.disable"].load = function()
--- pshy.events.disable
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
local events = pshy.require("pshy.events")
--- Dummy function.
local dummy_func = function() end
--- Disable a module.
local function DisableModuleEvents(module_name)
local module = pshy.modules[module_name]
if not module then
print(string.format("<r>[ERROR]: DisableModule: Module `%s` not found!<n>", module_name))
return
end
if module.enabled ~= false then
module.enabled = false
for event_name, event in pairs(events.events) do
module_index = event.module_indices[module_name]
if module_index then
event.functions[module_index] = dummy_func
end
end
end
end
return DisableModuleEvents
end
pshy.modules["pshy.commands.list.modules"].load = function()
--- pshy.commands.list.modules
--
-- Basic commands to control modules.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
local command_list = pshy.require("pshy.commands.list")
local help_pages = pshy.require("pshy.help.pages")
local EnableModule = pshy.require("pshy.events.enable")
local DisableModule = pshy.require("pshy.events.disable")
--- Module Help Page:
help_pages["pshy_commands_modules"] = {back = "pshy", title = "Modules", commands = {}}
help_pages["pshy"].subpages["pshy_commands_modules"] = help_pages["pshy_commands_modules"]
--- !modules
local function ChatCommandModules(user, event_name)
tfm.exec.chatMessage("Modules (in require order):", user)
for i_module, module in pairs(pshy.modules_list) do
local status
if not module.loaded then
status = "(<vi>not loaded</vi>)"
elseif module.event_count and module.event_count > 0 then
if module.enabled == false then
status = string.format("(%d <j>disabled</j> events)", module.event_count)
elseif module.event_count and module.event_count > 0 then
status = string.format("(%d <vp>enabled</vp> events)", module.event_count)
end
elseif module.loaded then
status = "(<v>loaded</v>)"
end
tfm.exec.chatMessage(string.format("  &gt; <n>%s %s", module.name, status), user)
end
end
command_list["modules"] = {perms = "admins", func = ChatCommandModules, desc = "see a list of loaded modules having a given event", argc_min = 0, argc_max = 1, arg_types = {"string"}, arg_names = {"event_name"}}
help_pages["pshy_commands_modules"].commands["modules"] = command_list["modules"]
--- !enablemodule
local function ChatCommandModuleenable(user, mname)
return EnableModule(mname)
end
command_list["enablemodule"] = {func = ChatCommandModuleenable, desc = "enable a module (NOT SAFE)", argc_min = 1, argc_max = 1, arg_types = {"string"}}
help_pages["pshy_commands_modules"].commands["enablemodule"] = command_list["enablemodule"]
--- !disablemodule
local function ChatCommandModuledisable(user, mname)
return DisableModule(mname)
end
command_list["disablemodule"] = {func = ChatCommandModuledisable, desc = "disable a module (NOT SAFE)", argc_min = 1, argc_max = 1, arg_types = {"string"}}
help_pages["pshy_commands_modules"].commands["disablemodule"] = command_list["disablemodule"]
--- !modulestop
local function ChatCommandModulestop(user)
print("<j>[Modules] </j>Stopping...")
tfm.exec.chatMessage("<j>[Modules] </j>Stopping...", user)
system.exit()
end
command_list["modulestop"] = {perms = "admins", func = ChatCommandModulestop, desc = "stop the module", argc_min = 0, argc_max = 0}
help_pages["pshy_commands_modules"].commands["modulestop"] = command_list["modulestop"]
--- !pshyversion
local function ChatCommandPshyversion(user)
return true, string.format("Pshy repository version: <r>%s</r>", tostring(pshy.PSHY_VERSION))
end
command_list["pshyversion"] = {perms = "everyone", func = ChatCommandPshyversion, desc = "show pshy_merge's repository version", argc_min = 0, argc_max = 0}
help_pages["pshy_commands_modules"].commands["pshyversion"] = command_list["pshyversion"]
--- !version
local function ChatCommandScriptversion(user)
return true, string.format("Script repository version: <vp>%s</vp>", tostring(pshy.MAIN_VERSION or "Not repository version available."))
end
command_list["version"] = {perms = "everyone", func = ChatCommandScriptversion, desc = "show the current script's repository version", argc_min = 0, argc_max = 0}
help_pages["pshy_commands_modules"].commands["pshyversion"] = command_list["pshyversion"]
end
pshy.modules["pshy.enums.keycodes"].load = function()
--- pshy.enums.keycodes
--
-- This file is a memo for key codes.
-- This contains two maps:
--	- keycodes: map of key names to key codes
--	- pshy.keynames: map of key codes to key names
--
-- @source https://help.adobe.com/fr_FR/FlashPlatform/reference/actionscript/3/flash/ui/Keyboard.html
-- @author TFM:Pshy#3753 DC:Pshy#7998
--- Map of key name -> key code
local keycodes = {}
-- Directions:
keycodes.LEFT = 0
keycodes.UP = 1
keycodes.RIGHT = 2
keycodes.DOWN = 3
-- modifiers
keycodes.SHIFT = 16
keycodes.CTRL = 17
keycodes.ALT = 18
-- Arrows:
keycodes.ARROW_LEFT = 37
keycodes.ARROW_UP = 38
keycodes.ARROW_RIGHT = 39
keycodes.ARROW_DOWN = 40
-- Letters
for i_letter = 0, 25 do
keycodes[string.char(65 + i_letter)] = 65 + i_letter
end
-- Numbers (48 - 57):
for number = 0, 9 do
keycodes["NUMBER_" .. tostring(number)] = 48 + number
end
-- Numpad Numbers (96 - 105):
for number = 0, 9 do
keycodes["NUMPAD_" .. tostring(number)] = 96 + number
end
-- Numpad
keycodes.NUMPAD_MULTIPLY = 106
keycodes.NUMPAD_ADD = 107
keycodes.NUMPAD_SUBTRACT = 109
keycodes.NUMPAD_ENTER = 108
keycodes.NUMPAD_DECIMAL = 110
keycodes.NUMPAD_DIVIDE = 111
-- F1 - F12 (112 - 123)
for f_index = 0, 11 do
keycodes["F" .. tostring(f_index + 1)] = 112 + f_index
end
-- Other
keycodes.BACKSPACE = 8
keycodes.TAB = 9
keycodes.ENTER = 13
keycodes.PAUSE = 19
keycodes.CAPSLOCK = 20
keycodes.ESCAPE = 27
keycodes.SPACE = 32
keycodes.PAGE_UP = 33
keycodes.PAGE_DOWN = 34
keycodes.END = 35
keycodes.HOME = 36
keycodes.INSERT = 45
keycodes.DELETE = 46
keycodes.SEMICOLON = 186
keycodes.EQUALS = 187
keycodes.COMMA = 188
keycodes.HYPHEN = 189
keycodes.PERIOD = 190
keycodes.SLASH = 191
keycodes.GRAVE = 192
keycodes.LEFTBRACKET = 219
keycodes.BACKSLASH = 220
keycodes.RIGHTBRACKET = 221
return keycodes
end
pshy.modules["pshy.help"].load = function()
--- pshy.help
--
-- Add a help commands and an in-game help interface.
--
-- @author tfm:Pshy#3752
local commands = pshy.require("pshy.commands")
local command_list = pshy.require("pshy.commands.list")
pshy.require("pshy.events")
pshy.require("pshy.ui.v1")
local perms = pshy.require("pshy.perms")
local pages = pshy.require("pshy.help.pages")
--- Namespace.
local help = {}
--- Module Settings:
local arbitrary_text_id_page_list = 315
local arbitrary_text_id_title_area = 316
local arbitrary_text_id_main_body = 317
--- Internal Use:
local html_page_list = ""
local html_page_list_admins = ""
--- Get a chat command desc text.
-- @param chat_command_name The name of the chat command.
function help.GetChatCommandDesc(chat_command_name)
local cmd = command_list[chat_command_name]
local desc = cmd.desc or "no description"
return desc
end
--- Get a chat command help html.
-- @param chat_command_name The name of the chat command.
function help.GetChatCommandHelpHtml(command_name, is_admin)
local real_command = commands.GetCommand(command_name)
if not real_command then
return "<r>This command does not exist or is unavailable.</r>"
end
if real_command.restricted and not is_admin then
return "<r>You do not have permissions to view this.</r>"
end
local html = "<j><i><b>"
-- usage
local html = html .. real_command.usage or "(no usage, error)"
-- short description
html = html .. "</b></i>\t - " .. (real_command.desc and tostring(real_command.desc) or "no description")
-- help + other info
if real_command.help then
html = html .. "\n" .. real_command.help
end
if not real_command.func then
html = html .. "\nThis command is not handled by pshy_commands."
end
html = html .. "</j>"
return html
end
--- Get the html to display in the title area.
function help.GetHelpPageHtmlTitleArea(page_name, is_admin)
local page = pages[page_name] or pages[""]
-- title menu
local html = "<bv><p align='right'><font size='14'><b>"
html = html .. " <bl><a href='event:pcmd man " .. (page.back or "") .. "'> ↶ </a></bl>"
html = html .. " <r><a href='event:pcmd closeman'> × </a></r>        "
html = html .. "</b></font></p>"
-- title
html = html .. "<p align='center'><font size='16'>" .. (page.title or page_name) .. '</font></p>\n'
-- text
if not page.restricted or is_admin then
html = html .. "<p align='center'>" .. (page.text or "") .. "</p>"
end
html = html .. "</bv>"
return html
end
--- Get the html to display for a page.
function help.GetHelpPageHtml(page_name, is_admin)
local page = pages[page_name]
page = page or pages[""]
local html = ""
-- title menu
local html = ""
-- restricted ?
if page.restricted and not is_admin then
html = html .. "<p align='center'><r>Access to this page is restricted.</r></p>\n"
return html
end
-- details
if page.details then
html = html .. "<p align='center'><vp>" .. page.details .. "</vp></p>"
end
-- commands
if page.commands then
html = html .. "<bv><p align='center'><font size='16'>Commands" .. "</font></p>\n"
for cmd_name, cmd in pairs(page.commands) do
local m1, m2 = commands.GetPermColorMarkups("!" .. cmd_name)
--html = html .. '!' .. ex_cmd .. "\t - " .. (cmd.desc or "no description") .. '\n'
html = html .. m1
--html = html .. "<u><a href='event:pcmd help " .. cmd_name .. "'>" .. commands.GetUsage(cmd_name) .. "</a></u>"
html = html .. "<u>" .. (cmd.usage or "(no usage, error)") .. "</u>"
html = html .. m2
html = html .. "\t - " .. (cmd.desc or "no description") .. "\n"
end
html = html .. "</bv>\n"
end
-- examples
if page.examples then
html = html .. "<rose><p align='center'><font size='16'>Examples" .. "</font> (click to run)</p>\n"
for ex_cmd, ex_desc in pairs(page.examples) do
--html = html .. "!" .. ex_cmd .. "\t - " .. ex_desc .. '\n'
html = html .. "<j><i><a href='event:cmd " .. ex_cmd .. "'>!" .. ex_cmd .. "</a></i></j>\t - " .. ex_desc .. '\n'
end
html = html .. "</rose>\n"
end
-- subpages
if page.subpages then
html = html .. "<ch><p align='center'><font size='16'>Subpages:" .. "</font></p>\n<p align='center'><u>"
for subpage_name, subpage in pairs(page.subpages) do
if not subpage.restricted or is_admin then
--html = html .. subpage .. '\n'
if subpage and subpage.title then
html = html .. "<a href='event:pcmd man " .. subpage_name .. "'>" .. subpage.title .. "</a>\n"
else
html = html .. "<a href='event:pcmd man " .. subpage_name .. "'>" .. subpage_name .. "</a>\n"
end
end
end
html = html .. "</u></p></ch>"
end
return html
end
--- !help [command]
-- Get general help or help about a specific page/command.
local function ChatCommandMan(user, page_name)
if page_name == nil then
page_name = ""
end
local page = pages[page_name]
local title_area_text
local main_body_text
if page then
if not page.restricted or perms.admins[user] then
title_area_text = page and page.html_1 or help.GetHelpPageHtmlTitleArea(page_name, perms.admins[user])
main_body_text = page.html_2
else
title_area_text = page and page.html_1 or help.GetHelpPageHtmlTitleArea(page_name, perms.admins[user])
main_body_text = "<p align='center'><font size='16'><r>This page is restricted.</r></font></p>"
end
elseif string.sub(page_name, 1, 1) == '!' then
main_body_text = help.GetChatCommandHelpHtml(string.sub(page_name, 2, #page_name), perms.admins[user])
tfm.exec.chatMessage(main_body_text, user)
return true
elseif command_list[page_name] then
main_body_text = help.GetChatCommandHelpHtml(page_name)
tfm.exec.chatMessage(main_body_text, user)
return true
else
main_body_text = help.GetHelpPageHtml(page_name, perms.admins[user])
title_area_text = help.GetHelpPageHtmlTitleArea(page_name, perms.admins[user])
end
main_body_text = "<font size='10'><b><n>" .. main_body_text .. "</n></b></font>"
if #main_body_text > 2000 then
error("#html is too big: == " .. tostring(#main_body_text))
end
ui.addTextArea(arbitrary_text_id_title_area, title_area_text, user, 200, 40, 570, 100, 0x010101, 0x010101, 0.95, true)
ui.addTextArea(arbitrary_text_id_main_body, main_body_text, user, 200, 160, 570, 220, 0x010101, 0x010101, 0.95, true)
-- page list:
local page_list_text = perms.admins[user] and html_page_list_admins or html_page_list
ui.addTextArea(arbitrary_text_id_page_list, page_list_text, user, 30, 40, 150, 340, 0x010101, 0x010101, 0.95, true)
return true
end
command_list["man"] = {aliases = {"help"}, perms = "everyone", func = ChatCommandMan, desc = "show a help panel", argc_min = 0, argc_max = 1, arg_types = {"string"}}
--- !closehelp
local function ChatCommandCloseman(user, page_name)
ui.removeTextArea(arbitrary_text_id_page_list, user)
ui.removeTextArea(arbitrary_text_id_title_area, user)
ui.removeTextArea(arbitrary_text_id_main_body, user)
return true
end
command_list["closeman"] = {aliases = {"closehelp"}, perms = "everyone", func = ChatCommandCloseman, desc = "hide the help panel", argc_min = 0, argc_max = 1, arg_types = {"string"}}
--- Pshy event eventInit
function eventInit()
html_page_list = "<ch><b><p align='center'>"
html_page_list_admins = "<ch><b><p align='center'>"
for page_name, page in pairs(pages) do
if not page.back or page.back == "" or page.back == "pshy" then
local line =  "<u><a href='event:pcmd help " .. page_name .. "'>" .. (page.title or page_name) .. "</a></u>\n"
if not page.restricted then
html_page_list = html_page_list .. line
html_page_list_admins = html_page_list_admins .. line
else
html_page_list_admins = html_page_list_admins .. "<r>" .. line .. "</r>"
end
end
end
html_page_list = html_page_list .. "</p></b></ch>"
html_page_list_admins = html_page_list_admins .. "</p></b></ch>"
-- precompute html help pages
for page_name, page in pairs(pages) do
page.html_1 = help.GetHelpPageHtmlTitleArea(page_name, true)
page.html_2 = help.GetHelpPageHtml(page_name, true)
end
end
return help
end
pshy.modules["pshy.commands.get_target_or_error"].load = function()
--- pshy.commands.get_target_or_error
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
local perms = pshy.require("pshy.perms")
--- Get a command target player or throw on permission issue.
-- This function can be used to check if a player can run a command on another one.
local function GetTargetOrError(user, target, perm_prefix)
if not target then
return user
end
if target == user then
return user
elseif not perms.HavePerm(user, perm_prefix .. "-others") then
error("You do not have permission to use this command on others.")
return
end
return target
end
return GetTargetOrError
end
pshy.modules["pshy.images.changeimage"].load = function()
--- pshy.images.changeimage
--
-- Allow players to change their image.
--
-- @author TFM:Pshy#3752 DC:Pshy#3752
local command_list = pshy.require("pshy.commands.list")
pshy.require("pshy.events")
local help_pages = pshy.require("pshy.help.pages")
local utils_strings = pshy.require("pshy.utils.strings")
local images = pshy.require("pshy.images.list")
--- Namespace.
local changeimage = {}
--- Module Help Page:
help_pages["pshy_changeimage"] = {back = "pshy", title = "Image Change", text = "Change your image.\n", commands = {}}
help_pages["pshy"].subpages["pshy_changeimage"] = help_pages["pshy_changeimage"]
--- Module Settings:
pshy.changesize_keep_changes_on_new_game = true
--- Internal Use:
local players = {}
--- Get the target of the command, throwing on permission issue.
local GetTarget = pshy.require("pshy.commands.get_target_or_error")
--- Remove an image for a player.
function changeimage.RemoveImage(player_name)
if players[player_name].image_id then
tfm.exec.removeImage(players[player_name].image_id)
end
players[player_name] = nil
tfm.exec.changePlayerSize(player_name, 0.9)
tfm.exec.changePlayerSize(player_name, 1.0)
end
--- Update a player's image.
function changeimage.UpdateImage(player_name)
local player = players[player_name]
-- get draw settings
local orientation = player.player_orientation or 1
if not pshy.imagedb_IsOriented(player.image_name) then
orientation = 1
end
-- skip if update not required
if player.image_id and player.image_orientation == orientation then
return
end
-- update image
local old_image_id = player.image_id
player.image_id = pshy.imagedb_AddImageMin(player.image_name, "%" .. player_name, 0, 0, nil, 40 * orientation, 30, 0.0, 1.0)
player.image_orientation = orientation
if old_image_id then
-- remove previous
tfm.exec.removeImage(old_image_id)
end
end
--- Change a player's image.
function changeimage.ChangeImage(player_name, image_name)
players[player_name] = players[player_name] or {}
local player = players[player_name]
if player.image_id then
tfm.exec.removeImage(player.image_id)
player.image_id = nil
end
player.image_name = nil
if image_name then
-- enable the image
system.bindKeyboard(player_name, 0, true, true)
system.bindKeyboard(player_name, 2, true, true)
player.image_name = image_name
player.player_orientation = (tfm.get.room.playerList[player_name].isFacingRight) and 1 or -1
player.available_update_count = 2
changeimage.UpdateImage(player_name)
else
-- disable the image
changeimage.RemoveImage(player_name)
end
end
function eventKeyboard(player_name, keycode, down, x, y)
if down and (keycode == 0 or keycode == 2) then
local player = players[player_name]
if not player or player.available_update_count <= 0 then
return
end
player.available_update_count = player.available_update_count - 1
player.player_orientation = (keycode == 2) and 1 or -1
changeimage.UpdateImage(player_name)
end
end
--- TFM event eventPlayerRespawn
function eventPlayerRespawn(player_name)
if players[player_name] then
changeimage.UpdateImage(player_name)
end
end
--- TFM even eventNewGame.
function eventNewGame()
-- images are deleted on new games
for player_name in pairs(tfm.get.room.playerList) do
if players[player_name] then
players[player_name].image_id = nil
end
end
-- keep player images
if pshy.changesize_keep_changes_on_new_game then
for player_name in pairs(tfm.get.room.playerList) do
if players[player_name] then
changeimage.UpdateImage(player_name)
end
end
end
end
--- TFM event eventPlayerDied
function eventPlayerDied(player_name)
if players[player_name] then
players[player_name].image_id = nil
end
end
--- TFM event eventLoop.
function eventLoop(time, time_remaining)
for player_name, player in pairs(players) do
player.available_update_count = 2
end
end
--- !changeimage <image_name> [player_name]
local function ChatCommandChangeimage(user, image_name, target)
target = GetTarget(user, target, "!changeimage")
local image = images[image_name]
if image_name == "off" then
changeimage.ChangeImage(target, nil)
return
end
if not image then
return false, "Unknown or not approved image."
end
if not image.w then
return false, "This image cannot be used (unknown width)."
end
if image.w > 400 or (image.h and image.h > 400)  then
return false, "This image is too big (w/h > 400)."
end
changeimage.ChangeImage(target, image_name)
return true, "Image changed!"
end
command_list["changeimage"] = {perms = "cheats", func = ChatCommandChangeimage, desc = "change your image", argc_min = 1, argc_max = 2, arg_types = {"string", "player"}}
help_pages["pshy_changeimage"].commands["changeimage"] = command_list["changeimage"]
--- !randomchangeimage <words>
local function ChatCommandRandomchangeimage(user, words)
words = utils_strings.Split(words, ' ', 4)
local image_names = pshy.imagedb_Search(words)
return ChatCommandChangeimage(user, image_names[math.random(#image_names)])
end
command_list["randomchangeimage"] = {perms = "cheats", func = ChatCommandRandomchangeimage, desc = "change your image to a random image matching a search", argc_min = 1, argc_max = 1, arg_types = {"string"}}
help_pages["pshy_changeimage"].commands["randomchangeimage"] = command_list["randomchangeimage"]
--- !randomchangeimages <words>
local function ChatCommandRandomchangeimageeveryone(user, words)
local words = utils_strings.Split(words, ' ', 4)
local image_names = pshy.imagedb_Search(words)
local r1, r2
for player_name in pairs(tfm.get.room.playerList) do
r1, r2 = ChatCommandChangeimage(player_name, image_names[math.random(#image_names)])
if r1 == false then
return r1, r2
end
end
return true, "All images changed!"
end
command_list["randomchangeimages"] = {perms = "admins", func = ChatCommandRandomchangeimageeveryone, desc = "change everyone's image to a random image matching a search", argc_min = 1, argc_max = 1, arg_types = {"string"}}
help_pages["pshy_changeimage"].commands["randomchangeimages"] = command_list["randomchangeimages"]
return changeimage
end
pshy.modules["pshy.utils.rotation"].load = function()
--- pshy.utils.rotation
--
-- Adds a table type that can be used to create random rotations.
--
-- A rotation is a table with the following fields:
--	- items: List of items to be randomly returned.
--	- next_indices: Private list of item indices that have not been done yet.
--	- is_random: `false` to disable randomness.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
--- Rotation.
-- Represent a collection of items that can be obtained one after another.
local Rotation = {
items = {},				-- The items in the rotation.
next_indices = {},		-- The indices of the items remaining to return.
is_random = true,		-- Should the items be returned in a random order?
}
Rotation.__index = Rotation
--- Create a rotation.
-- You can then add items in its `items` field.
function Rotation:New(o)
assert(self == Rotation)
local o = o or {}
o.items = o.items or {}
o.next_indices = o.next_indices or {}
setmetatable(o, self)
return o
end
--- Reset a rotation.
-- Its state will be back as if you had never poped items from it.
function Rotation:Reset()
assert(self ~= Rotation)
self.next_indices = {}
if #self.items > 0 then
local table_insert = table.insert
local next_indices = self.next_indices
for i = 1, #self.items do
table_insert(next_indices, i)
end
end
end
--- Get the index of an item in the rotation.
function Rotation:IndexOf(search_item)
assert(self ~= Rotation)
for i_item, item in ipairs(self.items) do
if item == search_item then
return i_item
end
end
end
function Rotation:SkipIndex(index)
assert(self ~= Rotation)
table.remove(self.next_indices, index)
if not self.is_random then
self.next_indices = {}
if #self.items > 0 then
local table_insert = table.insert
local next_indices = self.next_indices
for i = index + 1, #self.items do
table_insert(next_indices, i)
end
end
end
end
--- Skip to a given item.
-- If the item is not found then nothing is done.
function Rotation:SkipItem(item)
assert(self ~= Rotation)
local index = self:IndexOf(item)
if index then
return self:SkipIndex(index)
end
end
--- Get a random item from a rotation.
-- @return A random item from the rotation.
function Rotation:Next()
assert(self ~= Rotation)
if #self.items == 0 then
return nil
end
-- reset the rotation if needed
self.next_indices = self.next_indices or {}
if #self.next_indices == 0 then
self:Reset()
end
-- pop the item
local i_index = (self.is_random == false) and 1 or math.random(#self.next_indices)
local item = self.items[self.next_indices[i_index]]
table.remove(self.next_indices, i_index)
-- returning
return item
end
return Rotation
end
pshy.modules["pshy.maps.list"].load = function()
--- pshy.maps.list
--
-- @author TFM:Pshy#3752 DC:Pshy#7998 (script)
--- Map of maps.
local maps = {}
--- Test Map:
maps["test"]		= {author = "Test#0801", title = "Test Map", title_color="#ff7700", background_color = "#FF00FF", xml = [[<C><P F="0" shaman_tools="1,33,102,110,111,202,302,402,608,1002,2802,2,2806" MEDATA=";;;;-0;0:::1-"/><Z><S><S T="6" X="400" Y="250" L="120" H="40" P="0,0,0.3,0.2,0,0,0,0"/></S><D><F X="432" Y="218"/><P X="393" Y="230" T="11" P="0,0"/><DC X="362" Y="213"/><DS X="436" Y="107"/></D><O/><L/></Z></C>]]}
maps["error_map"]	= {author = "Error", duration = 20, title = "an error happened", xml = 7893612}
return maps
end
pshy.modules["pshy.rotations.list"].load = function()
--- pshy.rotations.list
--
-- List of maps and rotations.
-- Custom settings may be used by other modules.
--
-- Listed map and rotation tables can have the following fields:
--	- begin_func: Function to run when the map started.
--	- end_func: Function to run when the map stopped.
--	- replace_func: Function to run on the map's xml (or name if not present) that is supposed to return the final xml.
--	- autoskip: If true, the map will change at the end of the timer.
--	- duration: Duration of the map.
--	- shamans: Count of shamans (Currently, only 0 is supported to disable the shaman).
--	- xml (maps only): The true map's xml code.
--	- hidden (rotations only): Do not show the rotation is being used to players.
--	- modules: list of module names to enable while the map is playing (to trigger events).
--	- troll: bool telling if the rotation itself is a troll (may help other modules about how to handle the rotation).
--	- unique_items: bool telling if the items are supposed to be unique (duplicates are removed on eventInit).
-- See `pshy_madb_misc_maps.lua` for a more complete list of maps and rotations.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998 (script)
--- Rotations Map:
local rotations = {}					-- map of rotations
--- Aliases:
pshy.mapdb_rotation_aliases = {}
--- Get a rotation table.
function pshy.mapdb_GetRotation(rotation_name)
while pshy.mapdb_rotation_aliases[rotation_name] do
rotation_name = pshy.mapdb_rotation_aliases[rotation_name]
end
return rotations[rotation_name]
end
function eventInit()
for rotation_name, rotation in pairs(rotations) do
rotation.name = rotation.name or rotation_name
end
end
return rotations
end
pshy.modules["pshy.rotations.list.transformice"].load = function()
--- pshy.rotations.list.transformice
--
-- @author TFM:Pshy#3752 DC:Pshy#7998 (script)
local Rotation = pshy.require("pshy.utils.rotation")
local rotations = pshy.require("pshy.rotations.list")
--- Map Lists:
-- Vanilla:
local maps_vanilla = {}
local deleted_vanilla_maps = {[29] = true, [108] = true, [110] = true, [111] = true, [112] = true, [113] = true, [135] = true, [169] = true, [193] = true, [194] = true, [195] = true, [196] = true, [197] = true, [198] = true, [199] = true}
for i = 0, 227 do
if not deleted_vanilla_maps[i] then
table.insert(maps_vanilla, i)
end
end
--- Basic Rotations.
rotations["vanilla"]		= Rotation:New({desc = "0-210", duration = 120, items = maps_vanilla})
rotations["P0"]				= Rotation:New({desc = "P0 - standard", duration = 120, items = {"#0"}})
rotations["P1"]				= Rotation:New({desc = "P1 - protected", duration = 120, items = {"#1"}})
rotations["P4"]				= Rotation:New({desc = "P4 - shaman", duration = 120, items = {"#4"}})
rotations["P5"]				= Rotation:New({desc = "P5 - art", duration = 120, items = {"#5"}})
rotations["P6"]				= Rotation:New({desc = "P6 - mechanisms", duration = 120, items = {"#6"}})
rotations["P7"]				= Rotation:New({desc = "P7 - no shaman", duration = 60, shamans = 0, items = {"#7"}})
rotations["P8"]				= Rotation:New({desc = "P8 - dual shaman", duration = 60, shamans = 0, items = {"#8"}})
rotations["P9"]				= Rotation:New({desc = "P9 - miscellaneous", duration = 60, shamans = 0, items = {"#9"}})
rotations["P17"]			= Rotation:New({desc = "P17 - racing", duration = 60, shamans = 0, items = {"#17"}})
rotations["P18"]			= Rotation:New({desc = "P18 - defilante", duration = 60, shamans = 0, items = {"#18"}})
rotations["P38"]			= Rotation:New({desc = "P38 - racing test", duration = 60, shamans = 0, items = {"#38"}})
rotations["P66"]			= Rotation:New({desc = "P66 - thematic", duration = 60, shamans = 0, items = {"#66"}})
rotations["transformice"]	= Rotation:New({is_random = false, items = {"vanilla", "#4", "#9", "#5", "#1", "vanilla", "#8", "#6", "#7", "#0"}})
--- Rotation aliases:
pshy.mapdb_rotation_aliases["standard"]			= "P0"
pshy.mapdb_rotation_aliases["protected"]		= "P1"
pshy.mapdb_rotation_aliases["shaman"]			= "P4"
pshy.mapdb_rotation_aliases["art"]				= "P5"
pshy.mapdb_rotation_aliases["mechanisms"]		= "P6"
pshy.mapdb_rotation_aliases["nosham"]			= "P7"
pshy.mapdb_rotation_aliases["no_shaman"]		= "P7"
pshy.mapdb_rotation_aliases["dual_shaman"]		= "P8"
pshy.mapdb_rotation_aliases["misc"]				= "P9"
pshy.mapdb_rotation_aliases["miscellaneous"]	= "P9"
pshy.mapdb_rotation_aliases["racing"]			= "P17"
pshy.mapdb_rotation_aliases["defilante"]		= "P18"
pshy.mapdb_rotation_aliases["racing_test"]		= "P38"
pshy.mapdb_rotation_aliases["thematic"]			= "P66"
return rotations
end
pshy.modules["pshy.rotations.newgame"].load = function()
--- pshy.rotations.newgame
--
-- Override and replace `tfm.exec.newGame`.
-- Adds custom map features.
-- Calls `eventGameEnded` just before a map change.
--
-- Listed map and rotation tables can have the following fields:
--	- begin_func: Function to run when the map started.
--	- end_func: Function to run when the map stopped.
--	- replace_func: Function to run on the map's xml (or name if not present) that is supposed to return the final xml.
--	- autoskip: If true, the map will change at the end of the timer.
--	- duration: Duration of the map.
--	- shamans: Count of shamans (Currently, only 0 is supported to disable the shaman).
--	- xml (maps only): The true map's xml code.
--	- hidden (rotations only): Do not show the rotation is being used to players.
--	- modules: list of module names to enable while the map is playing (to trigger events).
--	- troll: bool telling if the rotation itself is a troll (may help other modules about how to handle the rotation).
--	- unique_items: bool telling if the items are supposed to be unique (duplicates are removed on eventInit).
--
-- @author TFM:Pshy#3752 DC:Pshy#7998 (script)
--
-- @TODO: replace pshy namespace function by locals when appropriate
-- @TODO: override disableAutoNewGame() and override its behavior (in pshy_newgame_ext)
-- @TODO: spawn the shamans from `mapinfo.mapinfo.shaman_spawns` (in pshy_newgame_ext)
-- @TODO: move bonus spawning to ext ?
-- @TODO: check what feature do utility support
local command_list = pshy.require("pshy.commands.list")
pshy.require("pshy.events")
local help_pages = pshy.require("pshy.help.pages")
pshy.require("pshy.utils.print")
local Rotation = pshy.require("pshy.utils.rotation")
local DisableModule = pshy.require("pshy.events.disable")
local EnableModule = pshy.require("pshy.events.enable")
local utils_tables = pshy.require("pshy.utils.tables")
local utils_tfm = pshy.require("pshy.utils.tfm")
local maps = pshy.require("pshy.maps.list")
local rotations = pshy.require("pshy.rotations.list")
pshy.require("pshy.rotations.list.transformice")
local mapinfo = pshy.require("pshy.rotations.mapinfo", true)
local perms = pshy.require("pshy.perms")
--- Namespace.
local newgame = {}
--- Module Help Page:
help_pages["pshy_newgame"] = {back = "pshy", title = "Rotations", text = "Replaces tfm.exec.newGame, adding features.\n", commands = {}}
help_pages["pshy"].subpages["pshy_newgame"] = help_pages["pshy_newgame"]
--- Module Settings:
newgame.default = "default"			-- default rotation, can be a rotation of rotations
rotations["default"]					= Rotation:New({hidden = true, items = {"transformice"}})	-- default rotation, can only use other rotations, no maps
newgame.default_rotation 				= rotations["default"]
newgame.delay_next_map					= false
newgame.error_map						= "error_map"
newgame.update_map_name_on_new_player	= true
--- Public Members:
newgame.current_map = nil				-- the map table currently playing
--- Internal Use:
local autorespawn = false
--- Settings for tfm overriden features:
local simulated_tfm_auto_new_game = true
local simulated_tfm_auto_shaman = true
--- Internal Use:
newgame.current_settings = {}
newgame.current_settings.map_code = nil		-- the code finaly passed to the newGame function
newgame.current_settings.shamans = nil
newgame.current_settings.map_name = nil
newgame.current_settings.map = nil
newgame.current_settings.autoskip = nil
newgame.current_settings.duration = 60
newgame.current_settings.begin_funcs = {}
newgame.current_settings.end_funcs = {}
newgame.current_settings.replace_func = nil
newgame.current_settings.modules = {}			-- list of module names enabled for the map that needs to be disabled
newgame.current_settings.background_color = nil
newgame.current_settings.title = nil
newgame.current_settings.title_color = nil
newgame.current_settings.author = nil
newgame.event_new_game_triggered = false
newgame.next = nil
newgame.force_next = false
newgame.current_rotations_names = {}			-- set rotation names we went by when choosing the map
local newgame_called				= false
local players_alive_changed			= false
local newgame_time = os.time() - 3001
local displayed_map_name = nil						-- used as cache, cf `RefreshMapName()`
--- Finally calls `tfm.exec.newGame`.
-- The purpose is only to know when the original have been called.
-- This will also prevent from loading a map if another is being loaded already.
-- This is an override for local use, the override for other modules is different.
local tfm_exec_newGame = tfm.exec.newGame
local FinallyNewGame = function(mapcode, ...)
newgame_time = os.time()
if newgame_called then
print_warn("newgame: tfm.exec.newGame was called while the game was already loading a new map.")
--return
end
if type(mapcode) == "string" and string.find(mapcode, "<", 1, true) ~= 1 and string.find(mapcode, "#", 1, true) ~= 1 and not tonumber(mapcode) then
print_warn("newgame: invalid rotation `%s`", mapcode)
return
end
newgame_called = true
--print_debug("pshy_newgame: tfm.exec.newGame(%s)", tostring(mapcode))
newgame.current_settings.map_code = mapcode
return tfm_exec_newGame(mapcode, ...)
end
--- Override for `tfm.exec.disableAutoNewGame()`.
local function override_tfm_exec_disableAutoNewGame(disable)
--print_debug("override_tfm_exec_disableAutoNewGame(%s)", tostring(disable))
if disable == nil then
disable = true
end
simulated_tfm_auto_new_game = not disable
end
tfm.exec.disableAutoNewGame(true)
tfm.exec.disableAutoNewGame = override_tfm_exec_disableAutoNewGame
--- Override for `tfm.exec.disableAutoShaman()`.
local function override_tfm_exec_disableAutoShaman(disable)
--print_debug("override_tfm_exec_disableAutoShaman(%s)", tostring(disable))
if disable == nil then
disable = true
end
simulated_tfm_auto_shaman = not disable
end
tfm.exec.disableAutoShaman(false)
local OriginalTFMDisableAutoShaman = tfm.exec.disableAutoShaman
tfm.exec.disableAutoShaman = override_tfm_exec_disableAutoShaman
--- Set the next map.
-- This map will be used on the next call to tfm.exec.newGame().
-- @param code Map code.
-- @param force Should the map be forced (even if another map is chosen).
function newgame.SetNextMap(code, force)
newgame.next = code
newgame.force_next = force or false
end
--- End the previous map.
-- @private
-- @param aborted true if the map have not even been started.
local function EndMap(aborted)
if not aborted then
for i_func, end_func in ipairs(newgame.current_settings.end_funcs) do
end_func(newgame.current_settings.map_name)
end
if eventGameEnded then
eventGameEnded()
end
end
newgame.current_settings.shamans = nil
OriginalTFMDisableAutoShaman(not simulated_tfm_auto_shaman)
newgame.current_settings.map_code = nil
newgame.current_settings.map_name = nil
newgame.current_settings.map = nil
newgame.current_settings.autoskip = nil
newgame.current_settings.duration = nil
newgame.current_settings.begin_funcs = {}
newgame.current_settings.end_funcs = {}
newgame.current_settings.replace_func = nil
newgame.current_settings.background_color = nil
newgame.current_settings.title = nil
newgame.current_settings.title_color = nil
newgame.current_settings.author = nil
newgame.current_rotations_names = {}
for i, module_name in ipairs(newgame.current_settings.modules) do
DisableModule(module_name)
end
newgame.current_settings.modules = {}
-- On every new game:
--for player_name in pairs(tfm.get.room.playerList) do
--tfm.exec.changePlayerSize(player_name, 1.0)
--tfm.exec.giveTransformations(player_name, false)
--tfm.exec.linkMice(player_name, player_name, false) -- TODO: check player.soulmate ?
--end
-- clean tfm.get.room.xmlMapInfo because TFM doesnt
tfm.get.room.xmlMapInfo = nil
end
--- TFM.exec.newGame override.
-- This is the main override.
-- @private
-- @param mapcode Either a map code or a map rotation code.
tfm.exec.newGame = function(mapcode, ...)
if os.time() <= newgame_time + 3000 then
print_error("You must wait 3000 ms before calling `tfm.exec.newGame`.")
return
end
--print_debug("newgame.newGame(%s)", tostring(mapcode))
EndMap()
newgame.event_new_game_triggered = false
return newgame.Next(mapcode, ...)
end
--- Add custom settings to the next map.
-- Some maps or map rotations have special settings.
-- This function handle both of them
local function AddCustomMapSettings(t)
if t.autoskip ~= nil then
newgame.current_settings.autoskip = t.autoskip
end
if t.shamans ~= nil then
assert(t.shamans == 0, "only a shaman count of 0 or nil is supported yet")
newgame.current_settings.shamans = t.shamans
OriginalTFMDisableAutoShaman(true)
end
if t.duration ~= nil then
newgame.current_settings.duration = t.duration
end
if t.begin_func ~= nil then
table.insert(newgame.current_settings.begin_funcs, t.begin_func)
end
if t.end_func ~= nil then
table.insert(newgame.current_settings.end_funcs, t.end_func)
end
if t.replace_func ~= nil then
newgame.current_settings.replace_func = t.replace_func
end
if t.background_color ~= nil then
newgame.current_settings.background_color = t.background_color
end
if t.title ~= nil then
newgame.current_settings.title = t.title
end
if t.title_color ~= nil then
newgame.current_settings.title_color = t.title_color
end
if t.author ~= nil then
newgame.current_settings.author = t.author
end
if t.modules then
for i, module_name in pairs(t.modules) do
table.insert(newgame.current_settings.modules, module_name)
end
end
end
--- newgame.newGame but only for maps listed to this module.
-- @private
local function NextDBMap(map_name)
local map = maps[map_name]
AddCustomMapSettings(map)
newgame.current_settings.map_name = map_name
newgame.current_settings.map = map
ui.setBackgroundColor("#010101") -- @TODO: make this a map setting
local map_xml
if map.xml then
map_xml = map.xml
tfm.get.room.xmlMapInfo = {}
if string.sub(map.xml, 1, 1) == "<" then
tfm.get.room.xmlMapInfo.xml = map.xml
end
tfm.get.room.xmlMapInfo.author = map.author
else
map_xml = map_name
end
if newgame.current_settings.replace_func then
map_xml = newgame.current_settings.replace_func(map.xml)
end
for i, module_name in ipairs(newgame.current_settings.modules) do
EnableModule(module_name)
end
return FinallyNewGame(map_xml)
end
--- newgame.newGame but only for rotations listed to this module.
-- @private
local function NextDBRotation(rotation_name)
if rotation_name == "default" and #newgame.default_rotation.items == nil then
-- empty rotation, just not changing map
return nil
end
local rotation = pshy.mapdb_GetRotation(rotation_name)
rotation_name = rotation.name or rotation_name -- resolving aliases
if newgame.current_rotations_names[rotation_name] then
print_warn("Cyclic map rotation (%s)! Running newGame(error_map)!", rotation_name)
EndMap(true)
return FinallyNewGame(newgame.error_map)
end
newgame.current_rotations_names[rotation_name] = true
AddCustomMapSettings(rotation)
newgame.current_rotation_name = rotation_name
newgame.current_rotation = rotation
local next_map_name = rotation:Next()
return newgame.Next(next_map_name)
end
local function SkipFromRotations(mapcode)
for i, rotation_name in ipairs(newgame.default_rotation.items) do
local rotation = rotations[rotation_name]
if rotation then
rotation:SkipItem(mapcode)
end
end
end
--- Setup the next map (possibly a rotation), calling newGame.
-- @private
function newgame.Next(mapcode)
if mapcode == nil or newgame.force_next then
if newgame.next then
mapcode = newgame.next
if type(mapcode) == "string" and #mapcode < 64 then
SkipFromRotations(mapcode)
end
else
mapcode = newgame.default
end
end
newgame.force_next = false
newgame.next = nil
if maps[mapcode] then
return NextDBMap(mapcode)
end
local mapcode_number = tonumber(mapcode)
if mapcode_number and maps[mapcode_number] then
return NextDBMap(mapcode_number)
end
local next_rotation = pshy.mapdb_GetRotation(mapcode)
if next_rotation then
return NextDBRotation(mapcode)
end
if tonumber(mapcode) then
newgame.current_settings.map_name = mapcode
for i, module_name in ipairs(newgame.current_settings.modules) do
EnableModule(module_name)
end
return FinallyNewGame(mapcode)
end
if string.sub(mapcode, 1, 1) == "<" then
tfm.get.room.xmlMapInfo = {}
tfm.get.room.xmlMapInfo.xml = mapcode
return FinallyNewGame(mapcode)
end
for i, module_name in ipairs(newgame.current_settings.modules) do
EnableModule(module_name)
end
return FinallyNewGame(mapcode)
end
local function RefreshMapName()
displayed_map_name = nil
local author = newgame.current_settings.author or (mapinfo and mapinfo.mapinfo and mapinfo.mapinfo.author)
local title = newgame.current_settings.title or (mapinfo and mapinfo.mapinfo and mapinfo.mapinfo.title) or newgame.current_settings.map_name
if author or title then
local full_map_name = ""
local title_color = newgame.current_settings.title_color or (mapinfo and mapinfo.mapinfo and mapinfo.mapinfo.title_color)
if author then
full_map_name = full_map_name .. author
end
title = title or newgame.current_settings.map_name
if mapinfo and mapinfo.mapinfo and not title then
title = mapinfo.mapinfo.current_map
end
if title then
if author then
full_map_name = full_map_name .. "<bl> - "
end
if title_color then
full_map_name = full_map_name .. string.format('<font color="%s">', title_color)
end
full_map_name = full_map_name .. title
if title_color then
full_map_name = full_map_name .. "</font>"
end
end
displayed_map_name = full_map_name
ui.setMapName(displayed_map_name)
end
end
--- TFM event eventNewGame.
function eventNewGame()
newgame_called = false
newgame.current_map = nil
if not newgame.event_new_game_triggered then
newgame.current_map = newgame.current_settings.map
for i_func, begin_func in ipairs(newgame.current_settings.begin_funcs) do
begin_func(newgame.current_settings.map_name)
end
if newgame.current_settings.duration then
tfm.exec.setGameTime(newgame.current_settings.duration, true)
end
if newgame.current_settings.background_color then
ui.setBackgroundColor(newgame.current_settings.background_color)
end
if mapinfo and mapinfo.mapinfo and mapinfo.mapinfo.background_images and mapinfo.mapinfo.foreground_images then
if perms.IsPlayerNameContentTrusted(mapinfo.mapinfo.publisher) then
for i_img, img in ipairs(mapinfo.mapinfo.background_images) do
tfm.exec.addImage(img.image, "?0", img.x, img.y)
end
for i_img, img in ipairs(mapinfo.mapinfo.foreground_images) do
tfm.exec.addImage(img.image, "!0", img.x, img.y)
end
end
end
RefreshMapName()
else
-- tfm loaded a new map
print_warn("TFM loaded a new game despite the override")
EndMap()
if newgame.current_settings.map then
OriginalTFMDisableAutoShaman(false)
end
end
newgame.event_new_game_triggered = true
players_alive_changed = false
end
--- TFM event eventLoop.
-- Skip the map when the timer is 0.
function eventLoop(time, time_remaining)
if newgame_called then
--print_warn("eventLoop called between newGame() and eventNewGame()")
--return
end
if time_remaining <= 400 and time > 3000 then
if (newgame.current_settings.autoskip ~= false and simulated_tfm_auto_new_game) or newgame.current_settings.autoskip then
--print_debug("changing map because time is low")
tfm.exec.newGame(nil)
end
end
if newgame_called then
return
end
if players_alive_changed then
local players_alive = utils_tfm.CountPlayersAlive()
if players_alive == 0 then
if (newgame.current_settings.autoskip ~= false and simulated_tfm_auto_new_game) or newgame.current_settings.autoskip then
tfm.exec.setGameTime(5, false)
if not newgame.delay_next_map then
--print_debug("changing map because no player remaining, autoskip == %s", tostring(newgame.current_settings.autoskip))
tfm.exec.newGame(nil)
end
end
end
end
end
function eventNewPlayer(player_name)
if newgame.update_map_name_on_new_player then
if newgame.current_settings.background_color then
ui.setBackgroundColor(newgame.current_settings.background_color)
end
if displayed_map_name then
ui.setMapName(displayed_map_name)
end
if mapinfo and mapinfo.mapinfo and mapinfo.mapinfo.background_images and mapinfo.mapinfo.foreground_images then
for i_img, img in ipairs(mapinfo.mapinfo.background_images) do
tfm.exec.addImage(img.image, "?0", img.x, img.y, player_name)
end
for i_img, img in ipairs(mapinfo.mapinfo.foreground_images) do
tfm.exec.addImage(img.image, "!0", img.x, img.y, player_name)
end
end
end
end
function newgame.SetRotation(rotname)
rotname = pshy.mapdb_rotation_aliases[rotname] or rotname -- check for aliases
if rotname and not pshy.mapdb_GetRotation(rotname) then
return false, string.format("Rotation %s does not exist!", rotname)
end
newgame.default_rotation.items = {}
if rotname then
table.insert(newgame.default_rotation.items, rotname)
return true, string.format("Disabled all rotations and enabled %s.", rotname)
end
return true, "Disabled all rotations."
end
--- !next [map]
local function ChatCommandNext(user, code, force)
newgame.SetNextMap(code, force)
return true, string.format("The next map or rotation will be %s.", code)
end
command_list["next"] = {aliases = {"np", "npp"}, perms = "admins", func = ChatCommandNext, desc = "set the next map to play (no param to cancel)", argc_min = 1, argc_max = 2, arg_types = {"string", "bool"}, arg_names = {"map code", "force"}}
help_pages["pshy_newgame"].commands["next"] = command_list["next"]
--- !skip [map]
local function ChatCommandSkip(user, code)
newgame.next = code or newgame.next
newgame.force_next = code ~= nil
if not newgame.next and #newgame.default_rotation.items == 0 then
return false, "First use !rotw to set the rotations you want to use (use !rots for a list)."
end
tfm.exec.setGameTime(0, false)
tfm.exec.newGame(newgame.next)
return true
end
command_list["skip"] = {aliases = {"map"}, perms = "admins", func = ChatCommandSkip, desc = "play a different map right now", argc_min = 0, argc_max = 1, arg_types = {"string"}, arg_names = {"map code"}}
help_pages["pshy_newgame"].commands["skip"] = command_list["skip"]
--- !repeat
local function ChatCommandRepeat(user)
map = newgame.current_settings.map_name
if not map then
return false, "Something wrong happened."
end
return ChatCommandSkip(user, newgame.current_settings.map_name or (mapinfo and mapinfo.mapinfo.arg1))
end
command_list["repeat"] = {aliases = {"r", "replay"}, perms = "admins", func = ChatCommandRepeat, desc = "repeat the last map", argc_min = 0, argc_max = 0}
help_pages["pshy_newgame"].commands["repeat"] = command_list["repeat"]
--- !rotations
local function ChatCommandRotations(user)
tfm.exec.chatMessage("Available rotations:", user)
local keys = utils_tables.SortedKeys(rotations)
for i_rot, rot_name in pairs(keys) do
local rot = pshy.mapdb_GetRotation(rot_name)
if rot ~= newgame.default_rotation then
local count = utils_tables.CountValue(newgame.default_rotation.items, rot_name)
local s = ((count > 0) and "<vp>" or "<fc>")
s = s .. ((count > 0) and ("<b> ⚖ " .. tostring(count) .. "</b> \t") or "  - \t\t") .. rot_name
s = s .. ((count > 0) and "</vp>" or "</fc>")
s = s ..  ": " .. tostring(rot.desc) .. " (" .. #rot.items .. "#)"
tfm.exec.chatMessage(s, user)
end
end
return true
end
command_list["rotations"] = {aliases = {"rots"}, perms = "admins", func = ChatCommandRotations, desc = "list available rotations", argc_min = 0, argc_max = 0}
help_pages["pshy_newgame"].commands["rotations"] = command_list["rotations"]
--- !rotationweigth <name> <value>
local function ChatCommandRotw(user, rotname, w)
rotname = pshy.mapdb_rotation_aliases[rotname] or rotname -- check for aliases
if not pshy.mapdb_GetRotation(rotname) then
return false, "Unknown rotation."
end
if rotname == "default" then
return false, "It's not rotationception."
end
if w == nil then
w = (utils_tables.CountValue(newgame.default_rotation.items, rotname) ~= 0) and 0 or 1
end
if w < 0 then
return false, "Use 0 to disable the rotation."
end
if w > 100 then
return false, "The maximum weight is 100."
end
pshy.ListRemoveValue(newgame.default_rotation.items, rotname)
if w > 0 then
for i = 1, w do
table.insert(newgame.default_rotation.items, rotname)
end
end
newgame.default_rotation:Reset()
return true, "Changed a map frequency."
end
command_list["rotationweigth"] = {aliases = {"rotw"}, perms = "admins", func = ChatCommandRotw, desc = "set how often a rotation is to be played", argc_min = 1, argc_max = 2, arg_types = {"string", "number"}, arg_names = {"rotation", "amount"}}
help_pages["pshy_newgame"].commands["rotationweigth"] = command_list["rotationweigth"]
--- !rotationclean [rotation]
local function ChatCommandRotc(user, rotname)
return newgame.SetRotation(rotname)
end
command_list["rotationclean"] = {aliases = {"rotc"}, perms = "admins", func = ChatCommandRotc, desc = "clear all rotations, and optionaly set a new one", argc_min = 0, argc_max = 1, arg_types = {"string"}, arg_names = {"new rotation"}}
help_pages["pshy_newgame"].commands["rotationclean"] = command_list["rotationclean"]
newgame.ChatCommandRotc = ChatCommandRotc -- @deprecated
--- !autorespawn <on/off>
local function ChatCommandAutorespawn(user, enabled)
autorespawn = enabled
return true, string.format("Automatic respawn is now %s.", (autorespawn and "enabled" or "disabled"))
end
command_list["autorespawn"] = {perms = "admins", func = ChatCommandAutorespawn, desc = "enable or disable automatic respawn", argc_min = 0, argc_max = 1, arg_types = {"boolean"}, arg_names = {"on/off"}}
help_pages["pshy_newgame"].commands["autorespawn"] = command_list["autorespawn"]
function eventPlayerDied(player_name)
if autorespawn then
tfm.exec.respawnPlayer(player_name)
return
end
players_alive_changed = true
tfm.get.room.playerList[player_name].isDead = true
end
function eventPlayerWon(player_name)
players_alive_changed = true
tfm.get.room.playerList[player_name].isDead = true
end
function eventInit()
for i_rot, rot in pairs(rotations) do
-- @TODO use a custom compare function
--if rot.unique_items then
--	table.sort(rot.items)
--	pshy.SortedListRemoveDuplicates(rot.items)
--end
end
end
return newgame
end
pshy.modules["pshy.tools.fcplatform"].load = function()
--- pshy.tools.fcplatform
--
-- This module add a command to spawn an orange plateform and tp on it.
--
-- @author TFM: Pshy#3752
local command_list = pshy.require("pshy.commands.list")
pshy.require("pshy.events")
local help_pages = pshy.require("pshy.help.pages")
--- Namespace.
local fcplatform = {}
--- Platform Settings.
fcplatform.x = -100
fcplatform.y = 100
fcplatform.w = 60
fcplatform.h = 10
fcplatform.friction = 0.4
fcplatform.members = {}		-- set of players to always tp on the platform
fcplatform.jail = {}		-- set of players to always tp on the platform, event when they escape ;>
fcplatform.pilots = {}		-- set of players who pilot the platform
fcplatform.autospawn = false
fcplatform.color = 0xff7000
--- Internal use:
fcplatform.spawned = false
--- Get the target of the command, throwing on permission issue.
local GetTarget = pshy.require("pshy.commands.get_target_or_error")
--- Module Help Page.
help_pages["pshy_fcplatform"] = {back = "pshy", title = "FC Platform",text = "Adds a platform you can teleport on to spectate.\nThe players on the platform move with it.\n"}
help_pages["pshy_fcplatform"].commands = {}
help_pages["pshy"].subpages["pshy_fcplatform"] = help_pages["pshy_fcplatform"]
--- Get a set of players on the platform.
local function GetPlayersOnFcplatform()
if not fcplatform.spawned then
return {}
end
local ons = {}
for player_name, player in pairs(tfm.get.room.playerList) do
if player.y < fcplatform.y - fcplatform.h / 2 and player.y > fcplatform.y - fcplatform.h / 2 - 60 and player.x > fcplatform.x - fcplatform.w / 2 and player.x < fcplatform.x + fcplatform.w / 2 then
ons[player_name] = true
end
end
return ons
end
--- !fcplatform [x] [y]
-- Create a funcorp plateform and tp on it
local function ChatCommandFcplatform(user, x, y)
local ons = GetPlayersOnFcplatform() -- set of players on the platform
local offset_x = 0
local offset_y = 0
if x then
offset_x = x - fcplatform.x
fcplatform.x = x
end
if y then
offset_y = y - fcplatform.y
fcplatform.y = y
end
if fcplatform.x and fcplatform.y then
tfm.exec.addPhysicObject(199, fcplatform.x, fcplatform.y, {type = 12, width = fcplatform.w, height = fcplatform.h, foreground = false, friction = fcplatform.friction, restitution = 0.0, angle = 0, color = fcplatform.color, miceCollision = true, groundCollision = false})
fcplatform.spawned = true
for player_name, void in pairs(ons) do
tfm.exec.movePlayer(player_name, offset_x, offset_y, true, 0, 0, true)
end
for player_name, void in pairs(fcplatform.members) do
if not ons[player_name] or user == nil then
tfm.exec.movePlayer(player_name, fcplatform.x, fcplatform.y - 20, false, 0, 0, false)
end
end
end
end
command_list["fcplatform"] = {aliases = {"fcp"}, perms = "admins", func = ChatCommandFcplatform, desc = "Create a funcorp plateform.", argc_min = 0, argc_max = 2, arg_types = {'number', 'number'}}
command_list["fcplatform"].help = "Create a platform at given coordinates, or recreate the previous platform. Accept variables as arguments.\n"
help_pages["pshy_fcplatform"].commands["fcplatform"] = command_list["fcplatform"]
--- !fcplatformpilot [player_name]
local function ChatCommandFcpplatformpilot(user, target)
target = target or user
if not fcplatform.pilots[target] then
system.bindMouse(target, true)
fcplatform.pilots[target] = true
return true, string.format("%s is now the platform's pilot!", target)
else
fcplatform.pilots[target] = nil
return true, string.format("%s is no longer the platform's pilot.", target)
end
end
command_list["fcplatformpilot"] = {aliases = {"fcpp"}, perms = "admins", func = ChatCommandFcpplatformpilot, desc = "Set yourself or a player as a fcplatform pilot.", argc_min = 0, argc_max = 1, arg_types = {'string'}}
help_pages["pshy_fcplatform"].commands["fcplatformpilot"] = command_list["fcplatformpilot"]
--- !fcplatformjoin [player_name]
-- Jail yourself on the fcplatform.
local function ChatCommandFcpplatformjoin(user, join, target)
local target = GetTarget(user, target, "!fcplatformjoin")
local target = target or user
join = join or not fcplatform.jail[target]
if fcplatform.jail[target] ~= fcplatform.members[target] then
return false, "You didnt join the platform by yourself ;>"
end
if join then
if not fcplatform.autospawn then
return false, "The fcplatform needs to be spawned by room admins for you to join it."
end
fcplatform.jail[target] = true
fcplatform.members[target] = true
tfm.exec.removeCheese(target)
return true, "Platform joined!"
else
fcplatform.jail[target] = nil
fcplatform.members[target] = nil
tfm.exec.killPlayer(user)
return true, "Platform left!"
end
end
command_list["fcplatformjoin"] = {aliases = {"fcpj", "fcpjoin"}, perms = "admins", func = ChatCommandFcpplatformjoin, desc = "Join or leave the fcplatform.", argc_min = 0, argc_max = 2, arg_types = {'bool', 'player'}}
help_pages["pshy_fcplatform"].commands["fcplatformjoin"] = command_list["fcplatformjoin"]
--- !fcplatformautospawn [enabled]
local function ChatCommandFcplatformautospawn(user, enabled)
if enabled == nil then
enabled = not fcplatform.autospawn
end
fcplatform.autospawn = enabled
if enabled then
return true, "The platform will now respawn between games."
else
return true, "The platform will no longer respawn between games."
end
end
command_list["fcplatformautospawn"] = {aliases = {"fcpautospawn"}, perms = "admins", func = ChatCommandFcplatformautospawn, desc = "Enable or disable the platform from respawning between games.", argc_min = 0, argc_max = 1, arg_types = {'bool'}}
help_pages["pshy_fcplatform"].commands["fcplatformautospawn"] = command_list["fcplatformautospawn"]
--- !fcplatformcolor [color]
local function ChatCommandFcplatformcolor(user, color)
fcplatform.color = color
if fcplatform.spawned then
return ChatCommandFcplatform(nil)
else
return true, "The platform's color will have changed the next time you spawn it."
end
end
command_list["fcplatformcolor"] = {aliases = {"fcpcolor"}, perms = "admins", func = ChatCommandFcplatformcolor, desc = "Set the platform's color.", argc_min = 1, argc_max = 1, arg_types = {'color'}}
help_pages["pshy_fcplatform"].commands["fcplatformcolor"] = command_list["fcplatformcolor"]
--- !fcplatformsize [color]
local function ChatCommandFcplatformsize(user, width, height)
height = height or fcplatform.h
fcplatform.w = width
fcplatform.h = height
if fcplatform.spawned then
return ChatCommandFcplatform(nil)
else
return true, "The platform's size will have changed the next time you spawn it."
end
end
command_list["fcplatformsize"] = {aliases = {"fcpsize"}, perms = "admins", func = ChatCommandFcplatformsize, desc = "Set the platform's size.", argc_min = 1, argc_max = 2, arg_types = {'number', 'number'}}
help_pages["pshy_fcplatform"].commands["fcplatformsize"] = command_list["fcplatformsize"]
--- TFM event eventNewgame
function eventNewGame()
fcplatform.spawned = false
if fcplatform.autospawn then
ChatCommandFcplatform(nil)
for player_name in pairs(fcplatform.jail) do
local tfm_player = tfm.get.room.playerList[player_name]
if tfm_player then
tfm.exec.movePlayer(player_name, tfm_player.x, tfm_player.y, false, 0, 0, true)
end
end
end
end
--- TFM event eventLoop
function eventLoop(currentTime, timeRemaining)
for player_name, void in pairs(fcplatform.jail) do
player = tfm.get.room.playerList[player_name]
if player then
if player.y < fcplatform.y and player.y > fcplatform.y - 60 and player.x > fcplatform.x - fcplatform.w / 2 and player.x < fcplatform.x + fcplatform.w / 2 then
-- on already
else
tfm.exec.movePlayer(player_name, fcplatform.x, fcplatform.y - 20, false, 0, 0, false)
end
end
end
end
--- TFM event eventMouse
function eventMouse(playerName, xMousePosition, yMousePosition)
if fcplatform.pilots[playerName] then
ChatCommandFcplatform(playerName, xMousePosition, yMousePosition)
end
end
return fcplatform
end
pshy.modules["pshy.tools.motd"].load = function()
--- pshy.tools.motd
--
-- Add announcement features.
--
--	!setmotd <join_message>		- Set a message for joining players.
--	!motd						- See the current motd.
--	!announce <message>			- Send an orange message.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
local command_list = pshy.require("pshy.commands.list")
pshy.require("pshy.events")
local help_pages = pshy.require("pshy.help.pages")
--- Namespace.
local motd = {}
--- Module settings:
motd.message = nil		-- The message to display to joining players.
motd.every = -1			-- Every how many chat messages to display the motd.
--- Module Help Page:
help_pages["pshy_motd"] = {back = "pshy", title = "Announcements", text = "This module adds announcement features.\nThis include a MOTD displayed to joining players.\n", examples = {}}
help_pages["pshy_motd"].commands = {}
help_pages["pshy"].subpages["pshy_motd"] = help_pages["pshy_motd"]
--- Internal use.
local message_count_since_motd = 0
--- !setmotd <join_message>
-- Set the motd (or html).
local function ChatCommandSetmotd(user, message)
if string.sub(message, 1, 1) == "&" then
motd.message = string.gsub(string.gsub(message, "&lt;", "<"), "&gt;", ">")
else
motd.message = "<fc>" .. message .. "</fc>"
end
return ChatCommandMotd(user)
end
command_list["setmotd"] = {perms = "admins", func = ChatCommandSetmotd, desc = "Set the motd (support html).", argc_min = 1, argc_max = 1, arg_types = {"string"}}
command_list["setmotd"].help = "You may also use html /!\\ BUT CLOSE MARKUPS!\n"
help_pages["pshy_motd"].commands["setmotd"] = command_list["setmotd"]
--- !motd
-- See the current motd.
local function ChatCommandMotd(user)
if motd.message then
return true, string.format("Current motd:\n%s", motd.message)
else
return false, "No MOTD set. Use `!setmotd <motd>` to set one."
end
end
command_list["motd"] = {perms = "everyone", func = ChatCommandMotd, desc = "See the current motd.", argc_min = 0, argc_max = 0, arg_types = {}}
help_pages["pshy_motd"].commands["motd"] = command_list["motd"]
--- !announce <message>
-- Send an orange message (or html).
local function ChatCommandAnnounce(player_name, message)
if string.sub(message, 1, 1) == "&" then
tfm.exec.chatMessage(string.gsub(string.gsub(message, "&lt;", "<"), "&gt;", ">"), nil)
else
tfm.exec.chatMessage("<fc>" .. message .. "</fc>", nil)
end
-- <r><bv><bl><j><vp>
return true
end
command_list["announce"] = {perms = "admins", func = ChatCommandAnnounce, desc = "Send an orange message in the chat (support html).", argc_min = 1, argc_max = 1, arg_types = {"string"}}
command_list["announce"].help = "You may also use html /!\\ BUT CLOSE MARKUPS!\n"
help_pages["pshy_motd"].commands["announce"] = command_list["announce"]
--- TFM event eventNewPlayer
function eventNewPlayer(player_name)
if motd.message then
tfm.exec.chatMessage(motd.message, player_name)
end
end
--- TFM event eventChatMessage
function eventChatMessage(player_name, message)
if motd.message and motd.every > 0 then
message_count_since_motd = message_count_since_motd + 1
if message_count_since_motd >= motd.every then
tfm.exec.chatMessage(motd.message, nil)
message_count_since_motd = 0
end
end
end
return motd
end
pshy.modules["pshy.games.pacmice"].load = function()
local __IS_MAIN_MODULE__ = true
--- pshy.games.pacmice
--
-- Pacmouse: -sees mice- "Nom nom nom!".
--
-- To create a new map:
--	- Add the map to the rotation, in the settings with `pathes` being `{{0, 0}}`.
--	- Play the map.
--	- Use `!set pacmice_cur_pilot YourName#3752`.
--	- Click on a free cell, then use arrows to travel the entire map, every possible path.
--	- Use `!call pacmice_GridExportPathes YourName#3752`.
--	- Copy the output, remove the new lines, and add this as the `pathes` field.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998 (script)
-- @author TFM:Nnaaaz#0000 (maps)
pshy.require("pshy.alternatives.chat")
local alternative_timers = pshy.require("pshy.alternatives.timers")
pshy.require("pshy.anticheats.ban")
pshy.require("pshy.anticheats.loadersync")
local loopmore = pshy.require("pshy.bases.loopmore")
local scores = pshy.require("pshy.bases.scores")
local splashscreen = pshy.require("pshy.bases.splashscreen")
pshy.require("pshy.bases.version")
local bonuses = pshy.require("pshy.bonuses")
local bonus_types = pshy.require("pshy.bonuses.list")
pshy.require("pshy.bonuses.list.mario")
pshy.require("pshy.commands")
local command_list = pshy.require("pshy.commands.list")
pshy.require("pshy.commands.list.modules")
local help_pages = pshy.require("pshy.help.pages")
local keycodes = pshy.require("pshy.enums.keycodes")
pshy.require("pshy.events")
pshy.require("pshy.help")
pshy.require("pshy.images.changeimage")
pshy.require("pshy.rotations.newgame")
pshy.require("pshy.tools.fcplatform")
pshy.require("pshy.tools.motd")
local Rotation = pshy.require("pshy.utils.rotation")
local utils_tfm = pshy.require("pshy.utils.tfm")
local maps = pshy.require("pshy.maps.list")
local perms = pshy.require("pshy.perms")
local rotations = pshy.require("pshy.rotations.list")
local room = pshy.require("pshy.room")
--- help Page:
help_pages[""] = {back = "", title = "PacMice", details = "<r>Run away</r> from the <j>pacmouse</j>!\n\nEvery <ch2>food</ch2> item earns you <ch>2 points</ch>.\n<ch2>Entering the hole</ch2> earns you <ch>16 points</ch>.\nIf you dont enter the hole but <ch2>survive</ch2>, you earn <ch>10 points</ch>.\nThe player with the highest score becomes the next <j>pacmouse</j>.\n"}
help_pages["pacmice"] = {back = "", title = "PacMice Commands", text = "", commands = {}}
--- TFM Settings
tfm.exec.disableAutoNewGame(true)
tfm.exec.disableAutoShaman(true)
tfm.exec.disableAfkDeath(true)
tfm.exec.disableAutoTimeLeft(true)
system.disableChatCommandDisplay(nil, true)
--- Pshy Settings:
perms.auto_admin_authors = true
perms.authors[70224600] = "Nnaaaz#0000"
perms.authors[105766424] = "Pshy#3752"
splashscreen.image = "17acb076edb.png"	-- splash image
splashscreen.x = 150					-- x location
splashscreen.y = 100					-- y location
splashscreen.sx = 1					-- scale on x
splashscreen.sy = 1					-- scale on y
splashscreen.text = nil
splashscreen.duration = 8 * 1000		-- pacmice screen duration
pacmice_arbitrary_help_btn_id = 7
local killer_ground_1 = 121
local killer_ground_2 = 122
--- Replace the map's colors.
function pacmice_GetMap(mapname)
pacmice_map = pacmice_maps[mapname]
local xml = pacmice_map.axml
pacmice_map_color_index = (pacmice_map_color_index % #pacmice_map_colors) + 1
return string.gsub(xml, "1500fb", pacmice_map_colors[pacmice_map_color_index])
end
--- Module Settings:
pacmice_maps = {}						-- game maps tables
-- map 1 (original)
pacmice_maps["pacmice_1"] = {xml = "pacmice_1", background_color = "#010101", x = 91, y = 29, cell_w = 26, cell_h = 26, wall_size = 14, web_x = -100, pac_count = 1, axml = [[<C><P H="720" DS="m;170,165,610,165" MEDATA=";;;;-0;0::0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160:1-"/><Z><S><S T="12" X="168" Y="107" L="56" H="56" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="613" Y="107" L="56" H="56" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="286" Y="107" L="79" H="56" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="495" Y="107" L="79" H="56" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="247" Y="263" L="10" H="160" P="0,0,0.5,0.2,0,0,0,0"/><S T="12" X="533" Y="263" L="10" H="160" P="0,0,0.5,0.2,0,0,0,0"/><S T="12" X="390" Y="29" L="605" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="91" Y="130" L="10" H="210" P="0,0,0.5,0.2,0,0,0,0"/><S T="12" X="690" Y="130" L="10" H="210" P="0,0,0.5,0.2,0,0,0,0"/><S T="12" X="141" Y="237" L="110" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="641" Y="237" L="108" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="196" Y="276" L="10" H="87" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="586" Y="277" L="10" H="88" P="0,0,0.5,0.2,0,0,0,0"/><S T="12" X="143" Y="316" L="113" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="636" Y="316" L="101" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="91" Y="343" L="10" H="60" P="0,0,0.5,0.2,0,0,0,0"/><S T="12" X="689" Y="342" L="10" H="62" P="0,0,0.5,0.2,0,0,0,0"/><S T="12" X="145" Y="368" L="111" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="635" Y="368" L="100" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="196" Y="408" L="10" H="83" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="586" Y="406" L="10" H="87" P="0,0,0.5,0.2,0,0,0,0"/><S T="12" X="145" Y="445" L="105" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="638" Y="445" L="105" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="90" Y="575" L="10" H="270" P="0,0,0.5,0.2,0,0,0,0"/><S T="12" X="690" Y="575" L="10" H="270" P="0,0,0.5,0.2,0,0,0,0"/><S T="12" X="390" Y="706" L="608" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="390" Y="82" L="32" H="108" P="0,0,0.5,0.2,0,0,0,0"/><S T="12" X="392" Y="186" L="180" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="391" Y="445" L="176" H="10" P="0,0,0.3,0.2,360,0,0,0"/><S T="12" X="389" Y="550" L="177" H="10" P="0,0,0.3,0.2,360,0,0,0"/><S T="12" X="234" Y="655" L="185" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="547" Y="655" L="184" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="170" Y="186" L="50" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="612" Y="186" L="50" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="390" Y="214" L="32" H="56" P="0,0,0.5,0.2,0,0,0,0"/><S T="12" X="390" Y="476" L="32" H="55" P="0,0,0.5,0.2,360,0,0,0"/><S T="12" X="390" Y="603" L="32" H="103" P="0,0,0.5,0.2,360,0,0,0"/><S T="12" X="172" Y="498" L="55" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="609" Y="498" L="55" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="195" Y="549" L="10" H="107" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="586" Y="549" L="10" H="107" P="0,0,0.5,0.2,0,0,0,0"/><S T="12" X="286" Y="498" L="73" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="495" Y="498" L="75" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="247" Y="420" L="10" H="55" P="0,0,0.5,0.2,0,0,0,0"/><S T="12" X="533" Y="420" L="10" H="56" P="0,0,0.5,0.2,0,0,0,0"/><S T="12" X="248" Y="600" L="10" H="100" P="0,0,0.5,0.2,0,0,0,0"/><S T="12" X="533" Y="600" L="10" H="99" P="0,0,0.5,0.2,0,0,0,0"/><S T="12" X="289" Y="238" L="75" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="493" Y="238" L="75" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="118" Y="576" L="52" H="54" P="0,0,0.5,0.2,0,0,0,0"/><S T="12" X="663" Y="576" L="52" H="54" P="0,0,0.5,0.2,0,0,0,0"/><S T="12" X="391" Y="393" L="190" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="480" Y="300" L="10" H="22" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="301" Y="300" L="10" H="22" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="480" Y="387" L="10" H="22" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="301" Y="387" L="10" H="22" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="325" Y="292" L="60" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="455" Y="292" L="60" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="312" Y="602" L="30" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="469" Y="602" L="30" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="390" Y="292" L="67" H="10" P="0,0,0.3,0.2,0,0,0,0" v="90000"/><S T="12" X="480" Y="342" L="67" H="10" P="0,0,0.3,0.2,90,0,0,0" v="90000"/><S T="12" X="301" Y="342" L="67" H="10" P="0,0,0.3,0.2,90,0,0,0" v="90000"/><S T="12" X="387" Y="724" L="10" H="10" P="1,0,0.3,0.2,0,1,Infinity,0" c="4" v="90000"/><S T="12" X="427" Y="724" L="10" H="10" P="1,0,0.3,0.2,0,1,Infinity,0" c="4" v="89000"/><S T="12" X="467" Y="724" L="10" H="10" P="1,0,0.3,0.2,0,1,Infinity,0" c="4" v="88000"/><S T="12" X="507" Y="724" L="10" H="10" P="1,0,0.3,0.2,0,1,Infinity,0" c="4" v="87000"/><S T="12" X="547" Y="724" L="10" H="10" P="1,0,0.3,0.2,0,1,Infinity,0" c="4" v="86000"/><S T="12" X="587" Y="724" L="10" H="10" P="1,0,0.3,0.2,0,1,Infinity,0" c="4" v="85000"/></S><D><F X="335" Y="379" D=""/><F X="445" Y="379" D=""/><T X="392" Y="387" D=""/></D><O/><L><JD c="1500fb,10,1,0" P1="91,29" P2="690,29"/><JD c="1500fb,10,1,0" P1="91,706" P2="690,706"/><JD c="1500fb,10,1,0" P1="91,30" P2="91,236"/><JD c="1500fb,10,1,0" P1="690,30" P2="690,236"/><JD c="1500fb,10,1,0" P1="91,446" P2="91,704"/><JD c="1500fb,10,1,0" P1="690,446" P2="690,704"/><JD c="1500fb,10,1,0" P1="91,237" P2="195,237"/><JD c="1500fb,10,1,0" P1="690,237" P2="586,237"/><JD c="1500fb,10,1,0" P1="149,186" P2="191,186"/><JD c="1500fb,10,1,0" P1="632,186" P2="590,186"/><JD c="1500fb,10,1,0" P1="301,292" P2="352,292"/><JD c="FFFFFF,10,1,0" M1="63" M2="63" P1="362,292" P2="418,292"/><JD c="FFFFFF,10,1,0" M1="63" M2="63" P1="480,316" P2="480,372"/><JD c="FFFFFF,10,1,0" M1="63" M2="63" P1="301,316" P2="301,372"/><JD c="1500fb,10,1,0" M1="64" M2="64" P1="362,292" P2="418,292"/><JD c="1500fb,10,1,0" M1="64" M2="64" P1="480,316" P2="480,372"/><JD c="1500fb,10,1,0" M1="64" M2="64" P1="301,316" P2="301,372"/><JD c="FFFFFF,10,1,0" M1="65" M2="65" P1="362,292" P2="418,292"/><JD c="FFFFFF,10,1,0" M1="65" M2="65" P1="480,316" P2="480,372"/><JD c="FFFFFF,10,1,0" M1="65" M2="65" P1="301,316" P2="301,372"/><JD c="1500fb,10,1,0" M1="66" M2="66" P1="362,292" P2="418,292"/><JD c="1500fb,10,1,0" M1="66" M2="66" P1="480,316" P2="480,372"/><JD c="1500fb,10,1,0" M1="66" M2="66" P1="301,316" P2="301,372"/><JD c="FFFFFF,10,1,0" M1="67" M2="67" P1="362,292" P2="418,292"/><JD c="FFFFFF,10,1,0" M1="67" M2="67" P1="480,316" P2="480,372"/><JD c="FFFFFF,10,1,0" M1="67" M2="67" P1="301,316" P2="301,372"/><JD c="1500fb,10,1,0" M1="68" M2="68" P1="362,292" P2="418,292"/><JD c="1500fb,10,1,0" M1="68" M2="68" P1="480,316" P2="480,372"/><JD c="1500fb,10,1,0" M1="68" M2="68" P1="301,316" P2="301,372"/><JD c="1500fb,10,1,0" P1="480,292" P2="429,292"/><JD c="1500fb,10,1,0" P1="249,238" P2="322,238"/><JD c="1500fb,10,1,0" P1="532,238" P2="459,238"/><JD c="1500fb,10,1,0" P1="92,316" P2="195,316"/><JD c="1500fb,10,1,0" P1="689,316" P2="586,316"/><JD c="1500fb,10,1,0" P1="92,368" P2="195,368"/><JD c="1500fb,10,1,0" P1="689,368" P2="586,368"/><JD c="1500fb,10,1,0" P1="91,445" P2="195,445"/><JD c="1500fb,10,1,0" P1="690,445" P2="586,445"/><JD c="1500fb,10,1,0" P1="307,445" P2="476,445"/><JD c="1500fb,10,1,0" P1="302,393" P2="479,393"/><JD c="1500fb,10,1,0" P1="307,186" P2="478,186"/><JD c="1500fb,10,1,0" P1="305,550" P2="474,550"/><JD c="1500fb,10,1,0" P1="145,655" P2="323,655"/><JD c="1500fb,10,1,0" P1="636,655" P2="458,655"/><JD c="000000,6,1,0" P1="91,30" P2="91,236"/><JD c="000000,6,1,0" P1="690,30" P2="690,236"/><JD c="000000,6,1,0" P1="91,706" P2="690,706"/><JD c="1500fb,10,1,0" P1="148,498" P2="195,498"/><JD c="1500fb,10,1,0" P1="633,498" P2="586,498"/><JD c="1500fb,10,1,0" P1="254,498" P2="318,498"/><JD c="1500fb,10,1,0" P1="527,498" P2="463,498"/><JD c="1500fb,10,1,0" P1="301,602" P2="322,602"/><JD c="1500fb,10,1,0" P1="480,602" P2="459,602"/><JD c="1500fb,10,1,0" P1="195.5,237.5" P2="195.5,315.5"/><JD c="1500fb,10,1,0" P1="585.5,237.5" P2="585.5,315.5"/><JD c="1500fb,10,1,0" P1="480,294" P2="480,306"/><JD c="1500fb,10,1,0" P1="301,294" P2="301,306"/><JD c="1500fb,10,1,0" P1="480,381" P2="480,393"/><JD c="1500fb,10,1,0" P1="301,381" P2="301,393"/><JD c="1500fb,10,1,0" P1="247.5,186.5" P2="247.5,338.5"/><JD c="1500fb,10,1,0" P1="533.5,186.5" P2="533.5,338.5"/><JD c="1500fb,10,1,0" P1="195.5,368" P2="195.5,445"/><JD c="1500fb,10,1,0" P1="585.5,368" P2="585.5,445"/><JD c="000000,6,1,0" P1="91,446" P2="91,704"/><JD c="000000,6,1,0" P1="690,446" P2="690,704"/><JD c="1500fb,10,1,0" P1="247.5,397" P2="247.5,443"/><JD c="1500fb,10,1,0" P1="533.5,397" P2="533.5,443"/><JD c="1500fb,10,1,0" P1="195.5,498" P2="195.5,600"/><JD c="1500fb,10,1,0" P1="585.5,498" P2="585.5,600"/><JD c="1500fb,10,1,0" P1="247.5,553" P2="247.5,655"/><JD c="1500fb,10,1,0" P1="533.5,553" P2="533.5,655"/><JD c="1500fb,10,1,0" P1="91.5,316" P2="91.5,367"/><JD c="1500fb,10,1,0" P1="689.5,316" P2="689.5,367"/><JD c="000000,6,1,0" P1="91,237" P2="195,237"/><JD c="000000,6,1,0" P1="690,237" P2="586,237"/><JD c="000000,6,1,0" P1="149,186" P2="191,186"/><JD c="000000,6,1,0" P1="632,186" P2="590,186"/><JD c="000000,6,1,0" P1="301,292" P2="352,292"/><JD c="000000,6,1,0" M1="63" M2="63" P1="362,292" P2="418,292"/><JD c="000000,6,1,0" M1="63" M2="63" P1="480,316" P2="480,372"/><JD c="000000,6,1,0" M1="63" M2="63" P1="301,316" P2="301,372"/><JD c="000000,6,1,0" P1="480,292" P2="429,292"/><JD c="000000,6,1,0" P1="249,238" P2="322,238"/><JD c="000000,6,1,0" P1="532,238" P2="459,238"/><JD c="000000,6,1,0" P1="92,316" P2="195,316"/><JD c="000000,6,1,0" P1="689,316" P2="586,316"/><JD c="000000,6,1,0" P1="92,368" P2="195,368"/><JD c="000000,6,1,0" P1="689,368" P2="586,368"/><JD c="000000,6,1,0" P1="91,445" P2="195,445"/><JD c="000000,6,1,0" P1="690,445" P2="586,445"/><JD c="000000,6,1,0" P1="307,445" P2="476,445"/><JD c="000000,6,1,0" P1="302,393" P2="479,393"/><JD c="000000,6,1,0" P1="145,655" P2="323,655"/><JD c="000000,6,1,0" P1="636,655" P2="458,655"/><JD c="000000,6,1,0" P1="148,498" P2="195,498"/><JD c="000000,6,1,0" P1="633,498" P2="586,498"/><JD c="000000,6,1,0" P1="254,498" P2="318,498"/><JD c="000000,6,1,0" P1="527,498" P2="463,498"/><JD c="000000,6,1,0" P1="301,602" P2="322,602"/><JD c="000000,6,1,0" P1="480,602" P2="459,602"/><JD c="000000,6,1,0" P1="195.5,237.5" P2="195.5,315.5"/><JD c="000000,6,1,0" P1="585.5,237.5" P2="585.5,315.5"/><JD c="000000,6,1,0" P1="480,294" P2="480,306"/><JD c="000000,6,1,0" P1="301,294" P2="301,306"/><JD c="000000,6,1,0" P1="480,381" P2="480,393"/><JD c="000000,6,1,0" P1="301,381" P2="301,393"/><JD c="000000,6,1,0" P1="247.5,186.5" P2="247.5,338.5"/><JD c="000000,6,1,0" P1="533.5,186.5" P2="533.5,338.5"/><JD c="000000,6,1,0" P1="195.5,368" P2="195.5,445"/><JD c="000000,6,1,0" P1="585.5,368" P2="585.5,445"/><JD c="000000,6,1,0" P1="247.5,397" P2="247.5,443"/><JD c="000000,6,1,0" P1="533.5,397" P2="533.5,443"/><JD c="000000,6,1,0" P1="195.5,498" P2="195.5,600"/><JD c="000000,6,1,0" P1="585.5,498" P2="585.5,600"/><JD c="000000,6,1,0" P1="247.5,553" P2="247.5,655"/><JD c="000000,6,1,0" P1="533.5,553" P2="533.5,655"/><JD c="000000,6,1,0" P1="91.5,316" P2="91.5,367"/><JD c="000000,6,1,0" P1="689.5,316" P2="689.5,367"/><JD c="1500fb,3,1,0" P1="141,80" P2="195,80"/><JD c="1500fb,3,1,0" P1="640,80" P2="586,80"/><JD c="1500fb,3,1,0" P1="248,80" P2="324,80"/><JD c="1500fb,3,1,0" P1="533,80" P2="457,80"/><JD c="1500fb,3,1,0" P1="195,81" P2="195,134"/><JD c="1500fb,3,1,0" P1="586,81" P2="586,134"/><JD c="1500fb,3,1,0" P1="324,81" P2="324,134"/><JD c="1500fb,3,1,0" P1="375,33" P2="375,134"/><JD c="1500fb,3,1,0" P1="375,189" P2="375,240"/><JD c="1500fb,3,1,0" P1="375,450" P2="375,502"/><JD c="1500fb,3,1,0" P1="375,553" P2="375,653"/><JD c="1500fb,3,1,0" P1="405,33" P2="405,134"/><JD c="1500fb,3,1,0" P1="405,189" P2="405,240"/><JD c="1500fb,3,1,0" P1="404.88,450" P2="404.88,502"/><JD c="1500fb,3,1,0" P1="405,553" P2="405,653"/><JD c="1500fb,3,1,0" P1="457,81" P2="457,134"/><JD c="1500fb,3,1,0" P1="141,81" P2="141,134"/><JD c="1500fb,3,1,0" P1="640,81" P2="640,134"/><JD c="1500fb,3,1,0" P1="248,81" P2="248,134"/><JD c="000000,6,1,0" P1="307,186" P2="478,186"/><JD c="1500fb,3,1,0" P1="533,81" P2="533,134"/><JD c="1500fb,3,1,0" P1="141,134" P2="195,134"/><JD c="1500fb,3,1,0" P1="640,134" P2="586,134"/><JD c="1500fb,3,1,0" P1="248,134.5" P2="324,134.5"/><JD c="1500fb,3,1,0" P1="375,134.5" P2="405,134.5"/><JD c="000000,6,1,0" P1="305,550" P2="474,550"/><JD c="1500fb,3,1,0" P1="375,240.5" P2="405,240.5"/><JD c="1500fb,3,1,0" P1="375,502.5" P2="405,502.5"/><JD c="000000,6,1,0" P1="91,29" P2="690,29"/><JD c="1500fb,3,1,0" P1="375,653.5" P2="405,653.5"/><JD c="1500fb,3,1,0" P1="533,134" P2="457,134"/><JD c="1500fb,3,1,0" P1="96,551" P2="143,551"/><JD c="1500fb,3,1,0" P1="685,551" P2="638,551"/><JD c="1500fb,3,1,0" P1="96,601" P2="143,601"/><JD c="1500fb,3,1,0" P1="685,601" P2="638,601"/><JD c="1500fb,3,1,0" P1="143,551" P2="143,601"/><JD c="1500fb,3,1,0" P1="638,551" P2="638,601"/><JD c="000000,5,1,0" P1="379,449" P2="401,449"/><JD c="000000,5,1,0" P1="379,554" P2="401,554"/><JD c="000000,5,1,0" P1="379,190" P2="401,190"/><JD c="000000,5,1,0" P1="379,33" P2="401,33"/><JD c="000000,5,1,0" P1="686,555" P2="686,597"/><JD c="000000,5,1,0" P1="95,555" P2="95,597"/></L></Z></C>]]}
pacmice_maps["pacmice_1"].pathes = {{1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}, {6, 1}, {7, 1}, {8, 1}, {9, 1}, {10, 1}, {13, 1}, {14, 1}, {15, 1}, {16, 1}, {17, 1}, {18, 1}, {19, 1}, {20, 1}, {21, 1}, {22, 1}, {1, 2}, {5, 2}, {10, 2}, {13, 2}, {18, 2}, {22, 2}, {1, 3}, {5, 3}, {10, 3}, {13, 3}, {18, 3}, {22, 3}, {1, 4}, {5, 4}, {10, 4}, {13, 4}, {18, 4}, {22, 4}, {1, 5}, {2, 5}, {3, 5}, {4, 5}, {5, 5}, {6, 5}, {7, 5}, {8, 5}, {9, 5}, {10, 5}, {11, 5}, {12, 5}, {13, 5}, {14, 5}, {15, 5}, {16, 5}, {17, 5}, {18, 5}, {19, 5}, {20, 5}, {21, 5}, {22, 5}, {1, 6}, {5, 6}, {7, 6}, {16, 6}, {18, 6}, {22, 6}, {1, 7}, {2, 7}, {3, 7}, {4, 7}, {5, 7}, {7, 7}, {8, 7}, {9, 7}, {10, 7}, {13, 7}, {14, 7}, {15, 7}, {16, 7}, {18, 7}, {19, 7}, {20, 7}, {21, 7}, {22, 7}, {5, 8}, {10, 8}, {13, 8}, {18, 8}, {5, 9}, {7, 9}, {8, 9}, {9, 9}, {10, 9}, {11, 9}, {12, 9}, {13, 9}, {14, 9}, {15, 9}, {16, 9}, {18, 9}, {5, 10}, {7, 10}, {16, 10}, {18, 10}, {5, 11}, {7, 11}, {16, 11}, {18, 11}, {1, 12}, {2, 12}, {3, 12}, {4, 12}, {5, 12}, {7, 12}, {16, 12}, {18, 12}, {19, 12}, {20, 12}, {21, 12}, {22, 12}, {5, 13}, {6, 13}, {7, 13}, {16, 13}, {17, 13}, {18, 13}, {5, 14}, {7, 14}, {16, 14}, {18, 14}, {5, 15}, {7, 15}, {8, 15}, {9, 15}, {10, 15}, {11, 15}, {12, 15}, {13, 15}, {14, 15}, {15, 15}, {16, 15}, {18, 15}, {5, 16}, {7, 16}, {16, 16}, {18, 16}, {1, 17}, {2, 17}, {3, 17}, {4, 17}, {5, 17}, {6, 17}, {7, 17}, {8, 17}, {9, 17}, {10, 17}, {13, 17}, {14, 17}, {15, 17}, {16, 17}, {17, 17}, {18, 17}, {19, 17}, {20, 17}, {21, 17}, {22, 17}, {1, 18}, {5, 18}, {10, 18}, {13, 18}, {18, 18}, {22, 18}, {1, 19}, {2, 19}, {3, 19}, {5, 19}, {6, 19}, {7, 19}, {8, 19}, {9, 19}, {10, 19}, {11, 19}, {12, 19}, {13, 19}, {14, 19}, {15, 19}, {16, 19}, {17, 19}, {18, 19}, {20, 19}, {21, 19}, {22, 19}, {3, 20}, {5, 20}, {7, 20}, {16, 20}, {18, 20}, {20, 20}, {3, 21}, {5, 21}, {7, 21}, {8, 21}, {9, 21}, {10, 21}, {13, 21}, {14, 21}, {15, 21}, {16, 21}, {18, 21}, {20, 21}, {3, 22}, {5, 22}, {7, 22}, {10, 22}, {13, 22}, {16, 22}, {18, 22}, {20, 22}, {1, 23}, {2, 23}, {3, 23}, {4, 23}, {5, 23}, {7, 23}, {8, 23}, {9, 23}, {10, 23}, {13, 23}, {14, 23}, {15, 23}, {16, 23}, {18, 23}, {19, 23}, {20, 23}, {21, 23}, {22, 23}, {1, 24}, {10, 24}, {13, 24}, {22, 24}, {1, 25}, {2, 25}, {3, 25}, {4, 25}, {5, 25}, {6, 25}, {7, 25}, {8, 25}, {9, 25}, {10, 25}, {11, 25}, {12, 25}, {13, 25}, {14, 25}, {15, 25}, {16, 25}, {17, 25}, {18, 25}, {19, 25}, {20, 25}, {21, 25}, {22, 25}}
pacmice_maps["pacmice_1"].foods = {{x = 285, y = 58}, {x = 495, y = 58}, {x = 390, y = 161}, {x = 274, y = 214}, {x = 502, y = 216}, {x = 389, y = 269}, {x = 117, y = 343}, {x = 117, y = 527}, {x = 218, y = 682}, {x = 390, y = 420}, {x = 390, y = 527}, {x = 352, y = 578}, {x = 427, y = 578}, {x = 561, y = 682}, {x = 667, y = 527}, {x = 661, y = 343}}
-- map 2 (2nd map)
pacmice_maps["pacmice_2"] = {xml = "pacmice_2", background_color = "#010101", x = 91, y = 39, cell_w = 26, cell_h = 26, wall_size = 14, web_x = -100, pac_count = 1, axml = [[<C><P H="720" DS="m;210,175,570,175" MEDATA=";;;;-0;0::0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208:1-"/><Z><S><S T="12" X="168" Y="91" L="56" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="612" Y="91" L="56" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="288" Y="91" L="84" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="492" Y="91" L="84" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="236" Y="142" L="84" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="544" Y="142" L="84" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="247" Y="536" L="58" H="10" P="0,0,0.3,0.2,-90,0,0,0"/><S T="12" X="533" Y="536" L="58" H="10" P="0,0,0.3,0.2,90,0,0,0"/><S T="12" X="208" Y="244" L="34" H="103" P="0,0,0.5,0.2,0,0,0,0"/><S T="12" X="572" Y="244" L="34" H="103" P="0,0,0.5,0.2,0,0,0,0"/><S T="12" X="120" Y="222" L="52" H="55" P="0,0,0.5,0.2,0,0,0,0"/><S T="12" X="660" Y="222" L="52" H="55" P="0,0,0.5,0.2,0,0,0,0"/><S T="12" X="390" Y="39" L="605" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="91" Y="91" L="10" H="114" P="0,0,0.5,0.2,0,0,0,0"/><S T="12" X="91" Y="433" L="10" H="569" P="0,0,0.5,0.2,0,0,0,0"/><S T="12" X="690" Y="91" L="10" H="113" P="0,0,0.5,0.2,0,0,0,0"/><S T="12" X="690" Y="433" L="10" H="574" P="0,0,0.5,0.2,0,0,0,0"/><S T="12" X="390" Y="716" L="608" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="390" Y="168" L="27" H="162" P="0,0,0.5,0.2,0,0,0,0"/><S T="12" X="391" Y="234" L="137" H="32" P="0,0,0.5,0.2,0,0,0,0"/><S T="12" X="325" Y="128" L="10" H="80" P="0,0,0.5,0.2,0,0,0,0"/><S T="12" X="455" Y="128" L="10" H="80" P="0,0,0.5,0.2,0,0,0,0"/><S T="12" X="273" Y="193" L="10" H="110" P="0,0,0.5,0.2,0,0,0,0"/><S T="12" X="507" Y="193" L="10" H="109" P="0,0,0.5,0.2,0,0,0,0"/><S T="12" X="285" Y="560" L="10" H="84" P="0,0,0.5,0.2,-90,0,0,0"/><S T="12" X="495" Y="560" L="10" H="84" P="0,0,0.5,0.2,90,0,0,0"/><S T="12" X="119" Y="143" L="50" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="661" Y="143" L="50" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="390" Y="483" L="30" H="55" P="0,0,0.5,0.2,360,0,0,0"/><S T="12" X="390" Y="613" L="32" H="103" P="0,0,0.5,0.2,360,0,0,0"/><S T="12" X="173" Y="417" L="50" H="31" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="607" Y="417" L="50" H="31" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="118" Y="545" L="50" H="35" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="662" Y="545" L="50" H="35" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="181" Y="611" L="81" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="599" Y="611" L="81" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="237" Y="664" L="81" H="10" P="0,0,0.3,0.2,180,0,0,0"/><S T="12" X="543" Y="664" L="81" H="10" P="0,0,0.3,0.2,-180,0,0,0"/><S T="12" X="107" Y="325" L="23" H="60" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="673" Y="325" L="23" H="60" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="210" Y="351" L="81" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="570" Y="351" L="81" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="247" Y="401" L="10" H="107" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="532" Y="401" L="10" H="107" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="390" Y="507" L="10" H="183" P="0,0,0.3,0.2,90,0,0,0"/><S T="12" X="284" Y="454" L="10" H="83" P="0,0,0.3,0.2,90,0,0,0"/><S T="12" X="496" Y="454" L="10" H="83" P="0,0,0.3,0.2,-90,0,0,0"/><S T="12" X="143" Y="443" L="10" H="83" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="637" Y="443" L="10" H="83" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="195" Y="521" L="10" H="80" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="585" Y="521" L="10" H="80" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="143" Y="637" L="10" H="60" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="637" Y="637" L="10" H="60" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="273" Y="638" L="10" H="59" P="0,0,0.3,0.2,180,0,0,0"/><S T="12" X="507" Y="638" L="10" H="59" P="0,0,0.3,0.2,-180,0,0,0"/><S T="12" X="325" Y="662" L="10" H="105" P="0,0,0.3,0.2,180,0,0,0"/><S T="12" X="455" Y="662" L="10" H="105" P="0,0,0.3,0.2,-180,0,0,0"/><S T="12" X="209" Y="299" L="78" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="571" Y="299" L="78" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="391" Y="403" L="190" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="480" Y="308" L="10" H="18" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="300" Y="308" L="10" H="18" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="480" Y="397" L="10" H="18" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="300" Y="397" L="10" H="18" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="325" Y="302" L="60" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="455" Y="302" L="60" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="390" Y="302" L="67" H="10" P="0,0,0.3,0.2,0,0,0,0" v="90000"/><S T="12" X="480" Y="352" L="67" H="10" P="0,0,0.3,0.2,90,0,0,0" v="90000"/><S T="12" X="300" Y="352" L="67" H="10" P="0,0,0.3,0.2,90,0,0,0" v="90000"/><S T="12" X="400" Y="735" L="10" H="10" P="1,0,0.3,0.2,0,1,Infinity,0" c="4" v="90000"/><S T="12" X="400" Y="735" L="10" H="10" P="1,0,0.3,0.2,0,1,Infinity,0" c="4" v="89000"/><S T="12" X="400" Y="735" L="10" H="10" P="1,0,0.3,0.2,0,1,Infinity,0" c="4" v="88000"/><S T="12" X="400" Y="735" L="10" H="10" P="1,0,0.3,0.2,0,1,Infinity,0" c="4" v="87000"/><S T="12" X="400" Y="735" L="10" H="10" P="1,0,0.3,0.2,0,1,Infinity,0" c="4" v="86000"/><S T="12" X="400" Y="735" L="10" H="10" P="1,0,0.3,0.2,0,1,Infinity,0" c="4" v="85000"/></S><D><F X="335" Y="390" D=""/><F X="445" Y="390" D=""/><T X="392" Y="397" D=""/></D><O/><L><JD c="1500fb,10,1,0" P1="91,39" P2="689,39"/><JD c="1500fb,10,1,0" P1="91,716" P2="689,716"/><JD c="1500fb,10,1,0" P1="91,40" P2="91,143"/><JD c="1500fb,10,1,0" P1="689,40" P2="689,143"/><JD c="1500fb,10,1,0" P1="91,199" P2="91,713"/><JD c="1500fb,10,1,0" P1="689,199" P2="689,713"/><JD c="1500fb,10,1,0" P1="273,143" P2="273,244"/><JD c="1500fb,10,1,0" P1="507,143" P2="507,244"/><JD c="1500fb,10,1,0" P1="325,91" P2="325,163"/><JD c="1500fb,10,1,0" P1="455,91" P2="455,163"/><JD c="1500fb,10,1,0" P1="272,142" P2="199,142"/><JD c="1500fb,10,1,0" P1="508,142" P2="581,142"/><JD c="1500fb,10,1,0" P1="244,299" P2="174,299"/><JD c="FFFFFF,10,1,0" M1="69" M2="69" P1="419,302" P2="361,302"/><JD c="FFFFFF,10,1,0" M1="69" M2="69" P1="480,382" P2="480,324"/><JD c="FFFFFF,10,1,0" M1="69" M2="69" P1="300,382" P2="300,324"/><JD c="1500fb,10,1,0" M1="70" M2="70" P1="419,302" P2="361,302"/><JD c="1500fb,10,1,0" M1="70" M2="70" P1="480,382" P2="480,324"/><JD c="1500fb,10,1,0" M1="70" M2="70" P1="300,382" P2="300,324"/><JD c="FFFFFF,10,1,0" M1="71" M2="71" P1="419,302" P2="361,302"/><JD c="FFFFFF,10,1,0" M1="71" M2="71" P1="480,382" P2="480,324"/><JD c="FFFFFF,10,1,0" M1="71" M2="71" P1="300,382" P2="300,324"/><JD c="1500fb,10,1,0" M1="72" M2="72" P1="419,302" P2="361,302"/><JD c="1500fb,10,1,0" M1="72" M2="72" P1="480,382" P2="480,324"/><JD c="1500fb,10,1,0" M1="72" M2="72" P1="300,382" P2="300,324"/><JD c="FFFFFF,10,1,0" M1="73" M2="73" P1="419,302" P2="361,302"/><JD c="FFFFFF,10,1,0" M1="73" M2="73" P1="480,382" P2="480,324"/><JD c="FFFFFF,10,1,0" M1="73" M2="73" P1="300,382" P2="300,324"/><JD c="1500fb,10,1,0" M1="74" M2="74" P1="419,302" P2="361,302"/><JD c="1500fb,10,1,0" M1="74" M2="74" P1="480,382" P2="480,324"/><JD c="1500fb,10,1,0" M1="74" M2="74" P1="300,382" P2="300,324"/><JD c="1500fb,10,1,0" P1="536,299" P2="606,299"/><JD c="1500fb,10,1,0" P1="245,351" P2="174,351"/><JD c="1500fb,10,1,0" P1="535,351" P2="606,351"/><JD c="1500fb,10,1,0" P1="321,454" P2="249,454"/><JD c="1500fb,10,1,0" P1="478,507" P2="302,507"/><JD c="1500fb,10,1,0" P1="479,403" P2="301,403"/><JD c="1500fb,10,1,0" P1="459,454" P2="531,454"/><JD c="1500fb,10,1,0" P1="322,560" P2="249,560"/><JD c="1500fb,10,1,0" P1="458,560" P2="531,560"/><JD c="1500fb,10,1,0" P1="218,611" P2="144,611"/><JD c="1500fb,10,1,0" P1="562,611" P2="636,611"/><JD c="1500fb,10,1,0" P1="273,664" P2="200,664"/><JD c="1500fb,10,1,0" P1="507,664" P2="580,664"/><JD c="1500fb,10,1,0" P1="323,91" P2="250,91"/><JD c="1500fb,10,1,0" P1="457,91" P2="530,91"/><JD c="1500fb,10,1,0" P1="192,91" P2="144,91"/><JD c="1500fb,10,1,0" P1="588,91" P2="636,91"/><JD c="1500fb,10,1,0" P1="351,302" P2="301,302"/><JD c="1500fb,10,1,0" P1="429,302" P2="479,302"/><JD c="1500fb,10,1,0" P1="140,143" P2="92,143"/><JD c="1500fb,10,1,0" P1="640,143" P2="688,143"/><JD c="1500fb,10,1,0" P1="480,302" P2="480,314"/><JD c="1500fb,10,1,0" P1="300,302" P2="300,314"/><JD c="1500fb,10,1,0" P1="480,391" P2="480,402"/><JD c="1500fb,10,1,0" P1="300,391" P2="300,402"/><JD c="1500fb,10,1,0" P1="247,351" P2="247,454"/><JD c="1500fb,10,1,0" P1="533,351" P2="533,454"/><JD c="1500fb,10,1,0" P1="195,485" P2="195,557"/><JD c="1500fb,10,1,0" P1="585,485" P2="585,557"/><JD c="1500fb,10,1,0" P1="143,406" P2="143,479"/><JD c="1500fb,10,1,0" P1="637,406" P2="637,479"/><JD c="1500fb,10,1,0" P1="247,511" P2="247,560"/><JD c="1500fb,10,1,0" P1="533,511" P2="533,560"/><JD c="1500fb,10,1,0" P1="273,613" P2="273,664"/><JD c="1500fb,10,1,0" P1="507,613" P2="507,664"/><JD c="1500fb,10,1,0" P1="143,612" P2="143,663"/><JD c="1500fb,10,1,0" P1="637,612" P2="637,663"/><JD c="1500fb,10,1,0" P1="325,613" P2="325,716"/><JD c="1500fb,10,1,0" P1="455,613" P2="455,716"/><JD c="000000,6,1,0" P1="91,40" P2="91,143"/><JD c="000000,6,1,0" P1="689,40" P2="689,143"/><JD c="000000,6,1,0" P1="91,198" P2="91,713"/><JD c="000000,6,1,0" P1="689,198" P2="689,713"/><JD c="000000,6,1,0" P1="273,143" P2="273,244"/><JD c="000000,6,1,0" P1="507,143" P2="507,244"/><JD c="000000,6,1,0" P1="325,91" P2="325,163"/><JD c="000000,6,1,0" P1="455,91" P2="455,163"/><JD c="000000,6,1,0" P1="272,142" P2="199,142"/><JD c="000000,6,1,0" P1="508,142" P2="581,142"/><JD c="000000,6,1,0" P1="244,299" P2="174,299"/><JD c="000000,6,1,0" M1="69" M2="69" P1="419,302" P2="361,302"/><JD c="000000,6,1,0" M1="69" M2="69" P1="480,382" P2="480,324"/><JD c="000000,6,1,0" M1="69" M2="69" P1="300,382" P2="300,324"/><JD c="000000,6,1,0" P1="536,299" P2="606,299"/><JD c="000000,6,1,0" P1="245,351" P2="174,351"/><JD c="000000,6,1,0" P1="535,351" P2="606,351"/><JD c="1500fb,3,1,0" P1="141,403" P2="197,403"/><JD c="000000,6,1,0" P1="91,716" P2="689,716"/><JD c="1500fb,3,1,0" P1="639,403" P2="583,403"/><JD c="1500fb,3,1,0" P1="96,529" P2="142,529"/><JD c="1500fb,3,1,0" P1="684,529" P2="638,529"/><JD c="000000,6,1,0" P1="321,454" P2="249,454"/><JD c="000000,6,1,0" P1="478,507" P2="302,507"/><JD c="000000,6,1,0" P1="479,403" P2="301,403"/><JD c="000000,6,1,0" P1="459,454" P2="531,454"/><JD c="000000,6,1,0" P1="322,560" P2="249,560"/><JD c="000000,6,1,0" P1="458,560" P2="531,560"/><JD c="000000,6,1,0" P1="218,611" P2="144,611"/><JD c="000000,6,1,0" P1="562,611" P2="636,611"/><JD c="000000,6,1,0" P1="273,664" P2="200,664"/><JD c="000000,6,1,0" P1="507,664" P2="580,664"/><JD c="000000,6,1,0" P1="323,91" P2="250,91"/><JD c="000000,6,1,0" P1="457,91" P2="530,91"/><JD c="000000,6,1,0" P1="192,91" P2="144,91"/><JD c="000000,6,1,0" P1="588,91" P2="636,91"/><JD c="000000,6,1,0" P1="351,302" P2="301,302"/><JD c="000000,6,1,0" P1="429,302" P2="479,302"/><JD c="000000,6,1,0" P1="140,143" P2="92,143"/><JD c="000000,6,1,0" P1="640,143" P2="688,143"/><JD c="000000,6,1,0" P1="480,302" P2="480,314"/><JD c="000000,6,1,0" P1="300,302" P2="300,314"/><JD c="000000,6,1,0" P1="480,391" P2="480,402"/><JD c="000000,6,1,0" P1="300,391" P2="300,402"/><JD c="000000,6,1,0" P1="247,351" P2="247,454"/><JD c="000000,6,1,0" P1="533,351" P2="533,454"/><JD c="000000,6,1,0" P1="195,485" P2="195,557"/><JD c="000000,6,1,0" P1="585,485" P2="585,557"/><JD c="000000,6,1,0" P1="143,408" P2="143,479"/><JD c="000000,6,1,0" P1="637,407" P2="637,479"/><JD c="000000,6,1,0" P1="247,511" P2="247,560"/><JD c="000000,6,1,0" P1="533,511" P2="533,560"/><JD c="000000,6,1,0" P1="273,613" P2="273,664"/><JD c="000000,6,1,0" P1="507,613" P2="507,664"/><JD c="000000,6,1,0" P1="143,612" P2="143,663"/><JD c="000000,6,1,0" P1="637,612" P2="637,663"/><JD c="000000,6,1,0" P1="325,613" P2="325,716"/><JD c="000000,6,1,0" P1="455,613" P2="455,716"/><JD c="1500fb,3,1,0" P1="88,196" P2="144,196"/><JD c="1500fb,3,1,0" P1="692,196" P2="636,196"/><JD c="1500fb,3,1,0" P1="193,195" P2="223,195"/><JD c="1500fb,3,1,0" P1="376,563" P2="404,563"/><JD c="000000,6,1,0" P1="91,39" P2="689,39"/><JD c="1500fb,3,1,0" P1="376,457" P2="404,457"/><JD c="1500fb,3,1,0" P1="376,663" P2="404,663"/><JD c="1500fb,3,1,0" P1="587,195" P2="557,195"/><JD c="1500fb,3,1,0" P1="402,89" P2="378,89"/><JD c="1500fb,3,1,0" P1="458,220" P2="402,220"/><JD c="1500fb,3,1,0" P1="378,220" P2="324,220"/><JD c="1500fb,3,1,0" P1="458,249" P2="324,249"/><JD c="1500fb,3,1,0" P1="96,297" P2="117,297"/><JD c="1500fb,3,1,0" P1="684,297" P2="663,297"/><JD c="1500fb,3,1,0" P1="148,431" P2="196,431"/><JD c="1500fb,3,1,0" P1="632,431" P2="584,431"/><JD c="1500fb,3,1,0" P1="96,561" P2="142,561"/><JD c="1500fb,3,1,0" P1="684,561" P2="638,561"/><JD c="1500fb,3,1,0" P1="96,353" P2="117,353"/><JD c="1500fb,3,1,0" P1="684,353" P2="663,353"/><JD c="1500fb,3,1,0" P1="96,248" P2="144,248"/><JD c="1500fb,3,1,0" P1="684,248" P2="636,248"/><JD c="1500fb,3,1,0" P1="144,197" P2="144,248"/><JD c="1500fb,3,1,0" P1="324,220" P2="324,248"/><JD c="1500fb,3,1,0" P1="458,220" P2="458,248"/><JD c="1500fb,3,1,0" P1="636,197" P2="636,248"/><JD c="1500fb,3,1,0" P1="117,297" P2="117,353"/><JD c="1500fb,3,1,0" P1="663,297" P2="663,353"/><JD c="1500fb,3,1,0" P1="197,403" P2="197,431"/><JD c="1500fb,3,1,0" P1="404,457" P2="404,502"/><JD c="1500fb,3,1,0" P1="376,457" P2="376,502"/><JD c="1500fb,3,1,0" P1="583,403" P2="583,431"/><JD c="1500fb,3,1,0" P1="142.17,529" P2="142.17,560"/><JD c="1500fb,3,1,0" P1="637.83,529" P2="637.83,560"/><JD c="1500fb,3,1,0" P1="193,195" P2="193,294"/><JD c="1500fb,3,1,0" P1="376,563" P2="376,662"/><JD c="1500fb,3,1,0" P1="587,195" P2="587,294"/><JD c="1500fb,3,1,0" P1="401.79,89" P2="401.79,218"/><JD c="1500fb,3,1,0" P1="223,195" P2="223,294"/><JD c="1500fb,3,1,0" P1="404,563" P2="404,662"/><JD c="1500fb,3,1,0" P1="557,195" P2="557,294"/><JD c="1500fb,3,1,0" P1="378,89" P2="378,218"/><JD c="000000,3,1,0" P1="560,298.16" P2="560,274.75"/><JD c="000000,3,1,0" P1="196,298.16" P2="196,274.75"/><JD c="000000,3,1,0" P1="379,506.16" P2="379,482.75"/><JD c="000000,3,1,0" P1="561,295" P2="583,295"/><JD c="000000,3,1,0" P1="197,295" P2="219,295"/><JD c="000000,3,1,0" P1="379,503" P2="400,503"/><JD c="000000,3,1,0" P1="685,556" P2="685,534"/><JD c="000000,3,1,0" P1="633,428" P2="633,408"/><JD c="000000,3,1,0" P1="147,428" P2="147,408"/><JD c="000000,3,1,0" P1="95,556" P2="95,534"/><JD c="000000,3,1,0" P1="685,348" P2="685,300"/><JD c="000000,3,1,0" P1="95,348" P2="95,300"/><JD c="000000,3,1,0" P1="685,244" P2="685,199"/><JD c="000000,3,1,0" P1="95,244" P2="95,199"/><JD c="000000,3,1,0" P1="584,298.16" P2="584,274.75"/><JD c="000000,3,1,0" P1="220,298.16" P2="220,274.75"/><JD c="000000,3,1,0" P1="401,506.16" P2="401,482.75"/><JD c="000000,3,1,0" P1="687,532" P2="664,532"/><JD c="000000,3,1,0" P1="635,406" P2="612,406"/><JD c="000000,3,1,0" P1="143,406" P2="168,406"/><JD c="000000,3,1,0" P1="93,532" P2="116,532"/><JD c="000000,3,1,0" P1="687,300" P2="673,300"/><JD c="000000,3,1,0" P1="93,300" P2="107,300"/><JD c="000000,3,1,0" P1="687,199" P2="673,199"/><JD c="000000,3,1,0" P1="93,199" P2="107,199"/><JD c="000000,3,1,0" P1="695,193" P2="681,193"/><JD c="000000,3,1,0" P1="85,193" P2="99,193"/><JD c="000000,3,1,0" P1="687,558" P2="664,558"/><JD c="000000,3,1,0" P1="635,428" P2="612,428"/><JD c="000000,3,1,0" P1="145,428" P2="168,428"/><JD c="000000,3,1,0" P1="93,558" P2="116,558"/><JD c="000000,3,1,0" P1="687,350" P2="673,350"/><JD c="000000,3,1,0" P1="93,350" P2="107,350"/><JD c="1500fb,10,1,0" P1="91,189" P2="91,153"/><JD c="1500fb,10,1,0" P1="689,189" P2="689,153"/><JD c="000000,3,1,0" P1="687,245" P2="673,245"/><JD c="000000,3,1,0" P1="93,245" P2="107,245"/><JD c="000000,6,1,0" P1="91,189" P2="91,153"/><JD c="000000,6,1,0" P1="689,189" P2="689,153"/></L></Z></C>]]}
pacmice_maps["pacmice_2"].pathes = {{1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}, {6, 1}, {7, 1}, {8, 1}, {9, 1}, {10, 1}, {11, 1}, {12, 1}, {13, 1}, {14, 1}, {15, 1}, {16, 1}, {17, 1}, {18, 1}, {19, 1}, {20, 1}, {21, 1}, {22, 1}, {1, 2}, {5, 2}, {10, 2}, {13, 2}, {18, 2}, {22, 2}, {1, 3}, {2, 3}, {3, 3}, {4, 3}, {5, 3}, {6, 3}, {7, 3}, {8, 3}, {10, 3}, {13, 3}, {15, 3}, {16, 3}, {17, 3}, {18, 3}, {19, 3}, {20, 3}, {21, 3}, {22, 3}, {3, 4}, {8, 4}, {10, 4}, {13, 4}, {15, 4}, {20, 4}, {1, 5}, {2, 5}, {3, 5}, {4, 5}, {5, 5}, {6, 5}, {8, 5}, {10, 5}, {13, 5}, {15, 5}, {17, 5}, {18, 5}, {19, 5}, {20, 5}, {21, 5}, {22, 5}, {3, 6}, {6, 6}, {8, 6}, {9, 6}, {10, 6}, {13, 6}, {14, 6}, {15, 6}, {17, 6}, {20, 6}, {3, 7}, {6, 7}, {8, 7}, {15, 7}, {17, 7}, {20, 7}, {3, 8}, {6, 8}, {8, 8}, {15, 8}, {17, 8}, {20, 8}, {1, 9}, {2, 9}, {3, 9}, {6, 9}, {7, 9}, {8, 9}, {9, 9}, {10, 9}, {11, 9}, {12, 9}, {13, 9}, {14, 9}, {15, 9}, {16, 9}, {17, 9}, {20, 9}, {21, 9}, {22, 9}, {2, 10}, {7, 10}, {16, 10}, {21, 10}, {2, 11}, {3, 11}, {4, 11}, {5, 11}, {6, 11}, {7, 11}, {16, 11}, {17, 11}, {18, 11}, {19, 11}, {20, 11}, {21, 11}, {2, 12}, {7, 12}, {16, 12}, {21, 12}, {1, 13}, {2, 13}, {3, 13}, {4, 13}, {5, 13}, {7, 13}, {16, 13}, {18, 13}, {19, 13}, {20, 13}, {21, 13}, {22, 13}, {1, 14}, {5, 14}, {7, 14}, {16, 14}, {18, 14}, {22, 14}, {1, 15}, {5, 15}, {7, 15}, {8, 15}, {9, 15}, {10, 15}, {11, 15}, {12, 15}, {13, 15}, {14, 15}, {15, 15}, {16, 15}, {18, 15}, {22, 15}, {1, 16}, {3, 16}, {4, 16}, {5, 16}, {10, 16}, {13, 16}, {18, 16}, {19, 16}, {20, 16}, {22, 16}, {1, 17}, {3, 17}, {5, 17}, {6, 17}, {7, 17}, {8, 17}, {9, 17}, {10, 17}, {13, 17}, {14, 17}, {15, 17}, {16, 17}, {17, 17}, {18, 17}, {20, 17}, {22, 17}, {1, 18}, {2, 18}, {3, 18}, {5, 18}, {7, 18}, {16, 18}, {18, 18}, {20, 18}, {21, 18}, {22, 18}, {3, 19}, {5, 19}, {7, 19}, {8, 19}, {9, 19}, {10, 19}, {11, 19}, {12, 19}, {13, 19}, {14, 19}, {15, 19}, {16, 19}, {18, 19}, {20, 19}, {3, 20}, {5, 20}, {10, 20}, {13, 20}, {18, 20}, {20, 20}, {1, 21}, {2, 21}, {3, 21}, {4, 21}, {5, 21}, {6, 21}, {7, 21}, {8, 21}, {9, 21}, {10, 21}, {13, 21}, {14, 21}, {15, 21}, {16, 21}, {17, 21}, {18, 21}, {19, 21}, {20, 21}, {21, 21}, {22, 21}, {1, 22}, {6, 22}, {8, 22}, {10, 22}, {13, 22}, {15, 22}, {17, 22}, {22, 22}, {1, 23}, {3, 23}, {4, 23}, {5, 23}, {6, 23}, {8, 23}, {10, 23}, {13, 23}, {15, 23}, {17, 23}, {18, 23}, {19, 23}, {20, 23}, {22, 23}, {1, 24}, {3, 24}, {8, 24}, {10, 24}, {13, 24}, {15, 24}, {20, 24}, {22, 24}, {1, 25}, {2, 25}, {3, 25}, {4, 25}, {5, 25}, {6, 25}, {7, 25}, {8, 25}, {10, 25}, {11, 25}, {12, 25}, {13, 25}, {15, 25}, {16, 25}, {17, 25}, {18, 25}, {19, 25}, {20, 25}, {21, 25}, {22, 25}}
pacmice_maps["pacmice_2"].foods = {{x = 170, y = 65}, {x = 390, y = 65}, {x = 607, y = 65}, {x = 347, y = 201}, {x = 432, y = 201}, {x = 390, y = 278}, {x = 203, y = 326}, {x = 574, y = 326}, {x = 170, y = 454}, {x = 345, y = 487}, {x = 390, y = 537}, {x = 435, y = 487}, {x = 607, y = 454}, {x = 170, y = 638}, {x = 235, y = 690}, {x = 390, y = 690}, {x = 540, y = 690}, {x = 607, y = 642}}
-- map 3 (v4)
pacmice_maps["pacmice_3"] = {xml = "pacmice_3", background_color = "#010101", x = 10, y = 27, cell_w = 26, cell_h = 26, grid_w = 31, grid_h = 15, wall_size = 14, web_x = -100, pac_count = 1, axml = [[<C><P DS="m;360,85,440,85" MEDATA=";;;;-0;0::0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131:1-"/><Z><S><S T="12" X="190" Y="157" L="58" H="10" P="0,0,0.3,0.2,180,0,0,0"/><S T="12" X="612" Y="157" L="58" H="10" P="0,0,0.3,0.2,-180,0,0,0"/><S T="12" X="788" Y="208" L="369" H="10" P="0,0,0.6,0.2,90,0,0,0"/><S T="12" X="400" Y="27" L="10" H="781" P="0,0,0.3,0.2,90,0,0,0"/><S T="12" X="400" Y="391" L="10" H="781" P="0,0,0.3,0.2,90,0,0,0"/><S T="12" X="10" Y="208" L="372" H="10" P="0,0,0.6,0.2,90,0,0,0"/><S T="12" X="166" Y="119" L="10" H="84" P="0,0,0.6,0.2,180,0,0,0"/><S T="12" X="219" Y="69" L="10" H="84" P="0,0,0.6,0.2,180,0,0,0"/><S T="12" X="583" Y="69" L="10" H="84" P="0,0,0.6,0.2,180,0,0,0"/><S T="12" X="636" Y="119" L="10" H="84" P="0,0,0.6,0.2,-180,0,0,0"/><S T="12" X="401" Y="326" L="32" H="157" P="0,0,0.3,0.2,-450,0,0,0"/><S T="12" X="400" Y="44" L="32" H="157" P="0,0,0.3,0.2,-450,0,0,0"/><S T="12" X="258" Y="305" L="73" H="31" P="0,0,0.6,0.2,90,0,0,0"/><S T="12" X="158" Y="326" L="73" H="31" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="644" Y="326" L="73" H="31" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="544" Y="306" L="75" H="31" P="0,0,0.6,0.2,-90,0,0,0"/><S T="12" X="114" Y="223" L="81" H="10" P="0,0,0.6,0.2,90,0,0,0"/><S T="12" X="687" Y="223" L="81" H="10" P="0,0,0.6,0.2,-90,0,0,0"/><S T="12" X="62" Y="167" L="81" H="10" P="0,0,0.6,0.2,-90,0,0,0"/><S T="12" X="740" Y="167" L="81" H="10" P="0,0,0.6,0.2,90,0,0,0"/><S T="12" X="738" Y="327" L="34" H="10" P="0,0,0.6,0.2,90,0,0,0"/><S T="12" X="62" Y="327" L="34" H="10" P="0,0,0.6,0.2,-90,0,0,0"/><S T="12" X="322" Y="157" L="10" H="110" P="0,0,0.3,0.2,90,0,0,0"/><S T="12" X="477" Y="157" L="10" H="108" P="0,0,0.3,0.2,-90,0,0,0"/><S T="12" X="271" Y="117" L="10" H="83" P="0,0,0.6,0.2,0,0,0,0"/><S T="12" X="400" Y="70" L="10" H="83" P="0,0,0.6,0.2,0,0,0,0"/><S T="12" X="530" Y="120" L="10" H="83" P="0,0,0.6,0.2,0,0,0,0"/><S T="12" X="219" Y="263" L="10" H="108" P="0,0,0.3,0.2,90,0,0,0"/><S T="12" X="116" Y="351" L="10" H="82" P="0,0,0.6,0.2,0,0,0,0"/><S T="12" X="686" Y="350" L="10" H="78" P="0,0,0.6,0.2,0,0,0,0"/><S T="12" X="582" Y="263" L="10" H="107" P="0,0,0.3,0.2,-90,0,0,0"/><S T="12" X="217" Y="209" L="10" H="105" P="0,0,0.3,0.2,90,0,0,0"/><S T="12" X="583" Y="209" L="10" H="106" P="0,0,0.3,0.2,-90,0,0,0"/><S T="12" X="66" Y="261" L="10" H="106" P="0,0,0.3,0.2,90,0,0,0"/><S T="12" X="733" Y="261" L="10" H="99" P="0,0,0.3,0.2,-90,0,0,0"/><S T="12" X="89" Y="131" L="10" H="59" P="0,0,0.3,0.2,-90,0,0,0"/><S T="12" X="714" Y="131" L="10" H="59" P="0,0,0.3,0.2,90,0,0,0"/><S T="12" X="65" Y="79" L="10" H="105" P="0,0,0.3,0.2,-90,0,0,0"/><S T="12" X="738" Y="79" L="10" H="105" P="0,0,0.3,0.2,90,0,0,0"/><S T="12" X="400" Y="260" L="166" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="400" Y="106" L="162" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="342" Y="212" L="47" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="459" Y="212" L="47" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="400" Y="212" L="67" H="10" P="0,0,0.3,0.2,0,0,0,0" v="90000"/><S T="12" X="479" Y="236" L="54" H="10" P="0,0,0.3,0.2,90,0,0,0" v="90000"/><S T="12" X="322" Y="236" L="54" H="10" P="0,0,0.3,0.2,90,0,0,0" v="90000"/><S T="12" X="400" Y="410" L="10" H="10" P="1,0,0.3,0.2,90,1,Infinity,0" c="4" v="90000"/><S T="12" X="400" Y="410" L="10" H="10" P="1,0,0.3,0.2,90,1,Infinity,0" c="4" v="89000"/><S T="12" X="400" Y="410" L="10" H="10" P="1,0,0.3,0.2,90,1,Infinity,0" c="4" v="88000"/><S T="12" X="400" Y="410" L="10" H="10" P="1,0,0.3,0.2,90,1,Infinity,0" c="4" v="87000"/><S T="12" X="400" Y="410" L="10" H="10" P="1,0,0.3,0.2,90,1,Infinity,0" c="4" v="86000"/><S T="12" X="400" Y="410" L="10" H="10" P="1,0,0.3,0.2,90,1,Infinity,0" c="4" v="85000"/></S><D><F X="351" Y="248" D=""/><F X="450" Y="247" D=""/><T X="399" Y="254" D=""/></D><O/><L><JD c="1500fb,10,1,0" P1="788,27" P2="788,391"/><JD c="1500fb,10,1,0" P1="10,27" P2="10,391"/><JD c="1500fb,10,1,0" P1="787,27" P2="12,27"/><JD c="1500fb,10,1,0" P1="787,391" P2="12,391"/><JD c="1500fb,10,1,0" P1="478,106" P2="323,106"/><JD c="1500fb,10,1,0" P1="400,29" P2="400,106"/><JD c="FFFFFF,10,1,0" M1="46" M2="46" P1="429,212.41" P2="371,212.41"/><JD c="FFFFFF,10,1,0" M1="46" M2="46" P1="478.59,259" P2="478.59,213"/><JD c="FFFFFF,10,1,0" M1="46" M2="46" P1="321.59,259" P2="321.59,213"/><JD c="1500fb,10,1,0" M1="47" M2="47" P1="429,212.41" P2="371,212.41"/><JD c="1500fb,10,1,0" M1="47" M2="47" P1="478.59,259" P2="478.59,213"/><JD c="1500fb,10,1,0" M1="47" M2="47" P1="321.59,259" P2="321.59,213"/><JD c="FFFFFF,10,1,0" M1="48" M2="48" P1="429,212.41" P2="371,212.41"/><JD c="FFFFFF,10,1,0" M1="48" M2="48" P1="478.59,259" P2="478.59,213"/><JD c="FFFFFF,10,1,0" M1="48" M2="48" P1="321.59,259" P2="321.59,213"/><JD c="1500fb,10,1,0" M1="49" M2="49" P1="429,212.41" P2="371,212.41"/><JD c="1500fb,10,1,0" M1="49" M2="49" P1="478.59,259" P2="478.59,213"/><JD c="1500fb,10,1,0" M1="49" M2="49" P1="321.59,259" P2="321.59,213"/><JD c="FFFFFF,10,1,0" M1="50" M2="50" P1="429,212.41" P2="371,212.41"/><JD c="FFFFFF,10,1,0" M1="50" M2="50" P1="478.59,259" P2="478.59,213"/><JD c="FFFFFF,10,1,0" M1="50" M2="50" P1="321.59,259" P2="321.59,213"/><JD c="1500fb,10,1,0" M1="51" M2="51" P1="429,212.41" P2="371,212.41"/><JD c="1500fb,10,1,0" M1="51" M2="51" P1="478.59,259" P2="478.59,213"/><JD c="1500fb,10,1,0" M1="51" M2="51" P1="321.59,259" P2="321.59,213"/><JD c="1500fb,10,1,0" P1="738,314" P2="738,339"/><JD c="1500fb,10,1,0" P1="62,314" P2="62,339"/><JD c="1500fb,10,1,0" P1="478,260" P2="322,260"/><JD c="1500fb,10,1,0" P1="271,80" P2="271,156"/><JD c="1500fb,10,1,0" P1="530,83" P2="530,155"/><JD c="1500fb,10,1,0" P1="166,82" P2="166,155"/><JD c="1500fb,10,1,0" P1="219,28" P2="219,105"/><JD c="1500fb,10,1,0" P1="583,28" P2="583,105"/><JD c="1500fb,10,1,0" P1="636,82" P2="636,155"/><JD c="1500fb,10,1,0" P1="114,186" P2="114,260"/><JD c="1500fb,10,1,0" P1="687,186" P2="687,260"/><JD c="1500fb,10,1,0" P1="62,131" P2="62,204"/><JD c="1500fb,10,1,0" P1="740,131" P2="740,204"/><JD c="1500fb,10,1,0" P1="361,212" P2="322,212"/><JD c="1500fb,10,1,0" P1="439,212" P2="478,212"/><JD c="1500fb,10,1,0" P1="372,157" P2="271,157"/><JD c="1500fb,10,1,0" P1="428,157" P2="530,157"/><JD c="1500fb,10,1,0" P1="266,209" P2="168,209"/><JD c="1500fb,3,1,0" P1="323,31" P2="323,58"/><JD c="1500fb,10,1,0" P1="533,209" P2="632,209"/><JD c="1500fb,10,1,0" P1="269,263" P2="169,263"/><JD c="1500fb,3,1,0" P1="477,31" P2="477,58"/><JD c="1500fb,10,1,0" P1="116.45,314.92" P2="116.45,389.92"/><JD c="1500fb,10,1,0" P1="686.05,314.92" P2="686.05,389.92"/><JD c="1500fb,10,1,0" P1="534,263" P2="632,263"/><JD c="1500fb,10,1,0" P1="215,157" P2="166,157"/><JD c="1500fb,10,1,0" P1="587,157" P2="636,157"/><JD c="1500fb,10,1,0" P1="113,131" P2="62,131"/><JD c="1500fb,10,1,0" P1="689,131" P2="740,131"/><JD c="1500fb,10,1,0" P1="113,261" P2="10,261"/><JD c="1500fb,10,1,0" P1="688,261" P2="787,261"/><JD c="1500fb,10,1,0" P1="113,79" P2="10,79"/><JD c="1500fb,10,1,0" P1="689,79" P2="788,79"/><JD c="1500fb,3,1,0" P1="323,58" P2="477,58"/><JD c="000000,6,1,0" P1="787,27" P2="12,27"/><JD c="000000,6,1,0" P1="787,391" P2="12,391"/><JD c="000000,6,1,0" P1="478,106" P2="323,106"/><JD c="000000,6,1,0" P1="400,29" P2="400,106"/><JD c="000000,6,1,0" M1="46" M2="46" P1="429,212.41" P2="371,212.41"/><JD c="000000,6,1,0" M1="46" M2="46" P1="478.59,259" P2="478.59,213"/><JD c="000000,6,1,0" M1="46" M2="46" P1="321.59,259" P2="321.59,213"/><JD c="000000,6,1,0" P1="738,314" P2="738,339"/><JD c="000000,6,1,0" P1="62,314" P2="62,339"/><JD c="1500fb,3,1,0" P1="272,261" P2="272,340"/><JD c="1500fb,3,1,0" P1="114.45,311.92" P2="193.45,311.92"/><JD c="1500fb,3,1,0" P1="688.05,311.92" P2="609.05,311.92"/><JD c="1500fb,3,1,0" P1="530,261" P2="530,342"/><JD c="000000,6,1,0" P1="10,27" P2="10,391"/><JD c="000000,6,1,0" P1="478,260" P2="322,260"/><JD c="000000,6,1,0" P1="271,80" P2="271,156"/><JD c="000000,6,1,0" P1="530,83" P2="530,155"/><JD c="000000,6,1,0" P1="166,82" P2="166,155"/><JD c="000000,6,1,0" P1="219,28" P2="219,105"/><JD c="000000,6,1,0" P1="583,28" P2="583,105"/><JD c="000000,6,1,0" P1="636,82" P2="636,155"/><JD c="000000,6,1,0" P1="114,186" P2="114,260"/><JD c="000000,6,1,0" P1="687,186" P2="687,260"/><JD c="000000,6,1,0" P1="62,131" P2="62,204"/><JD c="000000,6,1,0" P1="740,131" P2="740,204"/><JD c="000000,6,1,0" P1="361,212" P2="322,212"/><JD c="000000,6,1,0" P1="439,212" P2="478,212"/><JD c="000000,6,1,0" P1="372,157" P2="271,157"/><JD c="000000,6,1,0" P1="428,157" P2="530,157"/><JD c="000000,6,1,0" P1="266,209" P2="168,209"/><JD c="000000,6,1,0" P1="533,209" P2="632,209"/><JD c="000000,6,1,0" P1="267,263" P2="169,263"/><JD c="000000,6,1,0" P1="116.45,316.92" P2="116.45,389.92"/><JD c="000000,6,1,0" P1="686.05,316.92" P2="686.05,389.92"/><JD c="000000,6,1,0" P1="535,263" P2="632,263"/><JD c="000000,6,1,0" P1="215,157" P2="166,157"/><JD c="000000,6,1,0" P1="587,157" P2="636,157"/><JD c="000000,6,1,0" P1="113,131" P2="62,131"/><JD c="000000,6,1,0" P1="689,131" P2="740,131"/><JD c="000000,6,1,0" P1="113,261" P2="10,261"/><JD c="000000,6,1,0" P1="688,261" P2="787,261"/><JD c="000000,6,1,0" P1="113,79" P2="10,79"/><JD c="000000,6,1,0" P1="689,79" P2="788,79"/><JD c="1500fb,3,1,0" P1="324,312" P2="324,340"/><JD c="000000,6,1,0" P1="788,27" P2="788,391"/><JD c="1500fb,3,1,0" P1="478,312" P2="478,340"/><JD c="1500fb,3,1,0" P1="244,268" P2="244,340"/><JD c="1500fb,3,1,0" P1="121.45,339.92" P2="193.45,339.92"/><JD c="1500fb,3,1,0" P1="681.05,339.92" P2="609.05,339.92"/><JD c="1500fb,3,1,0" P1="558,268" P2="558,342"/><JD c="1500fb,3,1,0" P1="272,340" P2="244,340"/><JD c="1500fb,3,1,0" P1="193.45,311.92" P2="193.45,339.92"/><JD c="1500fb,3,1,0" P1="609.05,311.92" P2="609.05,339.92"/><JD c="1500fb,3,1,0" P1="530,342" P2="558,342"/><JD c="1500fb,3,1,0" P1="324,312" P2="478,312"/><JD c="1500fb,3,1,0" P1="324,340" P2="478,340"/><JD c="000000,3,1,0" P1="247,267" P2="267,267"/><JD c="000000,3,1,0" P1="326,31" P2="473,31"/><JD c="000000,3,1,0" P1="390,55" P2="410,55"/><JD c="000000,3,1,0" P1="120.45,336.92" P2="120.45,316.92"/><JD c="000000,3,1,0" P1="682.05,336.92" P2="682.05,316.92"/><JD c="000000,3,1,0" P1="555,267" P2="535,267"/><JD c="000000,3,1,0" P1="269,263" P2="269,288"/><JD c="000000,3,1,0" P1="404,29" P2="404,54"/><JD c="000000,3,1,0" P1="116.45,314.92" P2="141.45,314.92"/><JD c="000000,3,1,0" P1="686.05,314.92" P2="661.05,314.92"/><JD c="000000,3,1,0" P1="533,263" P2="533,288"/><JD c="000000,3,1,0" P1="247,265" P2="247,288"/><JD c="000000,3,1,0" P1="396,30" P2="396,53"/><JD c="000000,3,1,0" P1="474,31" P2="474,54"/><JD c="000000,3,1,0" P1="326,31" P2="326,54"/><JD c="000000,3,1,0" P1="118.45,336.92" P2="141.45,336.92"/><JD c="000000,3,1,0" P1="684.05,336.92" P2="661.05,336.92"/><JD c="000000,3,1,0" P1="555,265" P2="555,288"/></L></Z></C>]]}
pacmice_maps["pacmice_3"].pathes = {{1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}, {6, 1}, {7, 1}, {9, 1}, {10, 1}, {11, 1}, {19, 1}, {20, 1}, {21, 1}, {23, 1}, {24, 1}, {25, 1}, {26, 1}, {27, 1}, {28, 1}, {29, 1}, {5, 2}, {7, 2}, {9, 2}, {11, 2}, {12, 2}, {13, 2}, {14, 2}, {16, 2}, {17, 2}, {18, 2}, {19, 2}, {21, 2}, {23, 2}, {25, 2}, {1, 3}, {2, 3}, {3, 3}, {4, 3}, {5, 3}, {7, 3}, {9, 3}, {11, 3}, {19, 3}, {21, 3}, {23, 3}, {25, 3}, {26, 3}, {27, 3}, {28, 3}, {29, 3}, {1, 4}, {5, 4}, {7, 4}, {8, 4}, {9, 4}, {11, 4}, {12, 4}, {13, 4}, {14, 4}, {15, 4}, {16, 4}, {17, 4}, {18, 4}, {19, 4}, {21, 4}, {22, 4}, {23, 4}, {25, 4}, {29, 4}, {1, 5}, {3, 5}, {4, 5}, {5, 5}, {9, 5}, {15, 5}, {21, 5}, {25, 5}, {26, 5}, {27, 5}, {29, 5}, {1, 6}, {3, 6}, {5, 6}, {6, 6}, {7, 6}, {8, 6}, {9, 6}, {10, 6}, {11, 6}, {12, 6}, {13, 6}, {14, 6}, {15, 6}, {16, 6}, {17, 6}, {18, 6}, {19, 6}, {20, 6}, {21, 6}, {22, 6}, {23, 6}, {24, 6}, {25, 6}, {27, 6}, {29, 6}, {1, 7}, {3, 7}, {5, 7}, {11, 7}, {19, 7}, {25, 7}, {27, 7}, {29, 7}, {1, 8}, {2, 8}, {3, 8}, {5, 8}, {6, 8}, {7, 8}, {8, 8}, {9, 8}, {10, 8}, {11, 8}, {19, 8}, {20, 8}, {21, 8}, {22, 8}, {23, 8}, {24, 8}, {25, 8}, {27, 8}, {28, 8}, {29, 8}, {5, 9}, {11, 9}, {19, 9}, {25, 9}, {1, 10}, {2, 10}, {3, 10}, {4, 10}, {5, 10}, {6, 10}, {7, 10}, {8, 10}, {11, 10}, {12, 10}, {13, 10}, {14, 10}, {15, 10}, {16, 10}, {17, 10}, {18, 10}, {19, 10}, {22, 10}, {23, 10}, {24, 10}, {25, 10}, {26, 10}, {27, 10}, {28, 10}, {29, 10}, {1, 11}, {3, 11}, {8, 11}, {11, 11}, {19, 11}, {22, 11}, {27, 11}, {29, 11}, {1, 12}, {3, 12}, {8, 12}, {11, 12}, {19, 12}, {22, 12}, {27, 12}, {29, 12}, {1, 13}, {2, 13}, {3, 13}, {5, 13}, {6, 13}, {7, 13}, {8, 13}, {9, 13}, {10, 13}, {11, 13}, {12, 13}, {13, 13}, {14, 13}, {15, 13}, {16, 13}, {17, 13}, {18, 13}, {19, 13}, {20, 13}, {21, 13}, {22, 13}, {23, 13}, {24, 13}, {25, 13}, {27, 13}, {28, 13}, {29, 13}}
pacmice_maps["pacmice_3"].foods = {{x = 35, y = 53}, {x = 191, y = 130}, {x = 62, y = 235}, {x = 35, y = 364}, {x = 145, y = 364}, {x = 250, y = 235}, {x = 400, y = 189}, {x = 400, y = 364}, {x = 545, y = 235}, {x = 605, y = 130}, {x = 657, y = 364}, {x = 765, y = 364}, {x = 740, y = 235}, {x = 765, y = 53}}
-- map 4 (v5)
pacmice_maps["pacmice_4"] = {xml = "pacmice_4", background_color = "#010101", x = 10, y = 27, cell_w = 26, cell_h = 26, grid_w = 31, grid_h = 15, wall_size = 14, web_x = -100, pac_count = 1, axml = [[<C><P DS="m;258,58,545,58" MEDATA=";;;;-0;0::0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128:1-"/><Z><S><S T="12" X="190" Y="259" L="58" H="10" P="0,0,0.3,0.2,720,0,0,0"/><S T="12" X="610" Y="260" L="58" H="10" P="0,0,0.3,0.2,360,0,0,0"/><S T="12" X="788" Y="210" L="369" H="10" P="0,0,0.6,0.2,630,0,0,0"/><S T="12" X="400" Y="27" L="10" H="781" P="0,0,0.3,0.2,90,0,0,0"/><S T="12" X="400" Y="391" L="10" H="781" P="0,0,0.3,0.2,90,0,0,0"/><S T="12" X="10" Y="210" L="372" H="10" P="0,0,0.6,0.2,630,0,0,0"/><S T="12" X="166" Y="297" L="10" H="84" P="0,0,0.6,0.2,720,0,0,0"/><S T="12" X="218" Y="347" L="10" H="84" P="0,0,0.6,0.2,720,0,0,0"/><S T="12" X="582" Y="347" L="10" H="84" P="0,0,0.6,0.2,720,0,0,0"/><S T="12" X="634" Y="298" L="10" H="84" P="0,0,0.6,0.2,360,0,0,0"/><S T="12" X="401" Y="90" L="32" H="157" P="0,0,0.3,0.2,90,0,0,0"/><S T="12" X="400" Y="377" L="32" H="157" P="0,0,0.3,0.2,90,0,0,0"/><S T="12" X="258" Y="111" L="73" H="31" P="0,0,0.6,0.2,630,0,0,0"/><S T="12" X="157" Y="91" L="73" H="31" P="0,0,0.3,0.2,540,0,0,0"/><S T="12" X="645" Y="91" L="73" H="31" P="0,0,0.3,0.2,540,0,0,0"/><S T="12" X="544" Y="110" L="75" H="31" P="0,0,0.6,0.2,450,0,0,0"/><S T="12" X="114" Y="193" L="81" H="10" P="0,0,0.6,0.2,630,0,0,0"/><S T="12" X="687" Y="193" L="81" H="10" P="0,0,0.6,0.2,450,0,0,0"/><S T="12" X="62" Y="249" L="81" H="10" P="0,0,0.6,0.2,450,0,0,0"/><S T="12" X="739" Y="250" L="81" H="10" P="0,0,0.6,0.2,630,0,0,0"/><S T="12" X="738" Y="89" L="34" H="10" P="0,0,0.6,0.2,630,0,0,0"/><S T="12" X="62" Y="89" L="34" H="10" P="0,0,0.6,0.2,450,0,0,0"/><S T="12" X="285" Y="261" L="34" H="10" P="0,0,0.6,0.2,540,0,0,0"/><S T="12" X="518" Y="262" L="34" H="10" P="0,0,0.6,0.2,540,0,0,0"/><S T="12" X="400" Y="260" L="10" H="110" P="0,0,0.3,0.2,630,0,0,0"/><S T="12" X="271" Y="300" L="10" H="83" P="0,0,0.6,0.2,540,0,0,0"/><S T="12" X="530" Y="298" L="10" H="83" P="0,0,0.6,0.2,540,0,0,0"/><S T="12" X="219" Y="157" L="10" H="108" P="0,0,0.3,0.2,630,0,0,0"/><S T="12" X="115" Y="66" L="10" H="82" P="0,0,0.6,0.2,540,0,0,0"/><S T="12" X="687" Y="67" L="10" H="78" P="0,0,0.6,0.2,540,0,0,0"/><S T="12" X="582" Y="157" L="10" H="107" P="0,0,0.3,0.2,90,0,0,0"/><S T="12" X="217" Y="207" L="10" H="105" P="0,0,0.3,0.2,630,0,0,0"/><S T="12" X="583" Y="207" L="10" H="106" P="0,0,0.3,0.2,450,0,0,0"/><S T="12" X="66" Y="155" L="10" H="106" P="0,0,0.3,0.2,630,0,0,0"/><S T="12" X="733" Y="155" L="10" H="99" P="0,0,0.3,0.2,450,0,0,0"/><S T="12" X="89" Y="285" L="10" H="59" P="0,0,0.3,0.2,450,0,0,0"/><S T="12" X="713" Y="286" L="10" H="59" P="0,0,0.3,0.2,630,0,0,0"/><S T="12" X="65" Y="338" L="10" H="105" P="0,0,0.3,0.2,450,0,0,0"/><S T="12" X="738" Y="337" L="10" H="105" P="0,0,0.3,0.2,630,0,0,0"/><S T="12" X="400" Y="206" L="166" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="400" Y="312" L="162" H="10" P="0,0,0.3,0.2,540,0,0,0"/><S T="12" X="479" Y="181" L="10" H="49" P="0,0,0.6,0.2,0,0,0,0" v="90000"/><S T="12" X="323" Y="181" L="10" H="49" P="0,0,0.6,0.2,0,0,0,0" v="90000"/><S T="12" X="342" Y="158" L="47" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="459" Y="158" L="47" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="400" Y="158" L="67" H="10" P="0,0,0.3,0.2,0,0,0,0" v="90000"/><S T="12" X="400" Y="408" L="10" H="10" P="1,0,0.3,0.2,90,1,Infinity,0" c="4" v="85000"/><S T="12" X="400" Y="448" L="10" H="10" P="1,0,0.3,0.2,90,1,Infinity,0" c="4" v="85000"/><S T="12" X="400" Y="408" L="10" H="10" P="1,0,0.3,0.2,90,1,Infinity,0" c="4" v="86000"/><S T="12" X="400" Y="448" L="10" H="10" P="1,0,0.3,0.2,90,1,Infinity,0" c="4" v="86000"/><S T="12" X="400" Y="407" L="10" H="10" P="1,0,0.3,0.2,90,1,Infinity,0" c="4" v="87000"/><S T="12" X="400" Y="447" L="10" H="10" P="1,0,0.3,0.2,90,1,Infinity,0" c="4" v="87000"/><S T="12" X="400" Y="408" L="10" H="10" P="1,0,0.3,0.2,90,1,Infinity,0" c="4" v="88000"/><S T="12" X="400" Y="448" L="10" H="10" P="1,0,0.3,0.2,90,1,Infinity,0" c="4" v="88000"/><S T="12" X="400" Y="408" L="10" H="10" P="1,0,0.3,0.2,90,1,Infinity,0" c="4" v="89000"/><S T="12" X="400" Y="448" L="10" H="10" P="1,0,0.3,0.2,90,1,Infinity,0" c="4" v="89000"/><S T="12" X="400" Y="408" L="10" H="10" P="1,0,0.3,0.2,90,1,Infinity,0" c="4" v="90000"/><S T="12" X="400" Y="448" L="10" H="10" P="1,0,0.3,0.2,90,1,Infinity,0" c="4" v="90000"/></S><D><F X="352" Y="195" D=""/><F X="452" Y="195" D=""/><T X="402" Y="201" D=""/></D><O/><L><JD c="1500fb,10,1,0" P1="788,391" P2="788,27"/><JD c="1500fb,10,1,0" P1="10,391" P2="10,27"/><JD c="1500fb,10,1,0" P1="787,27" P2="12,27"/><JD c="1500fb,10,1,0" P1="787,391" P2="12,391"/><JD c="1500fb,10,1,0" P1="477,312" P2="324,312"/><JD c="FFFFFF,10,1,0" M1="56" M2="56" P1="431,159" P2="373,159"/><JD c="1500fb,10,1,0" M1="54" M2="54" P1="431,159" P2="373,159"/><JD c="FFFFFF,10,1,0" M1="52" M2="52" P1="431,159" P2="373,159"/><JD c="1500fb,10,1,0" M1="50" M2="50" P1="431,159" P2="373,159"/><JD c="FFFFFF,10,1,0" M1="48" M2="48" P1="431,159" P2="373,159"/><JD c="1500fb,10,1,0" M1="46" M2="46" P1="431,159" P2="373,159"/><JD c="1500fb,10,1,0" P1="738,102" P2="738,77"/><JD c="1500fb,10,1,0" P1="62,102" P2="62,77"/><JD c="1500fb,10,1,0" P1="272,261" P2="297,261"/><JD c="1500fb,10,1,0" P1="505,262" P2="530,262"/><JD c="1500fb,10,1,0" P1="480,207" P2="324,207"/><JD c="1500fb,10,1,0" P1="271,337" P2="271,261"/><JD c="1500fb,10,1,0" P1="530,335" P2="530,263"/><JD c="1500fb,10,1,0" P1="166,334" P2="166,261"/><JD c="1500fb,10,1,0" P1="218,388" P2="218,311"/><JD c="1500fb,10,1,0" P1="582,388" P2="582,311"/><JD c="1500fb,10,1,0" P1="634,335" P2="634,262"/><JD c="1500fb,10,1,0" P1="114,230" P2="114,156"/><JD c="1500fb,10,1,0" P1="687,230" P2="687,156"/><JD c="1500fb,10,1,0" P1="62,285" P2="62,212"/><JD c="1500fb,10,1,0" P1="739,286" P2="739,213"/><JD c="1500fb,10,1,0" P1="363,159" P2="324,159"/><JD c="1500fb,10,1,0" P1="441,159" P2="480,159"/><JD c="FFFFFF,10,1,0" M1="57" M2="57" P1="480,159" P2="480,206"/><JD c="FFFFFF,10,1,0" M1="57" M2="57" P1="323,159" P2="323,206"/><JD c="1500fb,10,1,0" M1="55" M2="55" P1="480,159" P2="480,206"/><JD c="1500fb,10,1,0" M1="55" M2="55" P1="323,159" P2="323,206"/><JD c="FFFFFF,10,1,0" M1="53" M2="53" P1="480,159" P2="480,206"/><JD c="FFFFFF,10,1,0" M1="53" M2="53" P1="323,159" P2="323,206"/><JD c="1500fb,10,1,0" M1="51" M2="51" P1="480,159" P2="480,206"/><JD c="1500fb,10,1,0" M1="51" M2="51" P1="323,159" P2="323,206"/><JD c="FFFFFF,10,1,0" M1="49" M2="49" P1="480,159" P2="480,206"/><JD c="FFFFFF,10,1,0" M1="49" M2="49" P1="323,159" P2="323,206"/><JD c="1500fb,10,1,0" M1="47" M2="47" P1="480,159" P2="480,206"/><JD c="1500fb,10,1,0" M1="47" M2="47" P1="323,159" P2="323,206"/><JD c="1500fb,10,1,0" P1="450,260" P2="349,260"/><JD c="1500fb,10,1,0" P1="266,207" P2="168,207"/><JD c="1500fb,3,1,0" P1="323,390" P2="323,363"/><JD c="1500fb,10,1,0" P1="533,207" P2="632,207"/><JD c="1500fb,10,1,0" P1="268,157" P2="169,157"/><JD c="1500fb,3,1,0" P1="477,390" P2="477,363"/><JD c="1500fb,10,1,0" P1="115.45,102.08" P2="115.45,27.08"/><JD c="1500fb,10,1,0" P1="687.05,102.08" P2="687.05,27.08"/><JD c="1500fb,10,1,0" P1="534,157" P2="632,157"/><JD c="1500fb,10,1,0" P1="215,259" P2="166,259"/><JD c="1500fb,10,1,0" P1="585,260" P2="634,260"/><JD c="1500fb,10,1,0" P1="113,285" P2="62,285"/><JD c="1500fb,10,1,0" P1="688,286" P2="739,286"/><JD c="1500fb,10,1,0" P1="113,155" P2="10,155"/><JD c="1500fb,10,1,0" P1="688,155" P2="787,155"/><JD c="1500fb,10,1,0" P1="113,338" P2="10,338"/><JD c="1500fb,10,1,0" P1="689,337" P2="788,337"/><JD c="1500fb,3,1,0" P1="323,363" P2="477,363"/><JD c="000000,6,1,0" P1="787,27" P2="12,27"/><JD c="000000,6,1,0" P1="787,391" P2="12,391"/><JD c="000000,6,1,0" P1="477,312" P2="324,312"/><JD c="000000,6,1,0" M1="56" M2="56" P1="431,159" P2="373,159"/><JD c="000000,6,1,0" P1="738,102" P2="738,77"/><JD c="000000,6,1,0" P1="62,102" P2="62,77"/><JD c="000000,6,1,0" P1="272,261" P2="297,261"/><JD c="000000,6,1,0" P1="505,262" P2="530,262"/><JD c="1500fb,3,1,0" P1="272,158" P2="272,75"/><JD c="1500fb,3,1,0" P1="113.45,105.08" P2="192.45,105.08"/><JD c="1500fb,3,1,0" P1="689.05,105.08" P2="610.05,105.08"/><JD c="1500fb,3,1,0" P1="530,156" P2="530,74"/><JD c="000000,6,1,0" P1="10,391" P2="10,27"/><JD c="000000,6,1,0" P1="480,207" P2="324,207"/><JD c="000000,6,1,0" P1="271,337" P2="271,261"/><JD c="000000,6,1,0" P1="530,335" P2="530,263"/><JD c="000000,6,1,0" P1="166,334" P2="166,261"/><JD c="000000,6,1,0" P1="218,388" P2="218,311"/><JD c="000000,6,1,0" P1="582,388" P2="582,311"/><JD c="000000,6,1,0" P1="634,335" P2="634,262"/><JD c="000000,6,1,0" P1="114,230" P2="114,156"/><JD c="000000,6,1,0" P1="687,230" P2="687,156"/><JD c="000000,6,1,0" P1="62,285" P2="62,212"/><JD c="000000,6,1,0" P1="739,286" P2="739,213"/><JD c="000000,6,1,0" P1="363,159" P2="324,159"/><JD c="000000,6,1,0" P1="441,159" P2="480,159"/><JD c="000000,6,1,0" M1="57" M2="57" P1="480,159" P2="480,206"/><JD c="000000,6,1,0" M1="57" M2="57" P1="323,159" P2="323,206"/><JD c="000000,6,1,0" P1="450,260" P2="349,260"/><JD c="000000,6,1,0" P1="266,207" P2="168,207"/><JD c="000000,6,1,0" P1="533,207" P2="632,207"/><JD c="000000,6,1,0" P1="268,157" P2="169,157"/><JD c="000000,6,1,0" P1="115.45,100.08" P2="115.45,27.08"/><JD c="000000,6,1,0" P1="687.05,100.08" P2="687.05,27.08"/><JD c="000000,6,1,0" P1="535,157" P2="632,157"/><JD c="000000,6,1,0" P1="215,259" P2="166,259"/><JD c="000000,6,1,0" P1="585,260" P2="634,260"/><JD c="000000,6,1,0" P1="113,285" P2="62,285"/><JD c="000000,6,1,0" P1="688,286" P2="739,286"/><JD c="000000,6,1,0" P1="113,155" P2="10,155"/><JD c="000000,6,1,0" P1="688,155" P2="787,155"/><JD c="000000,6,1,0" P1="113,338" P2="10,338"/><JD c="000000,6,1,0" P1="689,337" P2="788,337"/><JD c="1500fb,3,1,0" P1="324,104" P2="324,76"/><JD c="000000,6,1,0" P1="788,391" P2="788,27"/><JD c="1500fb,3,1,0" P1="478,104" P2="478,76"/><JD c="1500fb,3,1,0" P1="244,152" P2="244,76"/><JD c="1500fb,3,1,0" P1="120.45,77.08" P2="192.45,77.08"/><JD c="1500fb,3,1,0" P1="682.05,77.08" P2="610.05,77.08"/><JD c="1500fb,3,1,0" P1="558,152" P2="558,74"/><JD c="1500fb,3,1,0" P1="272,76" P2="244,76"/><JD c="1500fb,3,1,0" P1="192.45,105.08" P2="192.45,77.08"/><JD c="1500fb,3,1,0" P1="610.05,105.08" P2="610.05,77.08"/><JD c="1500fb,3,1,0" P1="530,74" P2="558,74"/><JD c="1500fb,3,1,0" P1="324,104" P2="478,104"/><JD c="1500fb,3,1,0" P1="324,76" P2="478,76"/><JD c="000000,3,1,0" P1="247,153" P2="267,153"/><JD c="000000,3,1,0" P1="326,387" P2="474,387"/><JD c="000000,3,1,0" P1="119.45,80.08" P2="119.45,100.08"/><JD c="000000,3,1,0" P1="683.05,80.08" P2="683.05,100.08"/><JD c="000000,3,1,0" P1="555,153" P2="535,153"/><JD c="000000,3,1,0" P1="269,157" P2="269,132"/><JD c="000000,3,1,0" P1="474,391" P2="474,368"/><JD c="000000,3,1,0" P1="115.45,102.08" P2="140.45,102.08"/><JD c="000000,3,1,0" P1="687.05,102.08" P2="662.05,102.08"/><JD c="000000,3,1,0" P1="533,157" P2="533,132"/><JD c="000000,3,1,0" P1="247,155" P2="247,132"/><JD c="000000,3,1,0" P1="326,389" P2="326,368"/><JD c="000000,3,1,0" P1="117.45,80.08" P2="140.45,80.08"/><JD c="000000,3,1,0" P1="685.05,80.08" P2="662.05,80.08"/><JD c="000000,3,1,0" P1="555,155" P2="555,132"/></L></Z></C>]]}
pacmice_maps["pacmice_4"].pathes = {{1, 1}, {2, 1}, {3, 1}, {5, 1}, {6, 1}, {7, 1}, {8, 1}, {9, 1}, {10, 1}, {11, 1}, {12, 1}, {13, 1}, {14, 1}, {15, 1}, {16, 1}, {17, 1}, {18, 1}, {19, 1}, {20, 1}, {21, 1}, {22, 1}, {23, 1}, {24, 1}, {25, 1}, {27, 1}, {28, 1}, {29, 1}, {1, 2}, {3, 2}, {8, 2}, {11, 2}, {19, 2}, {22, 2}, {27, 2}, {29, 2}, {1, 3}, {3, 3}, {8, 3}, {11, 3}, {19, 3}, {22, 3}, {27, 3}, {29, 3}, {1, 4}, {2, 4}, {3, 4}, {4, 4}, {5, 4}, {6, 4}, {7, 4}, {8, 4}, {11, 4}, {12, 4}, {13, 4}, {14, 4}, {15, 4}, {16, 4}, {17, 4}, {18, 4}, {19, 4}, {22, 4}, {23, 4}, {24, 4}, {25, 4}, {26, 4}, {27, 4}, {28, 4}, {29, 4}, {5, 5}, {11, 5}, {19, 5}, {25, 5}, {1, 6}, {2, 6}, {3, 6}, {5, 6}, {6, 6}, {7, 6}, {8, 6}, {9, 6}, {10, 6}, {11, 6}, {19, 6}, {20, 6}, {21, 6}, {22, 6}, {23, 6}, {24, 6}, {25, 6}, {27, 6}, {28, 6}, {29, 6}, {1, 7}, {3, 7}, {5, 7}, {11, 7}, {19, 7}, {25, 7}, {27, 7}, {29, 7}, {1, 8}, {3, 8}, {5, 8}, {6, 8}, {7, 8}, {8, 8}, {9, 8}, {10, 8}, {11, 8}, {12, 8}, {13, 8}, {14, 8}, {15, 8}, {16, 8}, {17, 8}, {18, 8}, {19, 8}, {20, 8}, {21, 8}, {22, 8}, {23, 8}, {24, 8}, {25, 8}, {27, 8}, {29, 8}, {1, 9}, {3, 9}, {4, 9}, {5, 9}, {9, 9}, {12, 9}, {18, 9}, {21, 9}, {25, 9}, {26, 9}, {27, 9}, {29, 9}, {1, 10}, {5, 10}, {7, 10}, {8, 10}, {9, 10}, {11, 10}, {12, 10}, {13, 10}, {14, 10}, {15, 10}, {16, 10}, {17, 10}, {18, 10}, {19, 10}, {21, 10}, {22, 10}, {23, 10}, {25, 10}, {29, 10}, {1, 11}, {2, 11}, {3, 11}, {4, 11}, {5, 11}, {7, 11}, {9, 11}, {11, 11}, {19, 11}, {21, 11}, {23, 11}, {25, 11}, {26, 11}, {27, 11}, {28, 11}, {29, 11}, {5, 12}, {7, 12}, {9, 12}, {11, 12}, {12, 12}, {13, 12}, {14, 12}, {15, 12}, {16, 12}, {17, 12}, {18, 12}, {19, 12}, {21, 12}, {23, 12}, {25, 12}, {1, 13}, {2, 13}, {3, 13}, {4, 13}, {5, 13}, {6, 13}, {7, 13}, {9, 13}, {10, 13}, {11, 13}, {19, 13}, {20, 13}, {21, 13}, {23, 13}, {24, 13}, {25, 13}, {26, 13}, {27, 13}, {28, 13}, {29, 13}}
pacmice_maps["pacmice_4"].foods = {{x = 60, y = 55}, {x = 400, y = 55}, {x = 735, y = 55}, {x = 400, y = 130}, {x = 218, y = 182}, {x = 579, y = 182}, {x = 35, y = 240}, {x = 400, y = 240}, {x = 763, y = 240}, {x = 195, y = 285}, {x = 605, y = 285}, {x = 35, y = 365}, {x = 400, y = 335}, {x = 763, y = 365}}
-- (v3) (first multi)
pacmice_maps["pacmice_5"] = {xml = "pacmice_5", background_color = "#010101", x = 10, y = 35, cell_w = 26, cell_h = 26, grid_w = 31, grid_h = 24, wall_size = 14, web_x = -100, pac_count = 2, axml = [[<C><P H="640" DS="m;205,120,595,120" MEDATA=";;;;-0;0::0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226:1-"/><Z><S><S T="12" X="191" Y="191" L="58" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="612" Y="191" L="58" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="190" Y="477" L="58" H="10" P="0,0,0.3,0.2,180,0,0,0"/><S T="12" X="612" Y="477" L="58" H="10" P="0,0,0.3,0.2,-180,0,0,0"/><S T="12" X="788" Y="334" L="605" H="10" P="0,0,0.7,0.2,90,0,0,0"/><S T="12" X="400" Y="35" L="10" H="781" P="0,0,0.3,0.2,90,0,0,0"/><S T="12" X="686" Y="634" L="10" H="213" P="0,0,0.3,0.2,90,0,0,0"/><S T="12" X="294" Y="634" L="10" H="574" P="0,0,0.3,0.2,90,0,0,0"/><S T="12" X="10" Y="334" L="608" H="10" P="0,0,0.7,0.2,90,0,0,0"/><S T="12" X="166" Y="229" L="10" H="84" P="0,0,0.7,0.2,0,0,0,0"/><S T="12" X="636" Y="229" L="10" H="84" P="0,0,0.7,0.2,0,0,0,0"/><S T="12" X="166" Y="439" L="10" H="84" P="0,0,0.7,0.2,180,0,0,0"/><S T="12" X="636" Y="439" L="10" H="84" P="0,0,0.7,0.2,-180,0,0,0"/><S T="12" X="243" Y="334" L="30" H="55" P="0,0,0.3,0.2,450,0,0,0"/><S T="12" X="334" Y="364" L="30" H="32" P="0,0,0.3,0.2,450,0,0,0"/><S T="12" X="465" Y="364" L="30" H="32" P="0,0,0.3,0.2,450,0,0,0"/><S T="12" X="558" Y="334" L="30" H="55" P="0,0,0.3,0.2,-450,0,0,0"/><S T="12" X="114" Y="334" L="32" H="107" P="0,0,0.3,0.2,450,0,0,0"/><S T="12" X="686" Y="334" L="32" H="107" P="0,0,0.3,0.2,-450,0,0,0"/><S T="12" X="309" Y="117" L="50" H="31" P="0,0,0.7,0.2,90,0,0,0"/><S T="12" X="493" Y="117" L="50" H="31" P="0,0,0.7,0.2,-90,0,0,0"/><S T="12" X="308" Y="553" L="50" H="31" P="0,0,0.7,0.2,90,0,0,0"/><S T="12" X="491" Y="554" L="50" H="31" P="0,0,0.7,0.2,-90,0,0,0"/><S T="12" X="181" Y="62" L="50" H="35" P="0,0,0.7,0.2,90,0,0,0"/><S T="12" X="621" Y="62" L="50" H="35" P="0,0,0.7,0.2,-90,0,0,0"/><S T="12" X="180" Y="606" L="50" H="35" P="0,0,0.7,0.2,90,0,0,0"/><S T="12" X="621" Y="606" L="50" H="35" P="0,0,0.7,0.2,-90,0,0,0"/><S T="12" X="115" Y="125" L="81" H="10" P="0,0,0.7,0.2,90,0,0,0"/><S T="12" X="687" Y="125" L="81" H="10" P="0,0,0.7,0.2,-90,0,0,0"/><S T="12" X="115" Y="543" L="81" H="10" P="0,0,0.7,0.2,90,0,0,0"/><S T="12" X="687" Y="543" L="81" H="10" P="0,0,0.7,0.2,-90,0,0,0"/><S T="12" X="62" Y="181" L="81" H="10" P="0,0,0.7,0.2,270,0,0,0"/><S T="12" X="740" Y="181" L="81" H="10" P="0,0,0.7,0.2,-270,0,0,0"/><S T="12" X="62" Y="487" L="81" H="10" P="0,0,0.7,0.2,-90,0,0,0"/><S T="12" X="740" Y="487" L="81" H="10" P="0,0,0.7,0.2,90,0,0,0"/><S T="12" X="400" Y="51" L="23" H="60" P="0,0,0.3,0.2,90,0,0,0"/><S T="12" X="400" Y="617" L="23" H="60" P="0,0,0.3,0.2,90,0,0,0"/><S T="12" X="375" Y="154" L="81" H="10" P="0,0,0.7,0.2,90,0,0,0"/><S T="12" X="426" Y="154" L="81" H="10" P="0,0,0.7,0.2,-90,0,0,0"/><S T="12" X="374" Y="519" L="85" H="10" P="0,0,0.7,0.2,90,0,0,0"/><S T="12" X="426" Y="518" L="89" H="10" P="0,0,0.7,0.2,-90,0,0,0"/><S T="12" X="326" Y="191" L="10" H="107" P="0,0,0.3,0.2,90,0,0,0"/><S T="12" X="477" Y="191" L="10" H="107" P="0,0,0.3,0.2,-90,0,0,0"/><S T="12" X="320" Y="480" L="10" H="107" P="0,0,0.3,0.2,90,0,0,0"/><S T="12" X="477" Y="477" L="10" H="108" P="0,0,0.3,0.2,-90,0,0,0"/><S T="12" X="219" Y="334" L="10" H="183" P="0,0,0.7,0.2,180,0,0,0"/><S T="12" X="582" Y="334" L="10" H="183" P="0,0,0.7,0.2,-180,0,0,0"/><S T="12" X="272" Y="227" L="10" H="83" P="0,0,0.7,0.2,180,0,0,0"/><S T="12" X="530" Y="228" L="10" H="83" P="0,0,0.3,0.2,-180,0,0,0"/><S T="12" X="271" Y="440" L="10" H="83" P="0,0,0.7,0.2,0,0,0,0"/><S T="12" X="400" Y="390" L="10" H="83" P="0,0,0.7,0.2,0,0,0,0"/><S T="12" X="530" Y="440" L="10" H="83" P="0,0,0.7,0.2,0,0,0,0"/><S T="12" X="284" Y="87" L="10" H="83" P="0,0,0.3,0.2,90,0,0,0"/><S T="12" X="519" Y="87" L="10" H="83" P="0,0,0.3,0.2,-90,0,0,0"/><S T="12" X="283" Y="583" L="10" H="83" P="0,0,0.3,0.2,90,0,0,0"/><S T="12" X="517" Y="584" L="10" H="83" P="0,0,0.3,0.2,-90,0,0,0"/><S T="12" X="205" Y="139" L="10" H="80" P="0,0,0.3,0.2,90,0,0,0"/><S T="12" X="597" Y="139" L="10" H="80" P="0,0,0.3,0.2,-90,0,0,0"/><S T="12" X="205" Y="529" L="10" H="80" P="0,0,0.3,0.2,90,0,0,0"/><S T="12" X="597" Y="529" L="10" H="80" P="0,0,0.3,0.2,-90,0,0,0"/><S T="12" X="89" Y="87" L="10" H="60" P="0,0,0.3,0.2,90,0,0,0"/><S T="12" X="713" Y="87" L="10" H="60" P="0,0,0.3,0.2,-90,0,0,0"/><S T="12" X="90" Y="581" L="10" H="60" P="0,0,0.3,0.2,90,0,0,0"/><S T="12" X="713" Y="581" L="10" H="60" P="0,0,0.3,0.2,-90,0,0,0"/><S T="12" X="88" Y="217" L="10" H="59" P="0,0,0.3,0.2,270,0,0,0"/><S T="12" X="714" Y="217" L="10" H="59" P="0,0,0.3,0.2,-270,0,0,0"/><S T="12" X="89" Y="451" L="10" H="59" P="0,0,0.3,0.2,-90,0,0,0"/><S T="12" X="714" Y="451" L="10" H="59" P="0,0,0.3,0.2,90,0,0,0"/><S T="12" X="65" Y="269" L="10" H="105" P="0,0,0.3,0.2,270,0,0,0"/><S T="12" X="738" Y="269" L="10" H="105" P="0,0,0.3,0.2,-270,0,0,0"/><S T="12" X="65" Y="399" L="10" H="105" P="0,0,0.3,0.2,-90,0,0,0"/><S T="12" X="738" Y="399" L="10" H="105" P="0,0,0.3,0.2,90,0,0,0"/><S T="12" X="400" Y="297" L="166" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="400" Y="428" L="162" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="342" Y="249" L="47" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="459" Y="249" L="47" H="10" P="0,0,0.3,0.2,0,0,0,0"/><S T="12" X="401" Y="249" L="67" H="10" P="0,0,0.3,0.2,0,0,0,0" v="90000"/><S T="12" X="478" Y="273" L="56" H="10" P="0,0,0.3,0.2,90,0,0,0" v="90000"/><S T="12" X="322" Y="273" L="56" H="10" P="0,0,0.3,0.2,90,0,0,0" v="90000"/><S T="12" X="400" Y="650" L="10" H="10" P="1,0,0.3,0.2,90,1,Infinity,0" c="4" v="90000"/><S T="12" X="400" Y="650" L="10" H="10" P="1,0,0.3,0.2,90,1,Infinity,0" c="4" v="89000"/><S T="12" X="400" Y="650" L="10" H="10" P="1,0,0.3,0.2,90,1,Infinity,0" c="4" v="88000"/><S T="12" X="400" Y="650" L="10" H="10" P="1,0,0.3,0.2,90,1,Infinity,0" c="4" v="87000"/><S T="12" X="400" Y="650" L="10" H="10" P="1,0,0.3,0.2,90,1,Infinity,0" c="4" v="86000"/><S T="12" X="400" Y="650" L="10" H="10" P="1,0,0.3,0.2,90,1,Infinity,0" c="4" v="85000"/></S><D><F X="351" Y="285" D=""/><F X="450" Y="284" D=""/><T X="399" Y="291" D=""/></D><O/><L><JD c="1500fb,10,1,0" P1="788,35" P2="788,633"/><JD c="1500fb,10,1,0" P1="10,35" P2="10,633"/><JD c="1500fb,10,1,0" P1="787,35" P2="12,35"/><JD c="1500fb,10,1,0" P1="788,633" P2="13,633"/><JD c="1500fb,10,1,0" P1="478,428" P2="323,428"/><JD c="1500fb,10,1,0" P1="400,353" P2="400,426"/><JD c="FFFFFF,10,1,0" M1="79" M2="79" P1="429,249" P2="371,249"/><JD c="FFFFFF,10,1,0" M1="79" M2="79" P1="478,296" P2="478,250"/><JD c="FFFFFF,10,1,0" M1="79" M2="79" P1="322,296" P2="322,250"/><JD c="1500fb,10,1,0" M1="80" M2="80" P1="429,249" P2="371,249"/><JD c="1500fb,10,1,0" M1="80" M2="80" P1="478,296" P2="478,250"/><JD c="1500fb,10,1,0" M1="80" M2="80" P1="322,296" P2="322,250"/><JD c="FFFFFF,10,1,0" M1="81" M2="81" P1="429,249" P2="371,249"/><JD c="FFFFFF,10,1,0" M1="81" M2="81" P1="478,296" P2="478,250"/><JD c="FFFFFF,10,1,0" M1="81" M2="81" P1="322,296" P2="322,250"/><JD c="1500fb,10,1,0" M1="82" M2="82" P1="429,249" P2="371,249"/><JD c="1500fb,10,1,0" M1="82" M2="82" P1="478,296" P2="478,250"/><JD c="1500fb,10,1,0" M1="82" M2="82" P1="322,296" P2="322,250"/><JD c="FFFFFF,10,1,0" M1="83" M2="83" P1="429,249" P2="371,249"/><JD c="FFFFFF,10,1,0" M1="83" M2="83" P1="478,296" P2="478,250"/><JD c="FFFFFF,10,1,0" M1="83" M2="83" P1="322,296" P2="322,250"/><JD c="1500fb,10,1,0" M1="84" M2="84" P1="429,249" P2="371,249"/><JD c="1500fb,10,1,0" M1="84" M2="84" P1="478,296" P2="478,250"/><JD c="1500fb,10,1,0" M1="84" M2="84" P1="322,296" P2="322,250"/><JD c="1500fb,10,1,0" P1="375,189" P2="375,118"/><JD c="1500fb,10,1,0" P1="426,189" P2="426,118"/><JD c="1500fb,10,1,0" P1="374,480" P2="374,559"/><JD c="1500fb,10,1,0" P1="426,478" P2="426,559"/><JD c="1500fb,10,1,0" P1="272,265" P2="272,193"/><JD c="1500fb,10,1,0" P1="530,265" P2="530,193"/><JD c="1500fb,10,1,0" P1="219,422" P2="219,246"/><JD c="1500fb,10,1,0" P1="582,422" P2="582,246"/><JD c="1500fb,10,1,0" P1="478,297" P2="322,297"/><JD c="1500fb,10,1,0" P1="271,403" P2="271,479"/><JD c="1500fb,10,1,0" P1="530,403" P2="530,475"/><JD c="1500fb,10,1,0" P1="166,266" P2="166,193"/><JD c="1500fb,10,1,0" P1="636,266" P2="636,193"/><JD c="1500fb,10,1,0" P1="166,402" P2="166,475"/><JD c="1500fb,10,1,0" P1="636,402" P2="636,475"/><JD c="1500fb,10,1,0" P1="115,162" P2="115,88"/><JD c="1500fb,10,1,0" P1="687,162" P2="687,88"/><JD c="1500fb,10,1,0" P1="115,506" P2="115,580"/><JD c="1500fb,10,1,0" P1="687,506" P2="687,580"/><JD c="1500fb,10,1,0" P1="62,217" P2="62,144"/><JD c="1500fb,10,1,0" P1="740,217" P2="740,144"/><JD c="1500fb,10,1,0" P1="62,451" P2="62,524"/><JD c="1500fb,10,1,0" P1="740,451" P2="740,524"/><JD c="1500fb,10,1,0" P1="361,249" P2="322,249"/><JD c="1500fb,10,1,0" P1="439,249" P2="478,249"/><JD c="1500fb,10,1,0" P1="375,191" P2="272,191"/><JD c="1500fb,10,1,0" P1="427,191" P2="530,191"/><JD c="1500fb,10,1,0" P1="374,480" P2="271,480"/><JD c="1500fb,10,1,0" P1="426,477" P2="530,477"/><JD c="1500fb,10,1,0" P1="241,139" P2="169,139"/><JD c="1500fb,10,1,0" P1="561,139" P2="633,139"/><JD c="1500fb,10,1,0" P1="241,529" P2="169,529"/><JD c="1500fb,10,1,0" P1="561,529" P2="633,529"/><JD c="1500fb,10,1,0" P1="320,87" P2="247,87"/><JD c="1500fb,10,1,0" P1="483,87" P2="555,87"/><JD c="1500fb,10,1,0" P1="319,583" P2="246,583"/><JD c="1500fb,10,1,0" P1="481,584" P2="552,584"/><JD c="1500fb,10,1,0" P1="215,191" P2="166,191"/><JD c="1500fb,10,1,0" P1="587,191" P2="636,191"/><JD c="1500fb,10,1,0" P1="215,477" P2="166,477"/><JD c="1500fb,10,1,0" P1="587,477" P2="636,477"/><JD c="1500fb,10,1,0" P1="113,217" P2="62,217"/><JD c="1500fb,10,1,0" P1="689,217" P2="740,217"/><JD c="1500fb,10,1,0" P1="113,451" P2="62,451"/><JD c="1500fb,10,1,0" P1="689,451" P2="740,451"/><JD c="1500fb,10,1,0" P1="114,87" P2="63,87"/><JD c="1500fb,10,1,0" P1="688,87" P2="739,87"/><JD c="1500fb,10,1,0" P1="114,581" P2="63,581"/><JD c="1500fb,10,1,0" P1="688,581" P2="739,581"/><JD c="1500fb,10,1,0" P1="113,269" P2="10,269"/><JD c="1500fb,10,1,0" P1="689,269" P2="788,269"/><JD c="1500fb,10,1,0" P1="113,399" P2="10,399"/><JD c="1500fb,10,1,0" P1="689,399" P2="788,399"/><JD c="000000,6,1,0" P1="787,35" P2="12,35"/><JD c="000000,6,1,0" P1="788,633" P2="13,633"/><JD c="000000,6,1,0" P1="478,428" P2="323,428"/><JD c="000000,6,1,0" P1="400,353" P2="400,426"/><JD c="000000,6,1,0" M1="79" M2="79" P1="429,249" P2="371,249"/><JD c="000000,6,1,0" M1="79" M2="79" P1="478,296" P2="478,250"/><JD c="000000,6,1,0" M1="79" M2="79" P1="322,296" P2="322,250"/><JD c="000000,6,1,0" P1="375,189" P2="375,118"/><JD c="000000,6,1,0" P1="426,189" P2="426,118"/><JD c="000000,6,1,0" P1="374,480" P2="374,559"/><JD c="000000,6,1,0" P1="426,478" P2="426,559"/><JD c="1500fb,3,1,0" P1="323,85" P2="323,141"/><JD c="1500fb,3,1,0" P1="479,85" P2="479,141"/><JD c="000000,6,1,0" P1="10,35" P2="10,633"/><JD c="1500fb,3,1,0" P1="322,585" P2="322,529"/><JD c="1500fb,3,1,0" P1="477,586" P2="477,530"/><JD c="1500fb,3,1,0" P1="197,40" P2="197,86"/><JD c="1500fb,3,1,0" P1="605,40" P2="605,86"/><JD c="1500fb,3,1,0" P1="196,628" P2="196,582"/><JD c="1500fb,3,1,0" P1="605,628" P2="605,582"/><JD c="000000,6,1,0" P1="272,265" P2="272,193"/><JD c="000000,6,1,0" P1="530,265" P2="530,193"/><JD c="000000,6,1,0" P1="219,422" P2="219,246"/><JD c="000000,6,1,0" P1="582,422" P2="582,246"/><JD c="000000,6,1,0" P1="478,297" P2="322,297"/><JD c="000000,6,1,0" P1="271,403" P2="271,479"/><JD c="000000,6,1,0" P1="530,403" P2="530,475"/><JD c="000000,6,1,0" P1="166,266" P2="166,193"/><JD c="000000,6,1,0" P1="636,266" P2="636,193"/><JD c="000000,6,1,0" P1="166,402" P2="166,475"/><JD c="000000,6,1,0" P1="636,402" P2="636,475"/><JD c="000000,6,1,0" P1="115,162" P2="115,88"/><JD c="000000,6,1,0" P1="687,162" P2="687,88"/><JD c="000000,6,1,0" P1="115,506" P2="115,580"/><JD c="000000,6,1,0" P1="687,506" P2="687,580"/><JD c="000000,6,1,0" P1="62,217" P2="62,144"/><JD c="000000,6,1,0" P1="740,217" P2="740,144"/><JD c="000000,6,1,0" P1="62,451" P2="62,524"/><JD c="000000,6,1,0" P1="740,451" P2="740,524"/><JD c="000000,6,1,0" P1="361,249" P2="322,249"/><JD c="000000,6,1,0" P1="439,249" P2="478,249"/><JD c="000000,6,1,0" P1="375,191" P2="272,191"/><JD c="000000,6,1,0" P1="427,191" P2="530,191"/><JD c="000000,6,1,0" P1="374,480" P2="271,480"/><JD c="000000,6,1,0" P1="426,477" P2="530,477"/><JD c="000000,6,1,0" P1="241,139" P2="169,139"/><JD c="000000,6,1,0" P1="561,139" P2="633,139"/><JD c="000000,6,1,0" P1="241,529" P2="169,529"/><JD c="000000,6,1,0" P1="561,529" P2="633,529"/><JD c="000000,6,1,0" P1="318,87" P2="247,87"/><JD c="000000,6,1,0" P1="484,87" P2="555,87"/><JD c="000000,6,1,0" P1="318,583" P2="246,583"/><JD c="000000,6,1,0" P1="482,584" P2="551.57,584"/><JD c="000000,6,1,0" P1="215,191" P2="166,191"/><JD c="000000,6,1,0" P1="587,191" P2="636,191"/><JD c="000000,6,1,0" P1="215,477" P2="166,477"/><JD c="000000,6,1,0" P1="587,477" P2="636,477"/><JD c="000000,6,1,0" P1="113,217" P2="62,217"/><JD c="000000,6,1,0" P1="689,217" P2="740,217"/><JD c="000000,6,1,0" P1="113,451" P2="62,451"/><JD c="000000,6,1,0" P1="689,451" P2="740,451"/><JD c="000000,6,1,0" P1="114,87" P2="63,87"/><JD c="000000,6,1,0" P1="688,87" P2="739,87"/><JD c="000000,6,1,0" P1="114,581" P2="63,581"/><JD c="000000,6,1,0" P1="688,581" P2="739,581"/><JD c="000000,6,1,0" P1="113,269" P2="10,269"/><JD c="000000,6,1,0" P1="689,269" P2="788,269"/><JD c="000000,6,1,0" P1="113,399" P2="10,399"/><JD c="000000,6,1,0" P1="689,399" P2="788,399"/><JD c="1500fb,3,1,0" P1="166,320" P2="166,348"/><JD c="1500fb,3,1,0" P1="634,320" P2="634,348"/><JD c="1500fb,3,1,0" P1="450,350" P2="450,378"/><JD c="1500fb,3,1,0" P1="319,350" P2="319,378"/><JD c="000000,6,1,0" P1="788,35" P2="788,633"/><JD c="1500fb,3,1,0" P1="269,320" P2="269,348"/><JD c="1500fb,3,1,0" P1="532,320" P2="532,348"/><JD c="1500fb,3,1,0" P1="62,320" P2="62,348"/><JD c="1500fb,3,1,0" P1="738,320" P2="738,348"/><JD c="1500fb,3,1,0" P1="480,350" P2="480,378"/><JD c="1500fb,3,1,0" P1="349,350" P2="349,378"/><JD c="1500fb,3,1,0" P1="429,40" P2="429,61"/><JD c="1500fb,3,1,0" P1="372,40" P2="372,61"/><JD c="1500fb,3,1,0" P1="429,628" P2="429,607"/><JD c="1500fb,3,1,0" P1="372,628" P2="372,607"/><JD c="1500fb,3,1,0" P1="295,92" P2="295,140"/><JD c="1500fb,3,1,0" P1="507,92" P2="507,140"/><JD c="1500fb,3,1,0" P1="294,578" P2="294,530"/><JD c="1500fb,3,1,0" P1="505,579" P2="505,531"/><JD c="1500fb,3,1,0" P1="165,40" P2="165,86"/><JD c="1500fb,3,1,0" P1="637,40" P2="637,86"/><JD c="1500fb,3,1,0" P1="164,628" P2="164,582"/><JD c="1500fb,3,1,0" P1="637,628" P2="637,582"/><JD c="1500fb,3,1,0" P1="429,61" P2="373,61"/><JD c="1500fb,3,1,0" P1="429,607" P2="373,607"/><JD c="1500fb,3,1,0" P1="323,141" P2="295,141"/><JD c="1500fb,3,1,0" P1="479,141" P2="507,141"/><JD c="1500fb,3,1,0" P1="269,348" P2="224,348"/><JD c="1500fb,3,1,0" P1="532,348" P2="577,348"/><JD c="1500fb,3,1,0" P1="269,320" P2="224,320"/><JD c="1500fb,3,1,0" P1="532,320" P2="577,320"/><JD c="1500fb,3,1,0" P1="322,529" P2="294,529"/><JD c="1500fb,3,1,0" P1="477,530" P2="505,530"/><JD c="1500fb,3,1,0" P1="197,86.17" P2="166,86.17"/><JD c="1500fb,3,1,0" P1="605,86.17" P2="636,86.17"/><JD c="1500fb,3,1,0" P1="196,581.83" P2="165,581.83"/><JD c="1500fb,3,1,0" P1="605,581.83" P2="636,581.83"/><JD c="1500fb,3,1,0" P1="166,320" P2="63,320"/><JD c="1500fb,3,1,0" P1="634,320" P2="737,320"/><JD c="1500fb,3,1,0" P1="450,350" P2="480,350"/><JD c="1500fb,3,1,0" P1="319,350" P2="349,350"/><JD c="1500fb,3,1,0" P1="166,348" P2="63,348"/><JD c="1500fb,3,1,0" P1="634,348" P2="737,348"/><JD c="1500fb,3,1,0" P1="450,378" P2="480,378"/><JD c="1500fb,3,1,0" P1="319,378" P2="349,378"/><JD c="000000,3,1,0" P1="219.84,323" P2="243.25,323"/><JD c="000000,3,1,0" P1="581.16,323" P2="557.75,323"/><JD c="000000,3,1,0" P1="223,323" P2="223,344"/><JD c="000000,3,1,0" P1="578,323" P2="578,344"/><JD c="000000,3,1,0" P1="169,629" P2="191,629"/><JD c="000000,3,1,0" P1="632,629" P2="610,629"/><JD c="000000,3,1,0" P1="297,579" P2="317,579"/><JD c="000000,3,1,0" P1="502,580" P2="482,580"/><JD c="000000,3,1,0" P1="298,91" P2="318,91"/><JD c="000000,3,1,0" P1="504,91" P2="484,91"/><JD c="000000,3,1,0" P1="170,39" P2="192,39"/><JD c="000000,3,1,0" P1="632,39" P2="610,39"/><JD c="000000,3,1,0" P1="377,629" P2="425,629"/><JD c="000000,3,1,0" P1="377,39" P2="425,39"/><JD c="000000,3,1,0" P1="219.84,345" P2="243.25,345"/><JD c="000000,3,1,0" P1="581.16,345" P2="557.75,345"/><JD c="000000,3,1,0" P1="193,631" P2="193,608"/><JD c="000000,3,1,0" P1="608,631" P2="608,608"/><JD c="000000,3,1,0" P1="319,581" P2="319,558"/><JD c="000000,3,1,0" P1="480,583" P2="480,560"/><JD c="000000,3,1,0" P1="320,87" P2="320,112"/><JD c="000000,3,1,0" P1="482,87" P2="482,112"/><JD c="000000,3,1,0" P1="194,37" P2="194,60"/><JD c="000000,3,1,0" P1="608,37" P2="608,60"/><JD c="000000,3,1,0" P1="426,631" P2="426,617"/><JD c="000000,3,1,0" P1="375,631" P2="375,617"/><JD c="000000,3,1,0" P1="426,37" P2="426,51"/><JD c="000000,3,1,0" P1="375,37" P2="375,51"/><JD c="000000,3,1,0" P1="167,631" P2="167,608"/><JD c="000000,3,1,0" P1="634,631" P2="634,608"/><JD c="000000,3,1,0" P1="297,581" P2="297,558"/><JD c="000000,3,1,0" P1="502,582" P2="502,559"/><JD c="000000,3,1,0" P1="298,89" P2="298,112"/><JD c="000000,3,1,0" P1="504,89" P2="504,112"/><JD c="000000,3,1,0" P1="168,37" P2="168,60"/><JD c="000000,3,1,0" P1="634,37" P2="634,60"/></L></Z></C>]]}
pacmice_maps["pacmice_5"].pathes = {{1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}, {8, 1}, {9, 1}, {10, 1}, {11, 1}, {12, 1}, {13, 1}, {17, 1}, {18, 1}, {19, 1}, {20, 1}, {21, 1}, {22, 1}, {25, 1}, {26, 1}, {27, 1}, {28, 1}, {29, 1}, {1, 2}, {5, 2}, {8, 2}, {13, 2}, {14, 2}, {15, 2}, {16, 2}, {17, 2}, {22, 2}, {25, 2}, {29, 2}, {1, 3}, {2, 3}, {3, 3}, {5, 3}, {6, 3}, {7, 3}, {8, 3}, {9, 3}, {10, 3}, {13, 3}, {15, 3}, {17, 3}, {20, 3}, {21, 3}, {22, 3}, {23, 3}, {24, 3}, {25, 3}, {27, 3}, {28, 3}, {29, 3}, {1, 4}, {3, 4}, {5, 4}, {10, 4}, {13, 4}, {15, 4}, {17, 4}, {20, 4}, {25, 4}, {27, 4}, {29, 4}, {1, 5}, {3, 5}, {5, 5}, {6, 5}, {7, 5}, {8, 5}, {9, 5}, {10, 5}, {11, 5}, {12, 5}, {13, 5}, {15, 5}, {17, 5}, {18, 5}, {19, 5}, {20, 5}, {21, 5}, {22, 5}, {23, 5}, {24, 5}, {25, 5}, {27, 5}, {29, 5}, {1, 6}, {3, 6}, {4, 6}, {5, 6}, {9, 6}, {15, 6}, {21, 6}, {25, 6}, {26, 6}, {27, 6}, {29, 6}, {1, 7}, {5, 7}, {7, 7}, {8, 7}, {9, 7}, {11, 7}, {12, 7}, {13, 7}, {14, 7}, {15, 7}, {16, 7}, {17, 7}, {18, 7}, {19, 7}, {21, 7}, {22, 7}, {23, 7}, {25, 7}, {29, 7}, {1, 8}, {2, 8}, {3, 8}, {4, 8}, {5, 8}, {7, 8}, {9, 8}, {11, 8}, {19, 8}, {21, 8}, {23, 8}, {25, 8}, {26, 8}, {27, 8}, {28, 8}, {29, 8}, {5, 9}, {7, 9}, {9, 9}, {11, 9}, {19, 9}, {21, 9}, {23, 9}, {25, 9}, {1, 10}, {2, 10}, {3, 10}, {4, 10}, {5, 10}, {6, 10}, {7, 10}, {9, 10}, {10, 10}, {11, 10}, {19, 10}, {20, 10}, {21, 10}, {23, 10}, {24, 10}, {25, 10}, {26, 10}, {27, 10}, {28, 10}, {29, 10}, {1, 11}, {7, 11}, {11, 11}, {12, 11}, {13, 11}, {14, 11}, {15, 11}, {16, 11}, {17, 11}, {18, 11}, {19, 11}, {23, 11}, {29, 11}, {1, 12}, {7, 12}, {11, 12}, {14, 12}, {16, 12}, {19, 12}, {23, 12}, {29, 12}, {1, 13}, {2, 13}, {3, 13}, {4, 13}, {5, 13}, {6, 13}, {7, 13}, {9, 13}, {10, 13}, {11, 13}, {14, 13}, {16, 13}, {19, 13}, {20, 13}, {21, 13}, {23, 13}, {24, 13}, {25, 13}, {26, 13}, {27, 13}, {28, 13}, {29, 13}, {5, 14}, {7, 14}, {9, 14}, {11, 14}, {12, 14}, {13, 14}, {14, 14}, {16, 14}, {17, 14}, {18, 14}, {19, 14}, {21, 14}, {23, 14}, {25, 14}, {1, 15}, {2, 15}, {3, 15}, {4, 15}, {5, 15}, {7, 15}, {9, 15}, {11, 15}, {19, 15}, {21, 15}, {23, 15}, {25, 15}, {26, 15}, {27, 15}, {28, 15}, {29, 15}, {1, 16}, {5, 16}, {7, 16}, {8, 16}, {9, 16}, {11, 16}, {12, 16}, {13, 16}, {14, 16}, {15, 16}, {16, 16}, {17, 16}, {18, 16}, {19, 16}, {21, 16}, {22, 16}, {23, 16}, {25, 16}, {29, 16}, {1, 17}, {3, 17}, {4, 17}, {5, 17}, {9, 17}, {15, 17}, {21, 17}, {25, 17}, {26, 17}, {27, 17}, {29, 17}, {1, 18}, {3, 18}, {5, 18}, {6, 18}, {7, 18}, {8, 18}, {9, 18}, {10, 18}, {11, 18}, {12, 18}, {13, 18}, {15, 18}, {17, 18}, {18, 18}, {19, 18}, {20, 18}, {21, 18}, {22, 18}, {23, 18}, {24, 18}, {25, 18}, {27, 18}, {29, 18}, {1, 19}, {3, 19}, {5, 19}, {10, 19}, {13, 19}, {15, 19}, {17, 19}, {20, 19}, {25, 19}, {27, 19}, {29, 19}, {1, 20}, {2, 20}, {3, 20}, {5, 20}, {6, 20}, {7, 20}, {8, 20}, {9, 20}, {10, 20}, {13, 20}, {15, 20}, {17, 20}, {20, 20}, {21, 20}, {22, 20}, {23, 20}, {24, 20}, {25, 20}, {27, 20}, {28, 20}, {29, 20}, {1, 21}, {5, 21}, {8, 21}, {13, 21}, {14, 21}, {15, 21}, {16, 21}, {17, 21}, {22, 21}, {25, 21}, {29, 21}, {1, 22}, {2, 22}, {3, 22}, {4, 22}, {5, 22}, {8, 22}, {9, 22}, {10, 22}, {11, 22}, {12, 22}, {13, 22}, {17, 22}, {18, 22}, {19, 22}, {20, 22}, {21, 22}, {22, 22}, {25, 22}, {26, 22}, {27, 22}, {28, 22}, {29, 22}}
pacmice_maps["pacmice_5"].foods = {{x = 87, y = 61}, {x = 282 , y = 61}, {x = 517, y = 61}, {x = 716, y = 61}, {x = 400, y = 88}, {x = 400, y = 218}, {x = 400, y = 330}, {x = 400, y = 522}, {x = 87, y = 195}, {x = 716, y = 195}, {x = 36, y = 330}, {x = 245, y = 373}, {x = 193, y = 452}, {x = 87, y = 517}, {x = 281, y = 610}, {x = 512, y = 610}, {x = 712, y = 519}, {x = 609, y = 452}, {x = 546, y = 373}, {x = 762, y = 330}}
-- rotation
rotations["pacmice"] = Rotation:New({items = {}})
-- pshy mapdbs
for i_map, map in pairs(pacmice_maps) do
local mapname = "pacmice_" .. tostring(i_map)
maps[mapname] = pacmice_maps[i_map]
map.replace_func = pacmice_GetMap
map.autoskip = false
table.insert(rotations["pacmice"].items, mapname)
end
-- colors
pacmice_map_colors = {"0000ff", "00ff00", "ff0000", "ffff00", "00ffff", "ff00ff", "ff7700", "d200ff"}
pacmice_map_color_index = math.random(#pacmice_map_colors)
-- food images
pacmice_food_images = {"17ae46fd894.png", "17ae46ff007.png", "17ae4700777.png", "17ae4701ee9.png", "17ae4703658.png", "17ae4704dcc.png", "17ae4706540.png", "17ae4707cb0.png", "17ae4709422.png", "17ae470ab94.png", "17ae470c307.png", "17ae470da77.png", "17ae470f1e8.png", "17ae4710959.png", "17ae47120dd.png", "17ae471383b.png", "17ae4714fad.png", "17ae4716720.png", "17ae4717e93.png", "17ae4719605.png"}
--- Internal use:
pacmice_map = nil				-- current map
pacmice_cur_pilot = nil			-- for generating pathes
pacmice_cur_x = 0
pacmice_cur_y = 0
pacmice_cur_generating = false
pacmice_auto_generating = false
pacmice_auto_x = nil
pacmice_auto_y = nil
pacmice_auto_object_id = nil
pacmice_pacmans = {}			-- map of pacmouces (key is the player name)
pacmice_auto_respawn = true
pacmice_pacmouse_count = 0
pacmice_round_over = false
pacmice_animations = {}
pacmice_animations[1] = {"17afe1cf978.png", "17afe1ce20a.png"}
pacmice_animations[2] = {"17afe2a6882.png", "17afe1d18bc.png"}
--- Custom bonus for pacmice foods
function pacmice_FoodGrabbedCallback(player_name, bonus)
scores.Add(player_name, 2)
--bonuses.Disable(bonus.id)
end
for i_image, image_name in pairs(pacmice_food_images) do
bonus_types[image_name] = {image = image_name, func = pacmice_FoodGrabbedCallback}
end
--- For every player, or when a player joins.
function pacmice_TouchPlayer(player_name)
ui.addTextArea(pacmice_arbitrary_help_btn_id, "<p align='center'><font size='12'><a href='event:pcmd help'>help</a></font></p>", player_name, 5, 25, 40, 20, 0x111111, 0xFFFF00, 0.2, true)
end
--- Alive mice count.
function pacmice_CountMiceAlive()
local count = 0
for player_name, player in pairs(tfm.get.room.playerList) do
if not player.isDead and not pacmice_pacmans[player_name] then
count = count + 1
end
end
return count
end
--- Pop the best player's score.
function pacmice_PopBestScorePlayer()
local best_player_name = nil
for player_name in pairs(tfm.get.room.playerList) do
if not best_player_name or scores.scores[player_name] > scores.scores[best_player_name] then
best_player_name = player_name
end
end
return best_player_name
end
local function HidePacmicePlayers()
tfm.exec.addPhysicObject(24, pacmice_map.web_x, 200, {type = tfm.enum.ground.rectangle, width = 200, height = 4000, foreground = true, color = 0x010101, miceCollision = false})
end
--- TFM event eventNewGame()
-- Make the next pacmouse.
function eventNewGame()
-- more accurate intervals
loopmore.SetInterval(250)
-- misc
ui.setMapName("PAC-MICE")
-- spawn scrolling
tfm.exec.addPhysicObject(21, pacmice_map.web_x - 20, 200, {type = tfm.enum.ground.invisible, width = 10, height = 5000, foreground = false, color = 0x1, miceCollision = true})
tfm.exec.addPhysicObject(22, pacmice_map.web_x + 20, 200, {type = tfm.enum.ground.invisible, width = 10, height = 5000, foreground = false, color = 0x1, miceCollision = true})
tfm.exec.addPhysicObject(23, pacmice_map.web_x, pacmice_map.y + pacmice_map.grid_h * pacmice_map.cell_h, {type = tfm.enum.ground.rectangle, width = 200, height = 20, foreground = true, color = 0xff0000, miceCollision = true})
HidePacmicePlayers()
pacmice_round_over = false
if pacmice_cur_generating or pacmice_cur_pilot then
return
end
if pacmice_CountMiceAlive() >= 1 then
local pacmouse_player = pacmice_PopBestScorePlayer()
pacmice_CreatePacman(pacmouse_player)
if pacmice_map.pac_count == 1 or pacmice_CountMiceAlive() <= 1 then
tfm.exec.chatMessage("<b><fc>The pacmouse is now <j>" .. utils_tfm.GetPlayerNick(pacmouse_player) .. "</j></fc></b>", nil)
ui.setShamanName(utils_tfm.GetPlayerNick(pacmouse_player))
else
old_score = scores.scores[pacmouse_player]
scores.scores[pacmouse_player] = 0
local pacmouse_player_2 = pacmice_PopBestScorePlayer()
scores.scores[pacmouse_player] = old_score
pacmice_CreatePacman(pacmouse_player_2)
tfm.exec.chatMessage("<b><fc>The pacmice are now <j>" .. utils_tfm.GetPlayerNick(pacmouse_player) .. "</j> and <j>" .. utils_tfm.GetPlayerNick(pacmouse_player_2) .. "</j></fc></b>", nil)
pacmice_pacmans[pacmouse_player_2].image_animation_number = 2
ui.setShamanName(utils_tfm.GetPlayerNick(pacmouse_player) .. " and " .. utils_tfm.GetPlayerNick(pacmouse_player_2))
end
end
-- add bonuses
for i_bonus, bonus in pairs(pacmice_map.foods) do
local bonus_type = pacmice_food_images[math.random(#pacmice_food_images)]
bonuses.AddNoCopy({type_name = bonus_type, x = bonus.x, y = bonus.y})
end
end
--- Create a pacman.
-- @player Player's Name#0000.
function pacmice_CreatePacman(player_name)
if pacmice_pacmans[player_name] then
--error("should not come here")
pacmice_DestroyPacman(player_name)
end
pacmice_pacmans[player_name] = {}
local pacman = pacmice_pacmans[player_name]
pacman.player_name = player_name
pacman.cell_x = pacmice_map.pathes[#pacmice_map.pathes][1]
pacman.cell_y = pacmice_map.pathes[#pacmice_map.pathes][2]
pacman.cell_vx = -1
pacman.cell_vy = 0
pacman.wish_vx = -1
pacman.wish_vy = 0
pacman.image_id = nil
pacman.direction = 0
pacman.speed = 50
pacman.size = 50
pacman.image_animation_number = pacmice_pacmouse_count % #pacmice_animations + 1
pacman.image_animation_index = 0
pacman.pacman_index = pacmice_pacmouse_count
-- player
tfm.exec.setShaman(player_name, false)
tfm.exec.removeCheese(player_name)
tfm.exec.respawnPlayer(player_name)
tfm.exec.freezePlayer(player_name, true)
tfm.exec.movePlayer(player_name, pacmice_map.web_x, pacman.cell_y * pacmice_map.cell_h + pacmice_map.y, false, 1, 1, false)
tfm.exec.movePlayer(player_name, 0, 0, true, -1, -1, true)
tfm.exec.setPlayerGravityScale(player_name, 0, 0)
--tfm.exec.changePlayerSize(player_name, (pacman.size - 4) / 35 )
pacmice_pacmouse_count = pacmice_pacmouse_count + 1
-- keys
system.bindMouse(player_name, true)
system.bindKeyboard(player_name, keycodes.UP, true, true)
system.bindKeyboard(player_name, keycodes.DOWN, true, true)
system.bindKeyboard(player_name, keycodes.LEFT, true, true)
system.bindKeyboard(player_name, keycodes.RIGHT, true, true)
end
--- Destroy a pacman.
-- @player Player's Name#0000.
function pacmice_DestroyPacman(player_name)
if pacmice_pacmans[player_name] then
local pacman = pacmice_pacmans[player_name]
if pacman.image_id then
tfm.exec.removeImage(pacman.image_id)
end
pacmice_pacmans[player_name] = nil
pacmice_pacmouse_count = pacmice_pacmouse_count - 1
if not pacmice_round_over then
tfm.exec.killPlayer(player_name)
end
tfm.get.room.playerList[player_name].isDead = true
tfm.exec.removePhysicObject(killer_ground_1 + pacman.pacman_index)
scores.Set(player_name, 0)
tfm.exec.setPlayerGravityScale(player_name, 1, 1)
end
end
--- Get a cell screen coordinates.
function pacmice_GetCellDrawCoords(x, y)
local x = x * pacmice_map.cell_w + pacmice_map.x
local y = y * pacmice_map.cell_h + pacmice_map.y
return x, y
end
--- Draw a pacman.
-- @player Player's Name#0000.
function pacmice_DrawPacman(player_name)
local pacman = pacmice_pacmans[player_name]
local x, y = pacmice_GetCellDrawCoords(pacman.cell_x, pacman.cell_y)
local animation = pacmice_animations[pacman.image_animation_number]
-- next image
pacman.image_animation_index = (pacman.image_animation_index + 1) % #animation
local image_code = (animation)[pacman.image_animation_index + 1] -- jerry: 1718e698ac9.png -- pacman:
-- @todo
old_image_id = pacman.image_id
local size = (pacmice_map.cell_w * 2) - pacmice_map.wall_size
--tfm.exec.addPhysicObject(5, x, y, {type = tfm.enum.ground.rectangle, width = size, height = size, foreground = false, color = 0xffff00, miceCollision = false})
pacman.image_id = tfm.exec.addImage(image_code, "!0", x, y, nil, 1.0, 1.0, pacman.direction, 1.0, 0.5, 0.5)
--pacman.image_id = tfm.exec.addImage("1718e698ac9.png", "$" .. player_name, 0, 0, nil, 0.5, 0.5, pacman.direction, 1.0, 0.5, 0.5)
if old_image_id then
tfm.exec.removeImage(old_image_id)
end
-- acid
local ground_id = killer_ground_1 + pacman.pacman_index
tfm.exec.addPhysicObject(killer_ground_1 + pacman.pacman_index, x, y, {type = tfm.enum.ground.invisible, width = size, height = size, foreground = false, miceCollision = true, groundCollision = true, contactListener = true})
-- move the player
tfm.exec.movePlayer(player_name, 0, 0, true, 0, (y - tfm.get.room.playerList[player_name].y) / 5 + pacman.cell_vy * 25, false)
end
--- Get a cell value.
function pacmice_GridGet(x, y)
if x > pacmice_map.grid_w or y > pacmice_map.grid_h then
return false
end
return pacmice_map.linear_grid[y * pacmice_map.grid_w + x]
end
--- Set a cell value.
function pacmice_GridSet(x, y, value)
pacmice_map.linear_grid[y * pacmice_map.grid_w + x] = value
end
--- Redraw the cursor.
function pacmice_DrawCursor()
local x = pacmice_cur_x * pacmice_map.cell_w + pacmice_map.x
local y = pacmice_cur_y * pacmice_map.cell_h + pacmice_map.y
if pacmice_cur_pilot then
tfm.exec.addPhysicObject(23, x + pacmice_map.cell_w / 2, y, {type = tfm.enum.ground.rectangle, width = 5, height = 2000, foreground = false, color = 0xdd4400, miceCollision = false, groundCollision = false})
tfm.exec.addPhysicObject(24, x - pacmice_map.cell_w / 2, y, {type = tfm.enum.ground.rectangle, width = 5, height = 2000, foreground = false, color = 0xdd4400, miceCollision = false, groundCollision = false})
tfm.exec.addPhysicObject(25, x, y + pacmice_map.cell_h / 2, {type = tfm.enum.ground.rectangle, width = 2000, height = 5, foreground = false, color = 0xdd4400, miceCollision = false, groundCollision = false})
tfm.exec.addPhysicObject(26, x, y - pacmice_map.cell_h / 2, {type = tfm.enum.ground.rectangle, width = 2000, height = 5, foreground = false, color = 0xdd4400, miceCollision = false, groundCollision = false})
else
tfm.exec.removeObject(23)
tfm.exec.removeObject(24)
tfm.exec.removeObject(25)
tfm.exec.removeObject(26)
end
end
--- Move the generation cursor, handling colisions.
function pacmice_MoveCursor(x, y)
if not pacmice_cur_generating then
-- map bounds
if x < 0 or y < 0 or x >= pacmice_map.grid_w or y >= pacmice_map.grid_h then
print("out of bounds")
return
end
-- walls
if not pacmice_GridGet(x, y) then
return
end
end
pacmice_cur_x = x
pacmice_cur_y = y
if pacmice_cur_generating then
pacmice_GridSet(x, y, true)
end
end
--- Get a vector from a direction key.
function pacmice_KeycodeToVector(keycode)
if keycode == keycodes.UP then
return 0, -1
elseif keycode == keycodes.DOWN then
return 0, 1
elseif keycode == keycodes.LEFT then
return -1, 0
elseif keycode == keycodes.RIGHT then
return 1, 0
end
end
--- Get a direction from a vector.
function pacmice_VectorToDirection(x, y)
if x == 1 and y == 0 then
return 0
elseif x == 0 and y == 1 then
return (math.pi / 2) * 1
elseif x == -1 and y == 0 then
return (math.pi / 2) * 2
elseif x == 0 and y == -1 then
return (math.pi / 2) * 3
end
error("unexpected")
end
--- Get grid coordinates from a point on screen.
function pacmice_GetGridCoords(x, y)
x = math.floor((x - pacmice_map.x) / pacmice_map.cell_w + 0.5)
y = math.floor((y - pacmice_map.y) / pacmice_map.cell_h + 0.5)
return x, y
end
--- Export the grid.
function pacmice_GridExportPathes(player_name)
local total = "{"
-- generate export string
for y = 0, (pacmice_map.grid_h - 1) do
for x = 0, (pacmice_map.grid_w - 1) do
if pacmice_GridGet(x, y) then
if #total > 1 then
total = total .. ", "
end
total = total .. "{" .. tostring(x) .. ", " .. tostring(y) .. "}"
end
end
end
total = total .. "}"
-- export
while #total > 0 do
subtotal = string.sub(total, 1, 180)
tfm.exec.chatMessage(subtotal, player_name)
total = string.sub(total, 181, #total)
end
end
--- TFM event eventMouse.
function eventMouse(player_name, x, y)
if player_name == pacmice_cur_pilot then
x, y = pacmice_GetGridCoords(x, y)
pacmice_MoveCursor(x, y)
pacmice_DrawCursor()
return true
end
end
--- TFM event eventkeyboard.
function eventKeyboard(player_name, keycode, down, x, y)
if player_name == pacmice_cur_pilot and (keycode == 0 or keycode == 1 or keycode == 2 or keycode == 3) then
vx, vy = pacmice_KeycodeToVector(keycode)
pacmice_MoveCursor(pacmice_cur_x + vx, pacmice_cur_y + vy)
pacmice_DrawCursor()
end
local pacman = pacmice_pacmans[player_name]
if pacman and (keycode == 0 or keycode == 1 or keycode == 2 or keycode == 3) then
pacman.wish_vx, pacman.wish_vy = pacmice_KeycodeToVector(keycode)
end
if room.is_tribehouse then
alternative_timers.RunTimers()
end
end
--- TFM event eventLoop.
function eventLoop(time, time_remaining)
-- auto generating
if pacmice_auto_generating then
-- handle previous
if pacmice_auto_object_id and pacmice_auto_x then
local tfm_object = tfm.get.room.objectList[pacmice_auto_object_id]
if tfm_object and tfm_object.id == pacmice_auto_object_id then
local spawn_x, spawn_y = pacmice_GetCellDrawCoords(pacmice_auto_x, pacmice_auto_y)
if spawn_x == tfm_object.x and spawn_y == tfm_object.y and tfm_object.angle == 0 and tfm_object.vx == 0 and tfm_object.vy == 0 then
pacmice_GridSet(pacmice_auto_x, pacmice_auto_y, true)
else
pacmice_GridSet(pacmice_auto_x, pacmice_auto_y, false)
end
--print("expected x: " .. tostring(spawn_x) " y: " .. tostring(spawn_y) .. " got x: " .. tfm.object.x)
else
return
end
end
-- first
if not pacmice_auto_x then
pacmice_auto_x = 0 -- TODO TODO TODO TODO TODO TODO
pacmice_auto_y = 1 --  TODO TODO TODO TODO TODO
else
pacmice_auto_x = pacmice_auto_x + 1
if pacmice_auto_x >= pacmice_map.grid_w then
pacmice_auto_x = 0
pacmice_auto_y = pacmice_auto_y + 1
tfm.exec.chatMessage("Generating... " .. tostring(math.floor(pacmice_auto_y / pacmice_map.grid_h * 100) .. "%"))
if pacmice_auto_y >= pacmice_map.grid_h then
pacmice_auto_x = nil
pacmice_auto_y = nil
pacmice_auto_generating = false
tfm.exec.chatMessage("Finished generating!")
return
end
end
end
-- spawn object
local spawn_x, spawn_y = pacmice_GetCellDrawCoords(pacmice_auto_x, pacmice_auto_y)
if not pacmice_auto_object_id then
pacmice_auto_object_id = tfm.exec.addShamanObject(tfm.enum.shamanObject.ball, spawn_x, spawn_y, 0, 0, 0, true)
else
tfm.exec.moveObject(pacmice_auto_object_id, spawn_x, spawn_y, false, 0, 0, false, 0, 0)
end
end
-- skip this if generating
if pacmice_cur_generating or pacmice_cur_pilot then
return
end
-- next game
if time_remaining <= 1 then
for player_name, player in pairs(tfm.get.room.playerList) do
if not player.isDead then
tfm.exec.playerVictory(player_name)
scores.Add(player_name, 10)
end
end
end
if time_remaining <= 0 then
pacmice_round_over = true
local pacmans_names = {}
for player_name in pairs(pacmice_pacmans) do
pacmans_names[player_name] = true
end
for player_name in pairs(pacmans_names) do
pacmice_DestroyPacman(player_name)
end
tfm.exec.newGame("pacmice")
elseif pacmice_CountMiceAlive() <= 0 then
tfm.exec.setGameTime(8, false)
else
local is_pacmouse = false
for player_name in pairs(pacmice_pacmans) do
is_pacmouse = true
end
if not is_pacmouse then
tfm.exec.setGameTime(8, false)
end
end
end
--- pshy event eventLoopMore.
function eventLoopMore(time, time_remaining)
for player_name, pacman in pairs(pacmice_pacmans) do
--pacman.cell_x, pacman.cell_y = GetGridCoords(tfm.get.room.playerList[player_name].x, tfm.get.room.playerList[player_name].y)
local wish_x = pacman.cell_x + pacman.wish_vx
local wish_y = pacman.cell_y + pacman.wish_vy
if pacmice_GridGet(wish_x, wish_y) then
pacman.cell_vx = pacman.wish_vx
pacman.cell_vy = pacman.wish_vy
end
if pacman.cell_vx ~= 0 or pacman.cell_vy ~= 0 then
local seen_x = pacman.cell_x + pacman.cell_vx
local seen_y = pacman.cell_y + pacman.cell_vy
if pacmice_GridGet(seen_x, seen_y) then
pacman.cell_x = seen_x
pacman.cell_y = seen_y
pacman.direction = pacmice_VectorToDirection(pacman.cell_vx, pacman.cell_vy)
else
pacman.cell_vx = 0
pacman.cell_vy = 0
end
end
--		pacman.cell_vx = pacman.wish_vx
--		pacman.cell_vy = pacman.wish_vy
--		pacman.direction = VectorToDirection(pacman.cell_vx, pacman.cell_vy)
--		tfm.exec.movePlayer(player_name, 0, 0, true, pacman.cell_vx * pacman.speed, pacman.cell_vy * pacman.speed, false)
pacmice_DrawPacman(player_name)
end
end
--- TFM event eventnewPlayer.
function eventNewPlayer(player_name)
if auto_respawn and not pacmice_pacmans[player_name] then
tfm.exec.respawnPlayer(player_name)
end
-- misc
pacmice_TouchPlayer(player_name)
ui.setMapName("PAC-MICE")
HidePacmicePlayers()
end
--- TFM event eventPlayerWon
function eventPlayerWon(player_name)
if not pacmice_pacmans[player_name] then
if pacmice_round_over then
scores.Add(player_name, 10)
else
scores.Add(player_name, 16)
end
end
end
--- TFM event eventPlayerDied.
function eventPlayerDied(player_name)
if pacmice_pacmans[player_name] then
pacmice_DestroyPacman(player_name)
elseif auto_respawn then
tfm.exec.respawnPlayer(player_name)
else
if not pacmice_round_over then
scores.Add(player_name, 1)
end
end
end
function eventContactListener(player_name, ground_id)
if ground_id == killer_ground_1 or ground_id == killer_ground_2 then
tfm.exec.killPlayer(player_name)
end
end
--- !pacmouse
local function ChatCommandPacmouse(user, target)
target = target or user
if target ~= user then
if target ~= user and not perms.HavePerm(user, "!pacmouse-others") then
return false, "You cant use this command on others :c"
end
local reason
target, reason = utils_tfm.FindPlayerName(target)
if not target then
return false, reason
end
end
if pacmice_pacmans[target] then
pacmice_DestroyPacman(target)
else
if pacmice_pacmouse_count >= 2 then
return false, "Too many pacmice :c"
end
pacmice_CreatePacman(target)
end
end
command_list["pacmouse"] = {perms = "admins", func = ChatCommandPacmouse, desc = "turn into a pacmouse", argc_min = 0, argc_max = 1, arg_types = {"string"}, arg_names = {"Target#0000"}}
help_pages["pacmice"].commands["pacmouse"] = command_list["pacmouse"]
--- !generatepathes
function pacmice_ChatCommandPackmiceGenerate(user, target)
target = target or user
if target ~= user and not perms.HavePerm(user, "!pacmouse-others") then
return false, "You cant use this command on others :c"
end
if pacmice_cur_pilot ~= target or not pacmice_cur_generating then
pacmice_cur_pilot = target
pacmice_cur_generating = true
system.bindMouse(target, true)
system.bindKeyboard(target, keycodes.UP, true, true)
system.bindKeyboard(target, keycodes.DOWN, true, true)
system.bindKeyboard(target, keycodes.LEFT, true, true)
system.bindKeyboard(target, keycodes.RIGHT, true, true)
tfm.exec.freezePlayer(target, true)
tfm.exec.chatMessage("Generating!", user)
else
pacmice_cur_generating = false
pacmice_GridExportPathes(target)
tfm.exec.freezePlayer(target, false)
tfm.exec.chatMessage("No longer generating.", user)
end
end
command_list["generatepathes"] = {perms = "admins", func = pacmice_ChatCommandPackmiceGenerate, desc = "generate the new map's pathes (see source)", argc_min = 0, argc_max = 1, arg_types = {"player"}, arg_names = {"Target#0000"}}
--- !autogeneratepathes
function pacmice_ChatCommandPackmiceGenerate(user)
local target = user
if pacmice_cur_pilot ~= target or not pacmice_auto_generating then
pacmice_cur_pilot = target
pacmice_auto_generating = true
tfm.exec.setWorldGravity(0, 0)
tfm.exec.chatMessage("Auto generating!", user)
else
pacmice_auto_generating = false
pacmice_GridExportPathes(target)
tfm.exec.chatMessage("No longer auto generating.", user)
end
end
command_list["autogeneratepathes"] = {perms = "admins", func = pacmice_ChatCommandPackmiceGenerate, desc = "autogenerate the new map's pathes (see source)", argc_min = 0, argc_max = 0}
--- !skip
function pacmice_ChatCommandSkip(user)
tfm.exec.setGameTime(1)
end
command_list["skip"] = {perms = "admins", func = pacmice_ChatCommandSkip, desc = "skip the map", argc_min = 0, argc_max = 0}
help_pages["pacmice"].commands["skip"] = command_list["skip"]
--- !fasterpacmice
function pacmice_ChatCommandFastpacmouse(user, delay)
delay = delay or 200
if delay < 100 or delay > 500 then
return false, "The delay must be between 100 (fastest) and 500 (slowest)."
end
loopmore.SetInterval(delay)
end
command_list["fasterpacmice"] = {aliases = {"fast"}, perms = "admins", func = pacmice_ChatCommandFastpacmouse, desc = "makes pacmice temporarily faster", argc_min = 0, argc_max = 1, arg_types = {"number"}}
help_pages["pacmice"].commands["fasterpacmice"] = command_list["fasterpacmice"]
--- Initialization:
-- generate other map properties
for i_map, map in pairs(pacmice_maps) do
pacmice_map = map
map.linear_grid = {}
if not map.grid_w then
local max_grid_x, max_grid_y = 1, 1
for i_path, path in ipairs(map.pathes) do
max_grid_x = math.max(max_grid_x, path[1])
max_grid_y = math.max(max_grid_y, path[2])
end
map.grid_w = max_grid_x + 1
map.grid_h = max_grid_y + 1
end
-- load map linear path grid
for i_path, path in ipairs(map.pathes) do
pacmice_GridSet(path[1], path[2], true)
end
end
pacmice_map = pacmice_maps[1]
-- ui
for player_name in pairs(tfm.get.room.playerList) do
pacmice_TouchPlayer(player_name)
end
-- start
tfm.exec.newGame("pacmice")
end
pshy.require("pshy.games.pacmice")
pshy.require("pshy.events").CreateFunctions()
print(string.format("<v>Loaded <ch2>%d files</ch2> in <vp>%d ms</vp>.", #pshy.modules_list, os.time() - pshy.INIT_TIME))
end
local __PSHY_PASTED__ = true
 
